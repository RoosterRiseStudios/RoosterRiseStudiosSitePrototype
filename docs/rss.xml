<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>LambdaBlog: lambda is not a four letter word</title>
        <link>https://thma.github.io/LambdaBlog/</link>
        <description><![CDATA[This feed lists the latest blog posts]]></description>
        <atom:link href="https://thma.github.io/LambdaBlog//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 15 Nov 2020 00:00:00 UT</lastBuildDate>
        <item>
    <title>Using Hakyll with GitHub Pages has become even easier!</title>
    <link>https://thma.github.io/LambdaBlog//posts/2020-11-15-using-hakyll-with-github-pages.html</link>
    <description><![CDATA[<div class="info">
    Posted on November 15, 2020
    
        by Thomas Mahler
    
</div>

<p>Over the weekend I’ve set up a <a href="https://jaspervdj.be/hakyll/">hakyll</a> powered blog on github pages (actually the one you are reading right now).</p>
<p>I’d like to share my findings, as I found an easier way to integrate Hakyll with GitHub Pages.</p>
<h2 id="the-documented-way">The documented way</h2>
<p>I followed the tutorial <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">Using Hakyll with GitHub Pages</a>. This tutorial assumes that the GitHub pages must always be served from the root folder of a github repository.</p>
<p>It then describes a way to achieve this by using a <code>develop</code> branch to do all the Hakyll work and finally writing the contents to the default <code>_site</code> folder. This folder is excluded from version control by entries in the <code>.gitignore</code> file both in the <code>develop</code> and <code>master</code> branches.</p>
<p>So to finally publish the generated site you’ll have to switch to the <code>master</code> branch and copy the contents of the <code>_site</code> folder to the root folder of your project.</p>
<p>I tried this approach and it works nicely.</p>
<p>But then I found out that GitHub pages also allows to use a <code>docs</code> folder as the document root of your GitHub Pages site.</p>
<p>This makes things significantly easier, as you can do all the necessary hakyll tasks and the final publishing on the same <code>master</code> branch.</p>
<h2 id="the-easier-way">The easier way</h2>
<h3 id="github-setup">GitHub setup</h3>
<ol type="1">
<li>If required, create a new GitHub repository for your blog.</li>
<li>If required, create a master branch.</li>
<li>in the Settings of your GitHub project define that the <code>/docs</code> folder from the <code>master</code> branch should be used as document-root of your site. Please refer to the <a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#choosing-a-publishing-source">documentation</a> in case of problems.</li>
<li>Create a .gitignore file with at a minimum, the following entries:</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">_cache/</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">.stack-work/</span></span></code></pre></div>
<h3 id="local-setup">Local setup</h3>
<p>If required, create a new Hakyll project. If you’re a stack user, there is a Hakyll template available that makes this step easy:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">stack</span> new myblog hakyll-template</span></code></pre></div>
<p>Create a .gitignore file in your blog’s directory with at a minimum, the same directories listed as in the GitHub repository. Use the following git commands to setup your local repository:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">git</span> init</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co"># track all the source files for our blog.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="fu">git</span> add .</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co"># make our first commit</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="fu">git</span> commit -m <span class="st">&quot;initial commit.&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co"># and add the GitHub repository as a remote.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="fu">git</span> remote add origin <span class="op">&lt;</span>URL to your GitHub pages repository<span class="op">&gt;</span></span></code></pre></div>
<h3 id="modify-site.hs">Modify site.hs</h3>
<p>In order to make Hakyll generate the site into the <code>docs</code> folder we have to edit the Hakyll Main module (<code>site.hs</code> if you use the stack template) slightly:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">config ::</span> <span class="dt">Configuration</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>config <span class="ot">=</span> defaultConfiguration</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  { destinationDirectory <span class="ot">=</span> <span class="st">&quot;docs&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  hakyllWith config <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="op">...</span></span></code></pre></div>
<h3 id="deployment">Deployment</h3>
<p>So everything’s all setup, and we’re ready to deploy.</p>
<p>We need to be able to run the executable that generates the website, so we need to compile it first. If you are using stack, this can be done using:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ex">stack</span> build</span></code></pre></div>
<p>Next we get a clean build of our site:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ex">stack</span> exec myblog clean</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ex">stack</span> exec myblog build</span></code></pre></div>
<p>After this step you should see a folder <code>docs</code> under your projects root folder, which contains the generated Hakyll site.</p>
<p>Now we commit our changes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">git</span> add -A</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">git</span> commit -m <span class="st">&quot;Publish.&quot;</span></span></code></pre></div>
<p>And send them to GitHub:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="fu">git</span> push origin master:master</span></code></pre></div>
<p>That’s all.</p>
<p>Now your Hakyll site should be visible under your GitHub Pages URL!</p>
<h2 id="view-the-source">View the source</h2>
<p>The source code for this blog post lies under my <a href="https://github.com/thma/thma.github.io">thma.github.io</a> GitHub project. I’ve adopted the composeconference css from <a href="http://katychuang.com/hakyll-cssgarden/gallery/">Katy Chuangs great Hakyll CSS Garden</a> and tweaked it a little bit to look more like GitHub markdown style and to provide some basic responsive design.</p>
<h2 id="update-nov.-24th-2020">Update Nov. 24th 2020</h2>
<p>The Hakyll project has just accepted my pull request for the Using Hakyll with GitHub Pages tutorial, which updates the text according to the findings presented in this post.</p>
<p>The amended version will thus be online shortly, rendering this blog entry kind of obsolete…</p>
]]></description>
    <pubDate>Sun, 15 Nov 2020 00:00:00 UT</pubDate>
    <guid>https://thma.github.io/LambdaBlog//posts/2020-11-15-using-hakyll-with-github-pages.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Implementing Clean Architecture with Haskell and Polysemy</title>
    <link>https://thma.github.io/LambdaBlog//posts/2020-05-29-polysemy-clean-architecture.html</link>
    <description><![CDATA[<div class="info">
    Posted on May 29, 2020
    
        by Thomas Mahler
    
</div>

<p><a href="https://github.com/thma/PolysemyCleanArchitecture/actions"><img src="https://github.com/thma/PolysemyCleanArchitecture/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a></p>
<h2 id="tldr">tl;dr</h2>
<p>This article shows how algebraic effect systems can be used to maintain a clear separation of concerns between different parts of software systems. From a practical programming perspective this improves composability and testability of software components.</p>
<p>I’m demonstrating this idea by using the Polysemy library to implement a multi-layered REST application conforming to the guidelines of the Clean Architecture model.</p>
<h2 id="motivation">Motivation</h2>
<p>While writing <a href="https://github.com/thma/WhyHaskellMatters#readme">Why Haskell Matters</a> I prepared a little demo application that was meant to showcase a cleanly designed REST application in Haskell. In particular, I wanted to demonstrate how the clear separation of <em>pure</em> and <em>impure</em> code helps to provide strict separation of concerns and state-of-the-art testability of all application layers.</p>
<p><strong>I failed!</strong></p>
<p>I was able to write the domain logic in <em>pure</em> code consisting only of <em>total</em> functions. It was a great pleasure to write unit tests for them!</p>
<p>However, as soon as I started writing controllers that coordinate access to the domain logic as well as to a persistence layer to retrieve and store data, I was stuck in the IO Monad. That is, in test cases I was not able to test the controllers independently of the concrete backend.</p>
<p>Then I tried to apply the <em>final tagless</em> pattern for the persistence layer. This allowed abstracting out the concrete persistence layer and writing controller tests with a mocked persistence backend. But when it came to testing the REST API handlers (written with Servant) I was again stuck in the IO Monad as the Handler type is defined as <code>newtype Handler a = Handler { runHandler' :: ExceptT ServerError IO a }</code>. Maybe it’s not a principle issue but just my brain being too small…</p>
<p>I was desperately looking for something that allowed me to combine different types of effects (like persistence, logging, configuration, http handlers, error handling, etc.) in controllers and handlers but still to be able to write tests that allow using mocks or stubs to test components in isolation.</p>
<p>As I reached a dead end, I had a look at some of the <em>algebraic effect systems</em> available in Haskell, like eff, extensible-effects, fused-effects, freer-simple and Polysemy.</p>
<p>In algebraic effect systems, effectful programs are split into two separate parts: the specification of the effects to be performed, and the interpretation (or semantics) given to them.</p>
<p>So my idea was to provide special effect interpretations that would allow building mocked effects for my test suite.</p>
<p>After seeing a <a href="https://youtu.be/kIwd1D9m1gE">presentation on maintainable software architecture with Polysemy</a> which answered many of my questions I rewrote my application based on Polysemy powered algebraic effects.</p>
<p>I’m pretty satisfied with the result, and of course I’m eager to share my approach with you!</p>
<h2 id="the-challenge">The Challenge</h2>
<p>A very small boutique restaurant (serving excellent vietnamese food) is looking for a reservation system that allows managing reservations. The restaurant has only twenty seats, they also take only a maximum of twenty reservations per day. (So guests can stay the whole evening and don’t have to leave after some time.) (I adopted this scenario from a inspiring <a href="https://youtu.be/US8QG9I1XW0">talk by Mark Seemann</a>)</p>
<p>They have asked us to write the REST backend for their reservation system.</p>
<p>The chef insists on a scrupulously clean kitchen and is also a lover of clean code. He has read about clean architecture and wants his new software to be a perfect example!</p>
<p>So we cannot just hack away but first have to understand what is expected from us when we are to deliver a clean architecture.</p>
<h2 id="what-makes-a-clean-architecture">What makes a Clean Architecture ?</h2>
<p>I’m following the introduction to clean architecture by Robert C. Martin on his <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Code blog</a>. He states that his concept builds up on several earlier approaches like <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">hexagonal architecture</a>, <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">ports and adapters</a> or <a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">Onion Architecture</a>.</p>
<p>According to him all these approaches share a similar objective: achieve separation of concerns by dividing a software system into different layers. All approaches result in system designs that share a common set of features:</p>
<ol type="1">
<li><p>The architecture does not depend on any specific software libraries or frameworks. This allows to freely choose such tools according to the actual needs. This avoids “vendor lock in”.</p></li>
<li><p>High testability. The business logic can be tested without any external element like UI, DB, Web Server, etc.</p></li>
<li><p>The UI is loosely coupled to the core system. So it can be easily changed or replaced without affecting the rest of the system.</p></li>
<li><p>The Database is also “external” to the core system. It can be easily changed (even from an RDBMS to NonSQL DB) without affecting the business logic.</p></li>
<li><p>The Business logic is agnostic of the outside world. It has no dependencies to any external systems like DB, ESB, etc.</p></li>
</ol>
<h3 id="layers-with-clearly-separated-responsibilities">Layers with clearly separated responsibilities</h3>
<p>The architecture consists of four layers, each of which contains components with a specific scope and a limited set of responsibilities.</p>
<ol type="1">
<li><p>At the centre sits the <strong>Domain</strong> layer consisting of entities and core business logic.</p></li>
<li><p>Next comes the <strong>Use Cases</strong> layer where all resources are coordinated that are required to fulfill a given use case. In particular, it uses entities and logic from the domain layer to implement use cases. But typically it must also interface to a persistent storage to retrieve and store entities.</p></li>
<li><p>The <strong>Interface Adapters</strong> layer holds code for UI controllers and presenters as well as adapters to external resources like databases, message queues, configuration, Logging, etc.</p></li>
<li><p>The <strong>External Interfaces</strong> layer contains the technical implementation of external interfaces. For example, a concrete REST service assembly, Web and UI infrastructure, databases, etc.</p></li>
</ol>
<h3 id="the-dependency-rule">The Dependency Rule</h3>
<blockquote>
<p>The overriding rule that makes this architecture work is The Dependency Rule. This rule says that source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.</p>
<p>Quoted from <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>This dependency rule leads to a very interesting consequence: If a use case interactor needs to access a component from an outer circle, e.g. retrieve data from a database, this must be done in a specific way in order to avoid breaking the dependency rule: In the use case layer we don’t have any knowledge about the components of the outer circles. <strong>If we require access to a database (or any other external resources), the call interface, as well as the data transfer protocol must be specified in the use case layer.</strong></p>
<p>The components in the outer circles will then implement this interface. Using this kind of interfaces, it is possible to communicate accross the layer boundaries, but still maintain a strict separation of concerns.</p>
<p>If you want to dive deeper into clean architecture I recommend the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a> as an entry point. Robert C. Martin later also published a whole book <a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</a> on this concept.</p>
<p>In the following sections I’ll explain how the clean architecture guidelines can be implemented in a Haskell REST API application by making use of the algebraic effect library <a href="https://github.com/polysemy-research/polysemy#readme">Polysemy</a>.</p>
<h2 id="the-domain-layer">The Domain layer</h2>
<p>The <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/Domain/ReservationDomain.hs">ReservationDomain</a> module implements the business logic for seat reservations in a very small boutique restaurant. The restaurant has only one big table with 20 seats. Each day the restaurants accepts only 20 reservations. (There is no limited time-slot for each guest.)</p>
<p>Please note: - all functions in this module are <strong>pure</strong> (they don’t do any IO) and <strong>total</strong> (they produce defined results for all possible input values).</p>
<ul>
<li>The definitions in this module do not have dependencies to anything from the outer circles.</li>
</ul>
<p>At the core of our Domain lies the <code>Reservation</code> data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- | a data type representing a reservation</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Reservation</span> <span class="ot">=</span> <span class="dt">Reservation</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    {<span class="ot"> date     ::</span> <span class="dt">Day</span>     <span class="co">-- ^ the date of the reservation</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    ,<span class="ot"> name     ::</span> <span class="dt">String</span>  <span class="co">-- ^ the name of the guest placing the reservation</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    ,<span class="ot"> email    ::</span> <span class="dt">String</span>  <span class="co">-- ^ the email address of the guest</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    ,<span class="ot"> quantity ::</span> <span class="dt">Natural</span> <span class="co">-- ^ how many seats are requested</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Generic</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>This type can be used to express facts like <em>Mr. Miller reserved two seats on 2020-06-01, he can be reached via his email address: manfred@miller.com</em>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>reservation <span class="ot">=</span> <span class="dt">Reservation</span> {name <span class="ot">=</span> <span class="st">&quot;Mr. Miller&quot;</span>, quantity <span class="ot">=</span> <span class="dv">2</span>, date <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;2020-06-01&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;manfred@miller.com&quot;</span>}</span></code></pre></div>
<p>All reservations of a specific day are represented as a list of reservations: <code>[Reservation]</code>.</p>
<p>A <code>ReservationMap</code> is a map from <code>Day</code> to <code>[Reservation]</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">-- | a key value map holding a list of reservations for any given day</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ReservationMap</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Day</span> [<span class="dt">Reservation</span>]</span></code></pre></div>
<p>That is, we can keep track of all reservations by maintaining them in such a map:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>fromList </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  [</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    (</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>      <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        [</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>          <span class="dt">Reservation</span> {date <span class="ot">=</span> <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>, name <span class="ot">=</span> <span class="st">&quot;Mr. Miller&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;manfred@miller.com&quot;</span>, quantity <span class="ot">=</span> <span class="dv">2</span>}, </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>          <span class="dt">Reservation</span> {date <span class="ot">=</span> <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>, name <span class="ot">=</span> <span class="st">&quot;Andrew M. Jones&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;amjones@example.com&quot;</span>, quantity <span class="ot">=</span> <span class="dv">4</span>}</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        ]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    )</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Based on these data types we can define domain logic like computing the used capacity of a list of reservations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- | computes the number of reserved seats for a list of reservations</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">usedCapacity ::</span> [<span class="dt">Reservation</span>] <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>usedCapacity [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>usedCapacity (<span class="dt">Reservation</span> _ _ _ quantity <span class="op">:</span> rest) <span class="ot">=</span> quantity <span class="op">+</span> usedCapacity rest</span></code></pre></div>
<p>Based on this we can compute the number of available seats (given a maximum capacity and a list of reservations):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- | computes the number of available seats from a maximum capacity and a list of reservations.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">availableSeats ::</span> <span class="dt">Natural</span><span class="ot">-&gt;</span> [<span class="dt">Reservation</span>] <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>availableSeats maxCapacity reservations <span class="ot">=</span> maxCapacity <span class="op">-</span> usedCapacity reservations</span></code></pre></div>
<p>The <code>Reservation</code> data type and some of the domain logic functions are depicted in the in the following diagram:</p>
<figure>
<img src="/img/domain.png" alt="" /><figcaption>The Domain layer</figcaption>
</figure>
<h3 id="testing">Testing</h3>
<p>As already mentioned: this layer has no knowledge of the world and it’s all pure code. Testing domain logic in isolation therefore is straight forward, as you can see from the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/DomainSpec.hs">DomainSpec</a> code.</p>
<p>The data types and functions of the domain layer can be used directly, without any mocking of components:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>day <span class="ot">=</span> fromGregorian <span class="dv">2020</span> <span class="dv">1</span> <span class="dv">29</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>res1 <span class="ot">=</span> <span class="dt">Reservation</span> day <span class="st">&quot;Andrew M. Jones&quot;</span> <span class="st">&quot;amjones@example.com&quot;</span> <span class="dv">4</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>res2 <span class="ot">=</span> <span class="dt">Reservation</span> day <span class="st">&quot;Thomas Miller&quot;</span> <span class="st">&quot;tm@example.com&quot;</span> <span class="dv">3</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>reservations <span class="ot">=</span> [res1, res2]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>totalCapacity <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  describe <span class="st">&quot;Domain Logic&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    it <span class="st">&quot;computes the used capacity for an empty list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>      usedCapacity [] <span class="ot">`shouldBe`</span> <span class="dv">0</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>    it <span class="st">&quot;computes the used capacity for a list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>      usedCapacity [res1, res2] <span class="ot">`shouldBe`</span> <span class="dv">7</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>      </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>    it <span class="st">&quot;computes the available seats for a list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>      availableSeats totalCapacity [res1, res2] <span class="ot">`shouldBe`</span> <span class="dv">13</span></span></code></pre></div>
<h2 id="the-use-case-layer">The Use Case layer</h2>
<blockquote>
<p>The software in this layer contains application specific business rules. It encapsulates and implements all of the use cases of the system. These <strong>use cases orchestrate the flow of data to and from the entities, and direct those entities to use their enterprise wide business rules to achieve the goals of the use case.</strong></p>
<p>Quoted from the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>The module <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/UseCases/ReservationUseCase.hs">ReservationUseCase</a> specifies the available use cases for the reservation system. It coordinates access to Effects and the actual domain logic. The module exposes service functions that will be used by the REST API in the ExternalInterfaces layer.</p>
<p>Implemented Use Cases:</p>
<ol type="1">
<li><p>Display the number of available seats for a given day</p></li>
<li><p>Enter a reservation for a given day and keep it persistent. If the reservation can not be served as all seats are occupies provide a functional error message stating the issue.</p></li>
<li><p>Display the list of reservations for a given day.</p></li>
<li><p>Delete a given reservation from the system in case of a cancellation. NO functional error is required if the reservation is not present in the system.</p></li>
<li><p>Display a List of all reservation in the system.</p></li>
</ol>
<p>In the Use Case layer we have left the garden Eden of <em>world agnostic</em> code:</p>
<p>In order to compute the number of available seats for a given day, we will have to first look up the actual reservations for that day from a persistent storage, and only then can we call the domain function <code>availableSeats</code>. In addition we also will have to write a Log message when calling the functions to provide an audit trail.</p>
<p><strong>However, the dependency rule of clean architecture bans all direct access to a database or a logging-infrastructure from the use case layer!</strong></p>
<h3 id="how-can-we-define-such-a-use-case-without-violating-the-dependency-rule">How can we define such a use case without violating the dependency rule?</h3>
<p>Algebraic Effect systems offer a consistent answer: 1. We <strong>declare effects</strong> in the use case layer by defining them as an abstract interface.</p>
<ol start="2" type="1">
<li><p>We also specify the actual <strong>usage of effects</strong> in the use case layer by having calls against the abstract interface.</p></li>
<li><p>We provide an <strong>interpretation</strong> of these effects only in the outer layers. This also allows us to provide different implementations. So we can easily swap backends, e.g. migrating from MySQL to PostgreSQL, and it can be used to provide mock implementations for testing purposes.</p></li>
</ol>
<p>Let’s see how all this looks like when using Polysemy.</p>
<h3 id="usage-of-effects">Usage of effects</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- | compute the number of available seats for a given day. the result must be a natural number, incl. 0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">availableSeats ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">Natural</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>availableSeats day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;compute available seats for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  todaysReservations <span class="ot">&lt;-</span> fetch day</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> Dom.availableSeats maxCapacity todaysReservations</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">-- | fetch the list of reservations for a given day from the key value store.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">--   If no match is found, an empty list is returned.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">-- | the maximum capacity of the restaurant.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="ot">maxCapacity ::</span> <span class="dt">Natural</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>maxCapacity <span class="ot">=</span> <span class="dv">20</span></span></code></pre></div>
<p>The type signature of <code>availableSeats</code> contains two constraints on the <em>effect stack</em> type <code>r</code>: <code>(Member Persistence r, Member Trace r)</code> This means that the function may perform two different effects: persistence via the <code>Persistence</code> effect and Logging via the <code>Trace</code> effect.</p>
<p>The type signature also specifies that we need an input of type <code>Day</code> and will return the <code>Natural</code> result wrapped in the <code>Sem r</code> monad.</p>
<p>The <code>Sem</code> monad handles computations of arbitrary extensible effects. A value of type <code>Sem r</code> describes a program with the capabilities of the effect stack <code>r</code>.</p>
<p>The first step of the function body of <code>availableSeats</code> specifies a Log action based on the (Polysemy built-in) <code>Trace</code> effect:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;compute available seats for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span></code></pre></div>
<p>I repeat: <code>trace</code> does not directly do any logging. The actual logging action - the effect interpretation - will be defined in the application assembly or in a test setup.</p>
<p>The next line specifies a lookup of the reservation list for <code>day</code> from the persistence layer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>  todaysReservations <span class="ot">&lt;-</span> fetch day</span></code></pre></div>
<p>where fetch is defined as:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span></code></pre></div>
<h3 id="declaration-of-effects">Declaration of effects</h3>
<p>To understand the <code>fetch</code> function, in particular the expression <code>maybeList &lt;- getKvs day</code> we first have to know the definition of the <code>Persistence</code> effect:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Persistence</span> <span class="ot">=</span> <span class="dt">KVS</span> <span class="dt">Day</span> [<span class="dt">Dom.Reservation</span>]</span></code></pre></div>
<p>Where KVS (standing for Key/Value Store) is a type that is also defined in the use case layer (<a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/UseCases/KVS.hs">KVS.hs</a>):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">-- | a key value store specified as a GADT</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">KVS</span> k v m a <span class="kw">where</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span><span class="ot"> ::</span> <span class="dt">KVS</span> k v m [(k, v)]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">GetKvs</span><span class="ot">     ::</span> k <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m (<span class="dt">Maybe</span> v)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="dt">InsertKvs</span><span class="ot">  ::</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m ()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span><span class="ot">  ::</span> k <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m ()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;KVS</span></span></code></pre></div>
<p>The four operations of the key value store are defined in the GADT as type constructors. <code>makeSem ''KVS</code> then uses TemplateHaskell to generate effect functions (or smart Constructors) from the GADT definition. This call results in the definition of the following four functions that represent the specific operations of the key value store:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">listAllKvs ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r [(k, v)]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">getKvs     ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> v)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">insertKvs  ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">deleteKvs  ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span></code></pre></div>
<p>These functions can be used in the <code>Sem</code> Monad. So now we understand much better what is going on in <code>fetch</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span></code></pre></div>
<p>As <code>fetch</code> operates in the <code>Sem</code> monad, <code>maybeList</code> is bound to a <code>Maybe [Dom.Reservation]</code> value, which results from the <code>getKVs day</code> action. The function finally uses <code>fromMaybe</code> to return a list of reservations that were retrieved (or <code>[]</code> in case <code>Nothing</code> was found for <code>day</code>).</p>
<p>Then, back in <code>availableSeats</code> we call the domain logic function <code>Dom.availableSeats</code> to compute the number of available seats. The resulting <code>Natural</code> value is lifted into the <code>Sem r</code> monad, thus matching the signature of the return type <code>Sem r Natural</code>.</p>
<p>In the next diagram I’m depicting the layers Use Cases and Domain. The arrow from Use Cases to Domain represents the dependency rule: use case code may only reference domain logic but the domain logic may not reference anything from the use case layer.</p>
<p>On the left side of the diagram we see the use case controllers (aka <em>use case interactors</em>) like <code>availableSeats</code> that coordinate all activities and resources to fulfill a specific use case.</p>
<p>On the right we see the gateway (or interface) code like the <code>KVS</code> abstraction of a key-value store or the <code>fetch</code> operation that wraps the access to the key-value store.</p>
<figure>
<img src="/img/use-cases.png" alt="" /><figcaption>Use Cases layer</figcaption>
</figure>
<h3 id="interpretation-of-effects-testing">Interpretation of effects / Testing</h3>
<p>The key value store functions like <code>getKvs</code> don’t perform any concrete operation. They just <code>declare</code> access to an abstract key-value store interface.</p>
<p>The concrete interpretation of these calls will be specified in the application assembly (typically in <code>Main.hs</code>) or in the setup code of test cases. If we provide a <em>pure</em> interpretation then the resulting code will also be pure. This allows writing tests in the same pure way as for the domain logic.</p>
<p>As an example, in <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/UseCasePureSpec.hs">UseCasePureSpec</a> I’m providing pure interpretations for all effects.</p>
<p>The <code>runPure</code> function takes a program with effects and handles each effect till it gets reduced to <code>Either ReservationError (ReservationMap‚ a)</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">runPure ::</span> <span class="dt">ReservationMap</span> </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>        <span class="ot">-&gt;</span> <span class="dt">Sem</span> &#39;[<span class="dt">UC.Persistence</span>, <span class="dt">State</span> <span class="dt">ReservationMap</span>, <span class="dt">Error</span> <span class="dt">UC.ReservationError</span>, <span class="dt">Trace</span>] a </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UC.ReservationError</span> (<span class="dt">ReservationMap</span>, a)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>runPure kvsMap program <span class="ot">=</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  program</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>     <span class="op">&amp;</span> runKvsPure kvsMap              <span class="co">-- run the key-value store on a simple ReservationMap</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>     <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">UC.ReservationError</span>  <span class="co">-- run error handling to produce an Either UC.ReservationError (ReservationMap, a)</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>     <span class="op">&amp;</span> ignoreTrace                    <span class="co">-- run Trace by simply ignoring all messages </span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>     <span class="op">&amp;</span> run                            <span class="co">-- run a &#39;Sem&#39; containing no effects as a pure value</span></span></code></pre></div>
<p>In addition to that I’m providing wrapping functions like <code>runAvailableSeats</code> that use <code>runPure</code> to interprete the effects of the use case functions (eg. <code>UC.availableSeats</code>) and extract the actual result from the <code>[Either UC.ReservationError (ReservationMap, a)]</code> return value:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">runAvailableSeats ::</span> <span class="dt">ReservationMap</span> <span class="ot">-&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>runAvailableSeats kvsMap day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="kw">case</span> runPure kvsMap (UC.availableSeats day) <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span class="dt">Right</span> (_, numSeats) <span class="ot">-&gt;</span> numSeats</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="dt">Left</span> err            <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;availableSeats failed&quot;</span></span></code></pre></div>
<p>This is all that it takes to abstract away persistence layer, logging facility and exception handling. We can now write tests in pure code:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">-- setting up test fixtures</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="ot">initReservations ::</span> <span class="dt">ReservationMap</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>initReservations <span class="ot">=</span> M.singleton day res</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>day <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;2020-05-02&quot;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>res <span class="ot">=</span> [<span class="dt">Reservation</span> day <span class="st">&quot;Andrew M. Jones&quot;</span> <span class="st">&quot;amjones@example.com&quot;</span> <span class="dv">4</span>]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  describe <span class="st">&quot;Reservation Use Case (only pure code)&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>  </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    it <span class="st">&quot;computes the number of available seats for a given day&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>      (runAvailableSeats initReservations day) <span class="ot">`shouldBe`</span> <span class="dv">16</span></span></code></pre></div>
<h2 id="the-interface-adapters-layer">The Interface Adapters layer</h2>
<p>This layer holds code for adapters to external resources like databases, message queues, configuration, Logging, etc.</p>
<p>The Logging effect <code>Trace</code> ships with Polysemy, so we don’t have to implement anything here. (Of course we could overzealously implement our own Graylog adapter here, Hingegen hat unser <code>reservationServer</code> eine Typensignatur but I leave this as an exercise for the reader… )</p>
<p>However, as the <code>KVS</code> type is our own invention we’ll have to provide our own implementations. (We could have used the <code>KVStore</code> type from <a href="https://hackage.haskell.org/package/polysemy-zoo-0.7.0.0/docs/Polysemy-KVStore.html">polysemy-zoo</a>, but for didactic purposes we will roll our own.)</p>
<p>The following code is the in-memory implementation from the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSInMemory.hs">KVSInMemory</a> module. It defines a key-value store in terms of <code>State (Map k v)</code> that is a <code>Map k v</code> in a <code>State</code> effect context:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">runKvsOnMapState ::</span> ( <span class="dt">Member</span> (<span class="dt">State</span> (<span class="dt">M.Map</span> k v)) r, <span class="dt">Ord</span> k) </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>                 <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>                 <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>runKvsOnMapState <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span>    <span class="ot">-&gt;</span> <span class="fu">fmap</span> M.toList get</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  <span class="dt">GetKvs</span> k      <span class="ot">-&gt;</span> <span class="fu">fmap</span> (M.lookup k) get</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="dt">InsertKvs</span> k v <span class="ot">-&gt;</span> modify <span class="op">$</span> M.insert k v</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span> k   <span class="ot">-&gt;</span> modify <span class="op">$</span> M.delete k</span></code></pre></div>
<p>So whenever the <code>interpret</code> functions detects a <code>GetKvs k</code> value, that was constructed by a call to <code>getKvs k</code> in the use case layer, it pattern-matches it to a <code>Map</code> lookup of <code>k</code> that is executed against state retrieved by <code>get</code>.</p>
<p>Interestingly <code>get</code> is a smart constructor of the <code>State</code> effect. This means that by interpreting the <code>KVS</code> we have created new effects that in turn have to be interpreted.</p>
<p>The <code>runKvsPure</code> functions (which we already have seen in the use case testing) chains interpretation of the effects <code>KVS</code> and <code>State</code> and thus allows us to work with pure Maps as mocks for a key-value store:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">runKvsPure ::</span> <span class="dt">Ord</span> k </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>           <span class="ot">=&gt;</span> <span class="dt">M.Map</span> k v</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>           <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> <span class="dt">State</span> (<span class="dt">M.Map</span> k v) <span class="op">:</span> r) a </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>           <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">M.Map</span> k v, a)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>runKvsPure <span class="fu">map</span> <span class="ot">=</span> runState <span class="fu">map</span> <span class="op">.</span> runKvsOnMapState</span></code></pre></div>
<h3 id="a-key-value-store-with-a-sqlite-backend.">A key-value store with a SQLite backend.</h3>
<p>As we are in the interface adapters layer, we are allowed to get our hands dirty with <em>real world code</em>, like database access. As an example I have provided a SQLite based interpretation of the <code>KVS</code> effect in <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSSqlite.hs">KVSSqllite.hs</a>.</p>
<p>The effect interpreting function is <code>runKvsAsSQLite</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- | Run a KVStore effect against a SQLite backend. Requires a Config object as input.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="ot">runKvsAsSQLite ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>                   <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>                   <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>runKvsAsSQLite <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="dt">GetKvs</span> k      <span class="ot">-&gt;</span> getAction k</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span>    <span class="ot">-&gt;</span> listAction</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>  <span class="dt">InsertKvs</span> k v <span class="ot">-&gt;</span> insertAction k v</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span> k   <span class="ot">-&gt;</span> deleteAction k</span></code></pre></div>
<p>The function’s type signature introduces a two more constraints on the effect stack type <code>r</code>: <code>Member (Embed IO) r</code> and <code>Member (Input Config) r</code>. <code>(Embed IO)</code> is needed as accessing SQLite will require IO, which can be lifted into the <code>Sem r</code> monad with <code>Embed IO</code>.</p>
<p>SQLite always needs a file name to create a database connection. As we want to be able to keep this name configurable, we use the <code>(Input Config)</code> effect. <code>Config</code> is a data type that I created to represent global application configuration, including the database file name. <code>Input</code> is a Polysemy built-in effect which can provide input to an application, quite similar to a <code>Reader</code> monad.</p>
<p>These effects are introduced by the actual implementations of the <code>KVS</code> constructors, like <code>getAction k</code>, which retrieves a value from the database by looking up the key <code>k</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">getAction ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> v)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>getAction key <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  conn <span class="ot">&lt;-</span> connectionFrom input</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  rows <span class="ot">&lt;-</span> embed (SQL.queryNamed conn</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>                      <span class="st">&quot;SELECT key, value FROM store WHERE key = :key&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>                      [<span class="st">&quot;:key&quot;</span> <span class="op">:=</span> <span class="fu">show</span> key]<span class="ot"> ::</span> <span class="dt">IO</span> [<span class="dt">KeyValueRow</span>])</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;get: &quot;</span> <span class="op">++</span> <span class="fu">show</span> rows</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>  <span class="kw">case</span> rows <span class="kw">of</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    []                          <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    (<span class="dt">KeyValueRow</span> _key value)<span class="op">:</span>xs <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> (decode <span class="op">.</span> encodeUtf8) value</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="co">-- | create a connection based on configuration data, make sure table &quot;store&quot; exists.</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="ot">connectionFrom ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">SQL.Connection</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>connectionFrom c <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> c</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>  embed (getConnection (dbPath config))</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a><span class="ot">      getConnection ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SQL.Connection</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>      getConnection dbFile <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>        conn <span class="ot">&lt;-</span> SQL.open dbFile</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a>        SQL.execute_ conn <span class="st">&quot;CREATE TABLE IF NOT EXISTS store (key TEXT PRIMARY KEY, value TEXT)&quot;</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a>        <span class="fu">return</span> conn</span></code></pre></div>
<p>Let’s have a closer look at what is going on in <code>getAction</code>:</p>
<p>First <code>connectionFrom input</code> is used to create a database connection based on the <code>Config</code> object obtained by <code>input</code> (the smart Constructor of the <code>Input</code> effect). The <code>Config</code> type contains a field <code>dbPath</code> which is read and used to create the connection with <code>getConnection</code>. As this is an IO operation we have to use <code>embed</code> to lift it into the <code>Sem r</code> monad.</p>
<p>In the second step <code>SQL.queryNamed</code> is used to perform the actual select statement against the db connection. Again <code>embed</code> must be used to lift this IO operation.</p>
<p>Finally the resulting <code>[KeyValueRow]</code> list is pattern matched: if the list is empty <code>Nothing</code> is returned. Otherwise <code>Aeson.decode</code> is called to unmarshal a result value from the JSON data retrieved from the database.</p>
<p>The JSON encoding and decoding to and from the DB is the reason for the <code>ToJSON v, FromJSON v</code> constraints on the value type <code>v</code>.</p>
<p>This implementation is inspired by key-value store of <a href="https://haskell-explained.gitlab.io/blog/posts/2019/07/31/polysemy-is-cool-part-2/index.html">a password manager in Polysemy</a>.</p>
<h3 id="declaring-the-rest-api">Declaring the REST API</h3>
<p>Our task was to build the backend for the reservation system. We will have to implement a REST API to allow access to the business logic that we defined in the use case layer.</p>
<p>The overall idea is to provide a REST route for all exposed functions of the <code>ReservationUseCase</code>. The following table shows the mapping of those functions to the REST routes that we want to achieve:</p>
<pre><code>listAll        GET    /reservations
fetch          GET    /reservations/YYYY-MM-DD
tryReservation POST   /reservations
cancel         DELETE /reservations
availableSeats GET    /seats/YYYY-MM-DD</code></pre>
<p>I’m using <a href="http://www.servant.dev/">Servant</a> to define our REST API. The great thing about Servant is that it allows us to define REST APIs in a typesafe manner by using a type level DSL.</p>
<p>Here comes the declaration of our API (please note that we declare our routes to accept and emit data in JSON format):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">-- | in order to allow JSON serialization for the Dom.Reservation type, it must instantiate FromJSON and ToJSON.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Dom.Reservation</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Dom.Reservation</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">-- | Declaring the routes of the REST API for Restaurant Reservations</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ReservationAPI</span> <span class="ot">=</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>       <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve a map of all reservations (Day -&gt; [Reservation])&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.ReservationMap</span> <span class="co">-- GET    /reservations</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve list of reservations for a given day&quot;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;day&quot;</span> <span class="dt">Day</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] [<span class="dt">Dom.Reservation</span>]  <span class="co">-- GET    /reservations/YYYY-MM-DD</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;place a new reservation&quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.Reservation</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Post</span>    &#39;[ <span class="dt">JSON</span>] ()                 <span class="co">-- POST   /reservations</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;cancel a reservation&quot;</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.Reservation</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Delete</span>  &#39;[ <span class="dt">JSON</span>] ()                 <span class="co">-- DELETE /reservations</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a>                      </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;seats&quot;</span>        <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve number of free seats for a given day&quot;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;day&quot;</span> <span class="dt">Day</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] <span class="dt">Natural</span>                <span class="co">-- GET    /seats/YYYY-MM-DD</span></span></code></pre></div>
<p>Next we have to create the connection between the declared routes and the actual business logic. This will be our REST service implementation. In our case we simply delegate to the use case controller functions. Off course, we might also implement additional functionality here like validation:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">UseCases.ReservationUseCase</span> <span class="kw">as</span> <span class="dt">UC</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="co">-- | implements the ReservationAPI</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">reservationServer ::</span> (<span class="dt">Member</span> <span class="dt">UC.Persistence</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">UC.ReservationError</span>) r, </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>                      <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r) <span class="ot">=&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> (<span class="dt">Sem</span> r)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>reservationServer <span class="ot">=</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>        UC.listAll        <span class="co">-- GET    /reservations</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.fetch          <span class="co">-- GET    /reservations/YYYY-MM-DD</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.tryReservation <span class="co">-- POST   /reservations</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.cancel         <span class="co">-- DELETE /reservations</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.availableSeats <span class="co">-- GET    /seats/YYYY-MM-DD</span></span></code></pre></div>
<p>I really love how <strong>declarative</strong> this code is. <strong>We don’t have to tell how</strong> to exchange data between the REST server and the use case controllers.</p>
<p>We <strong>just tell what we want</strong>: a mapping from the routes to the controller functions. That’s all!</p>
<p>In the following diagram, we now see the third layer. Again, the arrow symbolises the dependency rule, which prohibits access from domain or use case layer to the interface adapters layer. To the right we see the <code>ReservationAPI</code> and its <code>reservationServer</code> implementation, which we just explored. They interact with the use case controller functions like <code>availableSeats</code>, <code>listAll</code>, etc.</p>
<p>To the left we see the interpretations of the <code>KVS</code> effect (which was defined in the use case layer): <code>KVSInMemory</code>, <code>KVSSqlite</code> (and a third one <code>KVSFileServer</code>, a file based implementation which you could <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSFileServer.hs">explore on your own</a>).</p>
<figure>
<img src="/img/interface-adapters.png" alt="" /><figcaption>Interface Adapters layer</figcaption>
</figure>
<h3 id="testing-the-kvs-implementations">Testing the KVS implementations</h3>
<p>We’ll have a closer look at the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/InterfaceAdaptersKVSSQLiteSpec.hs">test of the SQLite implementation</a> of the <code>KVS</code> effect.</p>
<p>As Polysemy effects are involded we will need to provide an interpretation to actually perform the SQLLite operation.</p>
<p>The test setup looks quite similar to the tests in the use case layer.</p>
<p>We want our test to evaluate the KVS implementation independently of the domain logic and the use case layer. Therefore, we first define an example use case, featuring a data type <code>Memo</code> and a set of typical CRUD operations. The CRUD operations are using the <code>KVS</code> smart constructors and thus exhibit the typical Polysemy effect signatures:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">-- | a key value table mapping Natural to a list of Strings</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">KeyValueTable</span> <span class="ot">=</span> <span class="dt">KVS</span> <span class="dt">Int</span> [<span class="dt">String</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Memo</span> <span class="ot">=</span> <span class="dt">Memo</span> <span class="dt">Int</span> [<span class="dt">String</span>]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="ot">persistMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r)  <span class="ot">=&gt;</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>persistMemo (<span class="dt">Memo</span> <span class="fu">id</span> <span class="fu">lines</span> ) <span class="ot">=</span> insertKvs <span class="fu">id</span> <span class="fu">lines</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="ot">fetchMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> [<span class="dt">String</span>])</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>fetchMemo <span class="ot">=</span> getKvs</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span class="ot">fetchAll ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r (<span class="dt">M.Map</span> <span class="dt">Int</span> [<span class="dt">String</span>])</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>fetchAll <span class="ot">=</span> <span class="fu">fmap</span> M.fromList listAllKvs</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a><span class="ot">deleteMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r)  <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>deleteMemo <span class="ot">=</span> deleteKvs</span></code></pre></div>
<p>Next we define a set of helper functions that allow us to execute the CRUD operations as ordinary <code>IO ()</code> actions, which we can use in our test code:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">-- Helper functions for interpreting all effects in IO</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="ot">runPersist ::</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>runPersist memo <span class="ot">=</span> runAllEffects (persistMemo memo)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">runFetch ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">String</span>])</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>runFetch k <span class="ot">=</span> runAllEffects (fetchMemo k)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a><span class="ot">runFetchAll ::</span> <span class="dt">IO</span> (<span class="dt">M.Map</span> <span class="dt">Int</span> [<span class="dt">String</span>])</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>runFetchAll <span class="ot">=</span> runAllEffects fetchAll</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="ot">runDelete ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>runDelete k <span class="ot">=</span> runAllEffects (deleteMemo k)</span></code></pre></div>
<p>These wrapper function make use of the <code>runAllEffects</code> function that takes a program with effects and handles each effect till it gets reduced to <code>IO a</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">runAllEffects ::</span> <span class="dt">Sem</span> &#39;[<span class="dt">KeyValueTable</span>, <span class="dt">Input</span> <span class="dt">Config</span>, <span class="dt">Trace</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] a <span class="ot">-&gt;</span> <span class="dt">IO</span> a </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>runAllEffects program <span class="ot">=</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  program</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>    <span class="op">&amp;</span> runKvsAsSQLite       <span class="co">-- use SQLite based interpretation of the (KVS Int [String]) effect</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    <span class="op">&amp;</span> runInputConst config <span class="co">-- use the variable config as source for (Input Config) effect</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    <span class="op">&amp;</span> ignoreTrace          <span class="co">-- ignore all traces</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>    <span class="op">&amp;</span> runM                 <span class="co">-- reduce Sem r (Embed IO a) to IO a</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>  <span class="kw">where</span> config <span class="ot">=</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs-test.db&quot;</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, verbose <span class="ot">=</span> <span class="dt">False</span>}</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a><span class="co">-- errors are rethrown as Runtime errors, which can be verified by HSpec.</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a><span class="ot">handleErrors ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> err a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>handleErrors e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>  <span class="fu">either</span> <span class="ot">&lt;-</span> e</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a>  <span class="kw">case</span> <span class="fu">either</span> <span class="kw">of</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a>    <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="fu">return</span> v</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a>    <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;something bad happend&quot;</span></span></code></pre></div>
<p>With these preliminaries at hand we can now write our test cases:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>key <span class="ot">=</span> <span class="dv">4711</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>text <span class="ot">=</span> [<span class="st">&quot;In the morning&quot;</span>, <span class="st">&quot;I don&#39;t drink coffee&quot;</span>, <span class="st">&quot;But lots of curcuma chai.&quot;</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>memo <span class="ot">=</span> <span class="dt">Memo</span> key text</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  describe <span class="st">&quot;The KV Store SQLite Implementation&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>    it <span class="st">&quot;returns Nothing if nothing can be found for a given id&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Nothing</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>    it <span class="st">&quot;persists a key-value pair to the SQLite database&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>      runPersist memo</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Just</span> text</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true"></a>    it <span class="st">&quot;fetches a Map of all key-value entries from the KV store&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true"></a>      <span class="fu">map</span> <span class="ot">&lt;-</span> runFetchAll</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true"></a>      M.size <span class="fu">map</span> <span class="ot">`shouldBe`</span> <span class="dv">1</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true"></a></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true"></a>    it <span class="st">&quot;deletes an entry from the key value store&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true"></a>      runDelete key</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Nothing</span></span></code></pre></div>
<h3 id="testing-the-rest-api">Testing the REST API</h3>
<p>The actual code for testing the REST API looks pretty straightforward. We create a <a href="https://hackage.haskell.org/package/wai">WAI</a> <code>Application</code> instance with <code>createApp</code> and execute REST operations like <code>get</code> and <code>postJSON</code> against it:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">reservationData ::</span> <span class="dt">LB.ByteString</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>reservationData <span class="ot">=</span> <span class="st">&quot;{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:10,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Amelia Jones\&quot;}&quot;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>postJSON   path <span class="ot">=</span> request methodPost   path [(hContentType, <span class="st">&quot;application/json&quot;</span>)]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>deleteJSON path <span class="ot">=</span> request methodDelete path [(hContentType, <span class="st">&quot;application/json&quot;</span>)]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>  with (createApp) <span class="op">$</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>    describe <span class="st">&quot;Rest Service&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a call GET /reservations &quot;</span> <span class="op">$</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>        get <span class="st">&quot;/reservations&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;{\&quot;2020-05-02\&quot;:[{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:4,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Andrew M. Jones\&quot;}]}&quot;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid POST /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>        postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>      it <span class="st">&quot;responds with 412 if a reservation can not be done on a given day&quot;</span> <span class="op">$</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a>        (postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="op">&gt;&gt;</span> postJSON <span class="st">&quot;/reservations&quot;</span> reservationData) <span class="ot">`shouldRespondWith`</span> <span class="dv">412</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid DELETE /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a>        deleteJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span></code></pre></div>
<p>Please note that these tests don’t need a deployment of the WAI application to a web server. ALl testing can be done within a single process. We stick to the dependency rule not to use anything from a more outward layer.</p>
<p>The interesting part is the creation of the <code>Application</code> instance.</p>
<p>If we had a simple implementation <code>myServer</code> of a REST API <code>myApi</code>, not using any Polysemy effects, we could create an <code>Application</code> instance like so:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="ot">createSimpleApp ::</span> <span class="dt">Application</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>createSimpleApp <span class="op">::=</span> serve myApi myServer</span></code></pre></div>
<p>In contrast, our <code>reservationServer</code> has a type signature that contains Polysemy effects:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="ot">reservationServer ::</span> (<span class="dt">Member</span> <span class="dt">UC.Persistence</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">UC.ReservationError</span>) r, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>                      <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r) <span class="ot">=&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> (<span class="dt">Sem</span> r)</span></code></pre></div>
<p>Instead of building the <code>Application</code> instance directly, as in the simple example, we use <code>liftServer</code> to lift <code>reservationServer</code> into the required <code>ServerT ReservationAPI Handler</code> type by running all effects and by lifting the business logic exception <code>ReservationNotPossible</code> into a Servant <code>ServerError</code>. This time we also use the SQLite based interpretation of the <code>KVS</code> effect:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Application</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>createApp config <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> serve reservationAPI (liftServer config)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="ot">liftServer ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> <span class="dt">Handler</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>liftServer config <span class="ot">=</span> hoistServer reservationAPI (interpretServer config) reservationServer</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>    interpretServer config sem <span class="ot">=</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>      sem</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>        <span class="op">&amp;</span> runKvsAsSQLite</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>        <span class="op">&amp;</span> runInputConst config</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>        <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a>        <span class="op">&amp;</span> ignoreTrace</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>        <span class="op">&amp;</span> runM</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>        <span class="op">&amp;</span> liftToHandler</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> (<span class="fu">fmap</span> handleErrors)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 {errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span></code></pre></div>
<h2 id="the-external-interfaces-layer">The External Interfaces layer</h2>
<blockquote>
<p>The outermost layer is generally composed of frameworks and tools such as the Database, the Web Framework, etc. Generally you don’t write much code in this layer other than glue code that communicates to the next circle inwards.</p>
<p>This layer is where all the details go. The Web is a detail. The database is a detail. We keep these things on the outside where they can do little harm.</p>
<p>Quoted from <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>For the database we are already finished as the <a href="https://hackage.haskell.org/package/sqlite-simple">SQlite-Simple</a> library includes the SQLLite C runtime library and is thus self-contained.</p>
<p>We will use <a href="http://www.aosabook.org/en/posa/warp.html">WARP</a> as our Web Server, which can be used as a library within our <code>Main</code> program. What we still have to do though, is to assemble a Servant web <code>Application</code> so that it can be executed on the warp server.</p>
<p>We have done this step already for the testing of the REST service. The <code>createApp</code> function that we define in the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/ExternalInterfaces/ApplicationAssembly.hs">ApplicationAssembly module</a> will look quite familiar, it just provides some more bells and whistles to integrate all the features that we have developed so far.</p>
<ul>
<li><code>createApp</code> accepts a <code>Config</code> parameter which is used to configure application settings.</li>
<li><code>selectKvsBackend</code> selects the concrete <code>KVS</code> interpretation.</li>
<li><code>selectTraceVerbosity</code> selects the <code>Trace</code> interpretation:</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">-- | creates the WAI Application that can be executed by Warp.run.</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Application</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>createApp config <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span class="fu">return</span> (serve reservationAPI <span class="op">$</span> hoistServer reservationAPI (interpretServer config) reservationServer)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>    interpretServer config sem  <span class="ot">=</span>  sem</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>      <span class="op">&amp;</span> selectKvsBackend config</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>      <span class="op">&amp;</span> runInputConst config</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>      <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>      <span class="op">&amp;</span> selectTraceVerbosity config</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>      <span class="op">&amp;</span> runM</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>      <span class="op">&amp;</span> liftToHandler</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> (<span class="fu">fmap</span> handleErrors)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 { errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a><span class="co">-- | can select between SQLite or FileServer persistence backends.</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a><span class="ot">selectKvsBackend ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a>                 <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a>selectKvsBackend config <span class="ot">=</span> <span class="kw">case</span> backend config <span class="kw">of</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a>  <span class="dt">SQLite</span>     <span class="ot">-&gt;</span> runKvsAsSQLite</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>  <span class="dt">FileServer</span> <span class="ot">-&gt;</span> runKvsAsFileServer</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>  <span class="dt">InMemory</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;not supported&quot;</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a><span class="co">-- | if the config flag verbose is set to True, trace to Console, else ignore all trace messages</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a><span class="ot">selectTraceVerbosity ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> (<span class="dt">Sem</span> (<span class="dt">Trace</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a>selectTraceVerbosity config <span class="ot">=</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a>  <span class="kw">if</span> verbose config</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a>    <span class="kw">then</span> traceToIO</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>    <span class="kw">else</span> ignoreTrace</span></code></pre></div>
<p>The application assembly also features a function to load a <code>Config</code> instance. Typically, this would involve loading a configuration file or reading command line arguments. We take a shortcut here and just provide a static instance:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="co">-- | load application config. In real life, this would load a config file or read commandline args.</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="ot">loadConfig ::</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>loadConfig <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs.db&quot;</span>, verbose <span class="ot">=</span> <span class="dt">True</span>}</span></code></pre></div>
<p>With the whole application assembly written as library code, there is not much left to do in the <code>Main</code> module:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.ApplicationAssembly</span> (createApp, loadConfig)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">InterfaceAdapters.Config</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Network.Wai.Handler.Warp</span>               (run)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> loadConfig</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>  app    <span class="ot">&lt;-</span> createApp config</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Starting server on port &quot;</span> <span class="op">++</span> <span class="fu">show</span> (port config)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>  run (port config) app</span></code></pre></div>
<p>The following diagram shows the elements added by the External Interface layer: - On the left we have application assembly code like <code>createApp</code> used by the <code>Warp</code> server or some of the different <code>runPure</code> functions that we used in HSpec tests. - On the right we have the SQLite runtime library that provides access to the SQLite database and the Haskell runtime in general, which provides access to the filesystem and the OS in general.</p>
<figure>
<img src="/img/clean-architecture.png" alt="" /><figcaption>External Interfaces layer</figcaption>
</figure>
<h3 id="testing-1">Testing</h3>
<p>Testing the application assembly is quite straightforward and resembles the testing of the REST service:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="ot">loadConfig ::</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>loadConfig <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs-assembly.db&quot;</span>, verbose <span class="ot">=</span> <span class="dt">False</span>}</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>  with (loadConfig <span class="op">&gt;&gt;=</span> createApp) <span class="op">$</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a>    describe <span class="st">&quot;Rest Service&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a>      it <span class="st">&quot;responds with 20 for a first call to GET /seats/YYYY-MM-DD&quot;</span> <span class="op">$</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a>        get <span class="st">&quot;/seats/2020-05-02&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;20&quot;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid POST /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a>        postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a call GET /reservations &quot;</span> <span class="op">$</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true"></a>        get <span class="st">&quot;/reservations&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;{\&quot;2020-05-02\&quot;:[{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:12,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Amelia Jones\&quot;}]}&quot;</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true"></a></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true"></a>      it <span class="st">&quot;responds with 412 if a reservation can not be done on a given day&quot;</span> <span class="op">$</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true"></a>        (postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="op">&gt;&gt;</span> postJSON <span class="st">&quot;/reservations&quot;</span> reservationData) <span class="ot">`shouldRespondWith`</span> <span class="dv">412</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true"></a>      it <span class="st">&quot;responds with 20 for a first call to GET /seats/YYYY-MM-DD&quot;</span> <span class="op">$</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true"></a>        get <span class="st">&quot;/seats/2020-05-02&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;8&quot;</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid DELETE /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true"></a>        deleteJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span></code></pre></div>
<h2 id="swagger-documentation">Swagger Documentation</h2>
<p>For all those who have been patient enough to stay with me until here, I now have a little bonus.</p>
<p>There is a <a href="https://github.com/haskell-servant/servant-swagger-ui">servant-swagger-ui addon</a> available which allows to serve a <a href="https://swagger.io/tools/swagger-ui/">SwaggerDoc UI</a> for any Servant API. This UI renders an automatically generated documentation of our Reservation API and even allows to test all API operations directly.</p>
<p>You can launch it by executing <code>stack build --exec PolysemyCleanArchitecture</code> in the root folder of the project.</p>
<p>This will launch the REST service and open up the Swagger UI in your Web browser:</p>
<figure>
<img src="/img/swaggerUI.png" alt="" /><figcaption>Swagger UI</figcaption>
</figure>
<p>The code for this goody can be found in the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/app/SwaggerUI.hs">SwaggerUI</a> module.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Robert C. Martin concludes his blog post with a brief summary:</p>
<blockquote>
<p>Conforming to these simple rules is not hard, and will save you a lot of headaches going forward. By separating the software into layers, and conforming to The Dependency Rule, you will create a system that is <strong>intrinsically testable</strong>, with all the benefits that implies. When any of the external parts of the system become obsolete, like the database, or the web framework, you can <strong>replace those obsolete elements with a minimum of fuss</strong>.</p>
<p>Quoted from the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>I have emphasized the testability aspect quite a lot in this article. However, this approach allows switching freely between alternative backends in production environments as well.</p>
<p>As we have seen Polysemy — or algebraic effect systems in general — make this possible by the separation of effect <em>declaration</em>, effect <em>usage</em> and effect <em>interpretation</em>.</p>
<p>Furthermore, Polysemy also allows you to freely combine several effects. This is a huge gain in software composability.</p>
]]></description>
    <pubDate>Fri, 29 May 2020 00:00:00 UT</pubDate>
    <guid>https://thma.github.io/LambdaBlog//posts/2020-05-29-polysemy-clean-architecture.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Proof of functor laws for Maybe</title>
    <link>https://thma.github.io/LambdaBlog//posts/2020-04-17-maybe-functor-law-proof.html</link>
    <description><![CDATA[<div class="info">
    Posted on April 17, 2020
    
        by Thomas Mahler
    
</div>

<p>In this post I want to give a short example of how equational reasoning can be used to proof certain properties of a given piece of code in Haskell.</p>
<p>So without further ado let’s begin:</p>
<h2 id="known-facts">Known facts</h2>
<p>The <code>Functor</code> instance declaration of the type <code>Maybe</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">instance</span>  <span class="dt">Functor</span> <span class="dt">Maybe</span>  <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="fu">fmap</span> _ <span class="dt">Nothing</span>       <span class="ot">=</span> <span class="dt">Nothing</span>       <span class="co">-- (1)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="fu">fmap</span> f (<span class="dt">Just</span> a)      <span class="ot">=</span> <span class="dt">Just</span> (f a)    <span class="co">-- (2)</span></span></code></pre></div>
<p>The composition operator <code>(.)</code> is defined as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>f <span class="op">.</span> g x <span class="ot">=</span> f (g x)                        <span class="co">-- (3)</span></span></code></pre></div>
<p>The Identity function <code>id</code> is defined as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">id</span> x <span class="ot">=</span>  x                                <span class="co">-- (4)</span></span></code></pre></div>
<h2 id="claim">Claim</h2>
<p>The claim is that <code>Maybe</code> fulfils the two functor laws:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dv">1</span><span class="op">.:</span> <span class="fu">fmap</span> <span class="fu">id</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="dv">2</span><span class="op">.:</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="ot">=</span> (<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g)</span></code></pre></div>
<h2 id="proof-of-the-first-law">Proof of the first law</h2>
<p><strong>Claim:</strong> <code>fmap id m = id m</code>, for any <code>m</code> of type <code>Maybe a</code>.</p>
<p><strong>Proof.</strong> On cases of <code>m</code>.</p>
<p><em>Case 1:</em> <code>m = Nothing</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="fu">id</span> m <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">id</span> <span class="dt">Nothing</span> <span class="co">-- by expansion of m</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Nothing</span>         <span class="co">-- by applying equation (1)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>          <span class="ot">=</span> <span class="fu">id</span> m            <span class="co">-- by definition m, by applying equation (4)</span></span></code></pre></div>
<p><em>Case 2:</em> <code>m = Just a</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="fu">id</span> m <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">id</span> (<span class="dt">Just</span> a) <span class="co">-- by expansion of m</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Just</span> (<span class="fu">id</span> a)      <span class="co">-- by applying equation (2)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Just</span> a           <span class="co">-- by expansion of id (equation (4))</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>          <span class="ot">=</span> m                <span class="co">-- by definition of m</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>          <span class="ot">=</span> <span class="fu">id</span> m             <span class="co">-- by applying equation (4)</span></span></code></pre></div>
<p>Therefore, <code>fmap id m = id m</code> in all cases.∎</p>
<h2 id="proof-of-the-second-law">Proof of the second law</h2>
<p><strong>Claim:</strong> <code>fmap (f . g) m = (fmap f . fmap g) m</code>, for any <code>m</code> of type <code>Maybe a</code>.</p>
<p><strong>Proof.</strong> On cases of <code>m</code>.</p>
<p><em>Case 1:</em> <code>m = Nothing</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) m      <span class="ot">=</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="dt">Nothing</span>    <span class="co">-- by expansion of m</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Nothing</span>                 <span class="co">-- by applying equation (1)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>(<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g) m <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g <span class="dt">Nothing</span>) <span class="co">-- by applying equation (4) and expanding m</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="fu">fmap</span> f <span class="dt">Nothing</span>          <span class="co">-- by applying equation (1)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Nothing</span>                 <span class="co">-- by applying equation (1)</span></span></code></pre></div>
<p><em>Case 2:</em> <code>m = Just a</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) m      <span class="ot">=</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) (<span class="dt">Just</span> a)    <span class="co">-- by expansion of m</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> ((f <span class="op">.</span> g) a)         <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>(<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g) m <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g (<span class="dt">Just</span> a)) <span class="co">-- by applying equation (4) and expanding m</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> (g a))      <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> (f (g a)            <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> ((f <span class="op">.</span> g) a)         <span class="co">-- by applying equation (3)</span></span></code></pre></div>
<p>Therefore, <code>fmap (f . g) m = (fmap f . fmap g) m</code> in all cases. ∎</p>
<h2 id="conclusion">Conclusion</h2>
<p>You’ll see this kind of reasoning quite a lot in Haskell documentation and online discussions. The simple reason is: if you can prove something you don’t have to test it.</p>
]]></description>
    <pubDate>Fri, 17 Apr 2020 00:00:00 UT</pubDate>
    <guid>https://thma.github.io/LambdaBlog//posts/2020-04-17-maybe-functor-law-proof.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>
<item>
    <title>Why Haskell Matters</title>
    <link>https://thma.github.io/LambdaBlog//posts/2020-04-01-why-haskell-matters.html</link>
    <description><![CDATA[<div class="info">
    Posted on April  1, 2020
    
        by Thomas Mahler
    
</div>

<h2 id="abstract">Abstract</h2>
<blockquote>
<p>With Haskell, you don’t solve different problems. But you solve them differently.</p>
</blockquote>
<p>In this article I try to explain why Haskell keeps being such an important language by presenting some of its most important and distinguishing features and detailing them with working code examples.</p>
<p>The presentation aims to be self-contained and does not require any previous knowledge of the language.</p>
<p>The target audience are Haskell freshmen and developers with a background in non-functional languages who are eager to learn about concepts of functional programming and Haskell in particular.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#functions-are-first-class">Functions are first class</a>
<ul>
<li><a href="#functions-can-be-assigned-to-variables-exactly-as-any-other-values">Functions can be assigned to variables exactly as any other values</a></li>
<li><a href="#support-for-anonymous-functions">Support for anonymous functions</a></li>
<li><a href="#functions-can-be-returned-as-values-from-other-functions">Functions can be returned as values from other functions</a>
<ul>
<li><a href="#function-composition">Function composition</a></li>
<li><a href="#currying-and-Partial-Application">Currying and Partial Application</a></li>
</ul></li>
<li><a href="#functions-can-be-passed-as-arguments-to-other-functions">Functions can be passed as arguments to other functions</a></li>
</ul></li>
<li><a href="#pattern-matching">Pattern matching</a></li>
<li><a href="#algebraic-data-types">Algebraic Data Types</a></li>
<li><a href="#polymorphic-data-types">Polymorphic Data Types</a>
<ul>
<li><a href="#lists">Lists</a>
<ul>
<li><a href="#arithmetic-sequences">Arithmetic sequences</a></li>
</ul></li>
</ul></li>
<li><a href="#immutability">Immutability</a></li>
<li><a href="#declarative-programming">Declarative programming</a>
<ul>
<li><a href="#mapping">Mapping</a></li>
<li><a href="#folding">Folding</a></li>
</ul></li>
<li><a href="#non-strict-evaluation">Non-strict Evaluation</a>
<ul>
<li><a href="#avoid-endless-loops">Avoid endless loops</a></li>
<li><a href="#define-potentially-infinite-data-structures">Define potentially infinite data structures</a></li>
<li><a href="#list-comprehension">List comprehension</a></li>
<li><a href="#define-control-flow-structures-as-abstractions">Define control flow structures as abstractions</a></li>
</ul></li>
<li><a href="#type-classes">Type Classes</a>
<ul>
<li><a href="#read-and-show">Read and Show</a></li>
<li><a href="#functor-and-foldable">Functor and Foldable</a>
<ul>
<li><a href="#functor">Functor</a></li>
<li><a href="#foldable">Foldable</a></li>
</ul></li>
<li><a href="#the-maybe-monad">The Maybe Monad</a>
<ul>
<li><a href="#total-functions">Total Functions</a></li>
<li><a href="#composition-of-maybe-operations">Composition of Maybe operations</a></li>
</ul></li>
<li><a href="#purity">Purity</a><br />
</li>
<li><a href="#explicit-side-effects-with-the-io-monad">Explicit side effects with the IO Monad</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Exactly thirty years ago, on April 1st 1990, a small group of researchers in the field of non-strict functional programming published the original Haskell language report.</p>
<p>Haskell never became one of the most popular languages in the software industry or part of the mainstream, but it has been and still is quite influential in the software development community.</p>
<p>In this article I try to explain why Haskell keeps being such an important language by presenting some of its most distinguishing features and detailing them with working code examples.</p>
<p>The presentation aims to be self-contained and does not require any previous knowledge of the language. I will also try to keep the learning curve moderate and to limit the scope of the presentation; nevertheless this article is by no means a complete introduction to the language.</p>
<p>(If you are looking for thorough tutorials have a look at <a href="https://en.wikibooks.org/wiki/Haskell">Haskell Wikibook</a> or <a href="http://www.learnyouahaskell.com/.">Learn You a Haskell</a></p>
<p>Before diving directly into the technical details I’d like to first have a closer look on the reception of Haskell in the software developers community:</p>
<h3 id="a-strange-development-over-time">A strange development over time</h3>
<p>In a talk in 2017 on <a href="https://www.youtube.com/watch?v=re96UgMk6GQ">the Haskell journey</a> since its beginnings in the 1980ies Simon Peyton Jones speaks about the rather unusual life story of Haskell.</p>
<p>First he talks about the typical life cycle of research languages. They are often created by a single researcher (who is also the single user), and most of them will be abandoned after just a few years.</p>
<p>A more successful research language might gain some interest in a larger community but will still not escape the ivory tower and typically will be given up within ten years.</p>
<p>On the other hand we have all those popular programming languages that are quickly adopted by large numbers of developers and thus reach “the threshold of immortality”. That is the base of existing code will grow so large that the language will be in use for decades.</p>
<p>A little jokingly he then depicts the sad fate of languages designed by committees by flat line through zero: They simply never take off.</p>
<p>Finally, he presents a chart showing the Haskell timeline:</p>
<figure>
<img src="/img/language-5.png" alt="" /><figcaption>the haskell timeline</figcaption>
</figure>
<p>The development shown in this chart seems rather unexpected: Haskell started as a research language and was even designed by a committee; so in all probability it should have been abandoned long before the millennium!</p>
<p>Instead, it gained some momentum in its early years followed by a rather quiet phase during the decade of OO hype (Java being released in 1995). And then again we see a continuous growth of interest since about 2005. I’m writing this in early 2020, and we still see this trend!</p>
<h3 id="being-used-versus-being-discussed">Being used versus being discussed</h3>
<p>Then Simon Peyton Jones points out another interesting characteristic of the reception of Haskell in recent years: In statistics that rank programming languages by actual usage Haskell is typically not under the 30 most active languages. But in statistics that instead rank languages by the volume of discussions on the internet Haskell typically scores much better (often in the top ten).</p>
<h3 id="so-why-does-haskell-keep-being-a-hot-topic-in-the-software-development-community">So why does Haskell keep being a hot topic in the software development community?</h3>
<p>A very <em>short answer</em> might be: Haskell has a number of features that are clearly different from those of most other programming languages. Many of these features have proven to be powerful tools to solve basic problems of software development elegantly.</p>
<p>Therefore, over time other programming languages have adopted parts of these concepts (e.g. pattern matching or type classes). In discussions about such concepts the Haskell heritage is mentioned and differences between the original Haskell concepts and those of other languages are discussed. Sometimes people feel encouraged to have a closer look at the source of these concepts to get a deeper understanding of their original intentions. That’s why we see a growing number of developers working in Python, Typescript, Scala, Rust, C++, C# or Java starting to dive into Haskell.</p>
<p>A further essential point is that Haskell is still an experimental laboratory for research in areas such as compiler construction, programming language design, theorem-provers, type systems etc. So inevitably Haskell will be a topic in the discussion about these approaches.</p>
<p>In the following sections we will try to find the <em>longer answer</em> by studying some of the most distinguishing features of Haskell.</p>
<h2 id="functions-are-first-class">Functions are First-class</h2>
<blockquote>
<p>In computer science, a programming language is said to have first-class functions if it treats functions as first-class citizens. This means the language supports <strong>passing functions as arguments to other functions</strong>, <strong>returning them as the values from other functions</strong>, and <strong>assigning them to variables or storing them in data structures.</strong>[1] Some programming language theorists require <strong>support for anonymous functions</strong> (function literals) as well.[2] In languages with first-class functions, the names of functions do not have any special status; they are treated like ordinary variables with a function type.</p>
<p>quoted from <a href="https://en.wikipedia.org/wiki/First-class_function">Wikipedia</a></p>
</blockquote>
<p>We’ll go through this one by one:</p>
<h3 id="functions-can-be-assigned-to-variables-exactly-as-any-other-values">Functions can be assigned to variables exactly as any other values</h3>
<p>Let’s have a look how this looks like in Haskell. First we define some simple values:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- define constant `aNumber` with a value of 42. </span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">aNumber ::</span> <span class="dt">Integer</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>aNumber <span class="ot">=</span> <span class="dv">42</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="co">-- define constant `aString` with a value of &quot;hello world&quot;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="ot">aString ::</span> <span class="dt">String</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>aString <span class="ot">=</span> <span class="st">&quot;Hello World&quot;</span></span></code></pre></div>
<p>In the first line we see a type signature that defines the constant <code>aNumber</code> to be of type <code>Integer</code>. In the second line we define the value of <code>aNumber</code> to be <code>42</code>. In the same way we define the constant <code>aString</code> to be of type <code>String</code>.</p>
<p>Haskell is a statically typed language: all type checks happen at compile time. Static typing has the advantage that type errors don’t happen at runtime. This is especially useful if a function signature is changed and this change affects many dependent parts of a project: the compiler will detect the breaking changes at all affected places.</p>
<p>The Haskell Compiler also provides <em>type inference</em>, which allows the compiler to deduce the concrete data type of an expression from the context. Thus, it is usually not required to provide type declarations. Nevertheless, using explicit type signatures is considered good style as they are an important element of a comprehensive documentation.</p>
<p>Next we define a function <code>square</code> that takes an integer argument and returns the square value of the argument:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">square ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>Definition of a function works exactly in the same way as the definition of any other value. The only thing special is that we declare the type to be a <strong>function type</strong> by using the <code>-&gt;</code> notation. So <code>:: Integer -&gt; Integer</code> represents a function from <code>Integer</code> to <code>Integer</code>. In the second line we define function <code>square</code> to compute <code>x * x</code> for any <code>Integer</code> argument <code>x</code>.</p>
<p>Ok, seems not too difficult, so let’s define another function <code>double</code> that doubles its input value:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">double ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>double n <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> n</span></code></pre></div>
<h3 id="support-for-anonymous-functions">Support for anonymous functions</h3>
<p>Anonymous functions, also known as lambda expressions, can be defined in Haskell like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>\x <span class="ot">-&gt;</span> x <span class="op">*</span> x</span></code></pre></div>
<p>This expression denotes an anonymous function that takes a single argument x and returns the square of that argument. The backslash is read as λ (the greek letter lambda).</p>
<p>You can use such as expressions everywhere where you would use any other function. For example you could apply the anonymous function <code>\x -&gt; x * x</code> to a number just like the named function <code>square</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- use named function:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>result <span class="ot">=</span> square <span class="dv">5</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="co">-- use anonymous function:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>result&#39; <span class="ot">=</span> (\x <span class="ot">-&gt;</span> x <span class="op">*</span> x) <span class="dv">5</span></span></code></pre></div>
<p>We will see more useful applications of anonymous functions in the following section.</p>
<h3 id="functions-can-be-returned-as-values-from-other-functions">Functions can be returned as values from other functions</h3>
<h4 id="function-composition">Function composition</h4>
<p>Do you remember <em>function composition</em> from your high-school math classes? Function composition is an operation that takes two functions <code>f</code> and <code>g</code> and produces a function <code>h</code> such that <code>h(x) = g(f(x))</code> The resulting composite function is denoted <code>h = g ∘ f</code> where <code>(g ∘ f )(x) = g(f(x))</code>. Intuitively, composing functions is a chaining process in which the output of function <code>f</code> is used as input of function <code>g</code>.</p>
<p>So looking from a programmers perspective the <code>∘</code> operator is a function that takes two functions as arguments and returns a new composite function.</p>
<p>In Haskell this operator is represented as the dot operator <code>.</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>(<span class="op">.</span>) f g x <span class="ot">=</span> f (g x)</span></code></pre></div>
<p>The brackets around the dot are required as we want to use a non-alphabetical symbol as an identifier. In Haskell such identifiers can be used as infix operators (as we will see below). Otherwise <code>(.)</code> is defined as any other function. Please also note how close the syntax is to the original mathematical definition.</p>
<p>Using this operator we can easily create a composite function that first doubles a number and then computes the square of that doubled number:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">squareAfterDouble ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>squareAfterDouble <span class="ot">=</span> square <span class="op">.</span> double</span></code></pre></div>
<h4 id="currying-and-partial-application">Currying and Partial Application</h4>
<p>In this section we look at another interesting example of functions producing other functions as return values. We start by defining a function <code>add</code> that takes two <code>Integer</code> arguments and computes their sum:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- function adding two numbers </span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>This look quite straightforward. But still there is one interesting detail to note: the type signature of <code>add</code> is not something like</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">add ::</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>Instead it is:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span></code></pre></div>
<p>What does this signature actually mean? It can be read as “A function taking an Integer argument and returning a function of type <code>Integer -&gt; Integer</code>”. Sounds weird? But that’s exactly what Haskell does internally. So if we call <code>add 2 3</code> first <code>add</code> is applied to <code>2</code> which return a new function of type <code>Integer -&gt; Integer</code> which is then applied to <code>3</code>.</p>
<p>This technique is called <a href="https://wiki.haskell.org/Currying"><strong>Currying</strong></a></p>
<p>Currying is widely used in Haskell as it allows another cool thing: <strong>partial application</strong>.</p>
<p>In the next code snippet we define a function <code>add5</code> by partially applying the function <code>add</code> to only one argument:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- partial application: applying add to 5 returns a function of type Integer -&gt; Integer</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="ot">add5 ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>add5 <span class="ot">=</span> add <span class="dv">5</span></span></code></pre></div>
<p>The trick is as follows: <code>add 5</code> returns a function of type <code>Integer -&gt; Integer</code> which will add <code>5</code> to any Integer argument.</p>
<p>Partial application thus allows us to write functions that return functions as result values. This technique is frequently used to <a href="https://github.com/thma/LtuPatternFactory#dependency-injection--parameter-binding-partial-application">provide functions with configuration data</a>.</p>
<h3 id="functions-can-be-passed-as-arguments-to-other-functions">Functions can be passed as arguments to other functions</h3>
<p>I could keep this section short by telling you that we have already seen an example for this: the function composition operator <code>(.)</code>. It <strong>accepts two functions as arguments</strong> and returns a new one as in:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">squareAfterDouble ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>squareAfterDouble <span class="ot">=</span> square <span class="op">.</span> double</span></code></pre></div>
<p>But I have another instructive example at hand.</p>
<p>Let’s imagine we have to implement a function that doubles any odd Integer:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">ifOddDouble ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>ifOddDouble n <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="kw">if</span> <span class="fu">odd</span> n</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="kw">then</span> double n</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>    <span class="kw">else</span> n</span></code></pre></div>
<p>The Haskell code is straightforward: new ingredients are the <code>if ... then ... else ...</code> and the odd <code>odd</code> which is a predicate from the Haskell standard library that returns <code>True</code> if an integral number is odd.</p>
<p>Now let’s assume that we also need another function that computes the square for any odd number:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">ifOddSquare ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>ifOddSquare n <span class="ot">=</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="kw">if</span> <span class="fu">odd</span> n</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>    <span class="kw">then</span> square n</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>    <span class="kw">else</span> n</span></code></pre></div>
<p>As vigilant developers we immediately detect a violation of the <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself principle</a> as both functions only vary in the usage of a different growth functions <code>double</code> versus <code>square</code>.</p>
<p>So we are looking for a way to refactor this code by a solution that keeps the original structure but allows to vary the used growth function.</p>
<p>What we need is a function that takes a growth function (of type <code>(Integer -&gt; Integer)</code>) as first argument, an <code>Integer</code> as second argument and returns an <code>Integer</code>. The specified growth function will be applied in the <code>then</code> clause:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">ifOdd ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>ifOdd growthFunction n <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  <span class="kw">if</span> <span class="fu">odd</span> n</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>    <span class="kw">then</span> growthFunction n</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>    <span class="kw">else</span> n</span></code></pre></div>
<p>With this approach we can refactor <code>ifOddDouble</code> and <code>ifOddSquare</code> as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">ifOddDouble ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>ifOddDouble n <span class="ot">=</span> ifOdd double n</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a><span class="ot">ifOddSquare ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>ifOddSquare n <span class="ot">=</span> ifOdd square n</span></code></pre></div>
<p>Now imagine that we have to implement new function <code>ifEvenDouble</code> and <code>ifEvenSquare</code>, that will work only on even numbers. Instead of repeating ourselves we come up with a function <code>ifPredGrow</code> that takes a predicate function of type <code>(Integer -&gt; Bool)</code> as first argument, a growth function of type <code>(Integer -&gt; Integer)</code> as second argument and an Integer as third argument, returning an <code>Integer</code>.</p>
<p>The predicate function will be used to determine whether the growth function has to be applied:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">ifPredGrow ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>ifPredGrow predicate growthFunction n <span class="ot">=</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="kw">if</span> predicate n</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span class="kw">then</span> growthFunction n</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="kw">else</span> n</span></code></pre></div>
<p>Using this <a href="https://en.wikipedia.org/wiki/Higher-order_function">higher order function</a> that even takes two functions as arguments we can write the two new functions and further refactor the existing ones without breaking the DRY principle:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="ot">ifEvenDouble ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>ifEvenDouble n <span class="ot">=</span> ifPredGrow <span class="fu">even</span> double n</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a><span class="ot">ifEvenSquare ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>ifEvenSquare n <span class="ot">=</span> ifPredGrow <span class="fu">even</span> square n</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a><span class="ot">ifOddDouble&#39;&#39; ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>ifOddDouble&#39;&#39; n <span class="ot">=</span> ifPredGrow <span class="fu">odd</span> double n</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a><span class="ot">ifOddSquare&#39;&#39; ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>ifOddSquare&#39;&#39; n <span class="ot">=</span> ifPredGrow <span class="fu">odd</span> square n</span></code></pre></div>
<h2 id="pattern-matching">Pattern matching</h2>
<p>With the things that we have learnt so far, we can now start to implement some more interesting functions. So what about implementing the recursive <a href="https://en.wikipedia.org/wiki/Factorial">factorial function</a>?</p>
<p>The factorial function can be defined as follows:</p>
<blockquote>
<p>For all n ∈ ℕ<sub>0</sub>:</p>
<pre><code>0! = 1
n! = n * (n-1)!</code></pre>
</blockquote>
<p>With our current knowledge of Haskell we can implement this as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">factorial ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>factorial n <span class="ot">=</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>  <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>    <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    <span class="kw">else</span> n <span class="op">*</span> factorial (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>We are using the Haskell data type <code>Natural</code> to denote the set of non-negative integers ℕ<sub>0</sub>. Using the literal <code>factorial</code> within the definition of the function <code>factorial</code> works as expected and denotes a recursive function call.</p>
<p>As these kind of recursive definition of functions are typical for functional programming, the language designers have added a useful feature called <em>pattern matching</em> that allows to define functions by a set of equations:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">fac ::</span> <span class="dt">Natural</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>fac <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>fac n <span class="ot">=</span> n <span class="op">*</span> fac (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>This style comes much closer to the mathematical definition and is typically more readable, as it helps to avoid nested <code>if ... then ... else ...</code> constructs.</p>
<p>Pattern matching can not only be used for numeric values but for any other data types. We’ll see some more examples shortly.</p>
<h2 id="algebraic-data-types">Algebraic Data Types</h2>
<p>Haskell supports user-defined data types by making use of a well thought out concept. Let’s start with a simple example:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Status</span> <span class="ot">=</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Red</span></span></code></pre></div>
<p>This declares a data type <code>Status</code> which has exactly three different instances. For each instance a <em>data constructor</em> is defined that allows to create a new instance of the data type.</p>
<p>Each of those data constructors is a function (in this simple case a constant) that returns a <code>Status</code> instance.</p>
<p>The type <code>Status</code> is a so called <em>sum type</em> as it is represents the set defined by the sum of all three instances <code>Green</code>, <code>Yellow</code>, <code>Red</code>. In Java this corresponds to Enumerations.</p>
<p>Let’s assume we have to create a converter that maps our <code>Status</code> values to <code>Severity</code> values representing severity levels in some other system. This converter can be written using the pattern matching syntax that we already have seen above:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- another sum type representing severity:</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Low</span> <span class="op">|</span> <span class="dt">Middle</span> <span class="op">|</span> <span class="dt">High</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">severity ::</span> <span class="dt">Status</span> <span class="ot">-&gt;</span> <span class="dt">Severity</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>severity <span class="dt">Green</span>  <span class="ot">=</span> <span class="dt">Low</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>severity <span class="dt">Yellow</span> <span class="ot">=</span> <span class="dt">Middle</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>severity <span class="dt">Red</span>    <span class="ot">=</span> <span class="dt">High</span></span></code></pre></div>
<p>The compiler will tell us when we did not cover all instances of the <code>Status</code> type (by making use of the <code>-fwarn-incomplete-patterns</code> pragma).</p>
<p>Now we look at data types that combine multiple different elements, like pairs n-tuples, etc. Let’s start with a <code>PairStatusSeverity</code> type that combines two different elements:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">P</span> <span class="dt">Status</span> <span class="dt">Severity</span></span></code></pre></div>
<p>This can be understood as: data type <code>PairStatusSeverity</code> can be constructed from a data constructor <code>P</code> that takes a value of type <code>Status</code> and a value of type <code>Severity</code> and returns a <code>Pair</code> instance.</p>
<p>So for example <code>P Green High</code> returns a <code>PairStatusSeverity</code> instance (the data constructor <code>P</code> has the signature <code>P :: Status -&gt; Severity -&gt; PairStatusSeverity</code>).</p>
<p>The type <code>PairStatusSeverity</code> can be interpreted as the set of all possible ordered pairs of Status and Severity values, that is the <em>cartesian product</em> of <code>Status</code> and <code>Severity</code>.</p>
<p>That’s why such a data type is called <em>product type</em>.</p>
<p>Haskell allows you to create arbitrary data types by combining <em>sum types</em> and <em>product types</em>. The complete range of data types that can be constructed in this way is called <a href="https://en.wikipedia.org/wiki/Algebraic_data_type"><em>algebraic data types</em></a> or ADT in short.</p>
<p>Using algebraic data types has several advantages:</p>
<ul>
<li>Pattern matching can be used to analyze any concrete instance to select different behaviour based on input data. as in the example that maps <code>Status</code> to <code>Severity</code> there is no need to use <code>if..then..else..</code> constructs.</li>
<li>The compiler can detect incomplete patterns matching or other flaws.</li>
<li>The compiler can derive many complex functionality automatically for ADTs as they are constructed in such a regular way.</li>
</ul>
<p>We will cover the interesting combination of ADTs and pattern matching in the following sections.</p>
<h2 id="polymorphic-data-types">Polymorphic Data Types</h2>
<p>Forming pairs or more generally n-tuples is a very common task in programming. Therefore it would be inconvenient and repetitive if we were forced to create new Pair or Tuple types for each concrete usage. consider the following example:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">P</span> <span class="dt">Status</span> <span class="dt">Severity</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusString</span>   <span class="ot">=</span> <span class="dt">P&#39;</span> <span class="dt">Status</span> <span class="dt">String</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairSeverityStatus</span> <span class="ot">=</span> <span class="dt">P&#39;&#39;</span> <span class="dt">Severity</span> <span class="dt">Status</span></span></code></pre></div>
<p>Luckily data type declarations allow to use type variables to avoid this kind of cluttered code. So we can define a generic data type <code>Pair</code> that allows us to freely combine different kinds of arguments:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">-- a simple polymorphic type</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">P</span> a b</span></code></pre></div>
<p>This can be understood as: data type <code>Pair</code> uses two elements of (potentially) different types <code>a</code> and <code>b</code>; the data constructor <code>P</code> takes a value of type <code>a</code> and a value of type <code>b</code> and returns a <code>Pair a b</code> instance (the data constructor <code>P</code> has the signature <code>P :: a -&gt; b -&gt; Pair a b</code>). The type <code>Pair</code> can now be used to create many different concrete data types it is thus called a <em>polymorphic</em> data type. As the Polymorphism is defined by type variables, i.e. parameters to the type declarations, this mechanism is called <em>parametric polymorphism</em>.</p>
<p>As pairs and n-tuples are so frequently used, the Haskell language designers have added some syntactic sugar to work effortlessly with them.</p>
<p>So you can simply write tuples like this:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="ot">tuple ::</span> (<span class="dt">Status</span>, <span class="dt">Severity</span>, <span class="dt">String</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>tuple <span class="ot">=</span> (<span class="dt">Green</span>, <span class="dt">Low</span>, <span class="st">&quot;All green&quot;</span>)</span></code></pre></div>
<h3 id="lists">Lists</h3>
<p>Another very useful polymorphic type is the <code>List</code>.</p>
<p>A list can either be the empty list (denoted by the data constructor <code>[]</code>) or some element of a data type <code>a</code> followed by a list with elements of type <code>a</code>, denoted by <code>[a]</code>.</p>
<p>This intuition is reflected in the following data type definition:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="kw">data</span> [a] <span class="ot">=</span> [] <span class="op">|</span> a <span class="op">:</span> [a]</span></code></pre></div>
<p>The cons operator <code>(:)</code> (which is an infix operator like <code>(.)</code> from the previous section) is declared as a <em>data constructor</em> to construct a list from a single element of type <code>a</code> and a list of type <code>[a]</code>.</p>
<p>So a list containing only a single element <code>1</code> is constructed by:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="dv">1</span> <span class="op">:</span> []</span></code></pre></div>
<p>A list containing the three numbers 1, 2, 3 is constructed like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> []</span></code></pre></div>
<p>Luckily the Haskell language designers have been so kind to offer some syntactic sugar for this. So the first list can simply be written as <code>[1]</code> and the second as <code>[1,2,3]</code>.</p>
<p>Polymorphic type expressions describe <em>families of types</em>. For example, <code>(forall a)[a]</code> is the family of types consisting of, for every type <code>a</code>, the type of lists of <code>a</code>. Lists of integers (e.g. <code>[1,2,3]</code>), lists of characters (<code>['a','b','c']</code>), even lists of lists of integers, etc., are all members of this family.</p>
<p>Function that work on lists can use pattern matching to select behaviour for the <code>[]</code> and the <code>a:[a]</code> case.</p>
<p>Take for instance the definition of the function <code>length</code> that computes the length of a list:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="fu">length</span> []     <span class="ot">=</span>  <span class="dv">0</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span>  <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>We can read these equations as: The length of the empty list is 0, and the length of a list whose first element is x and remainder is xs is 1 plus the length of xs.</p>
<p>In our next example we want to work with a of some random integers:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="ot">someNumbers ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>someNumbers <span class="ot">=</span> [<span class="dv">49</span>,<span class="dv">64</span>,<span class="dv">97</span>,<span class="dv">54</span>,<span class="dv">19</span>,<span class="dv">90</span>,<span class="dv">934</span>,<span class="dv">22</span>,<span class="dv">215</span>,<span class="dv">6</span>,<span class="dv">68</span>,<span class="dv">325</span>,<span class="dv">720</span>,<span class="dv">8082</span>,<span class="dv">1</span>,<span class="dv">33</span>,<span class="dv">31</span>]</span></code></pre></div>
<p>Now we want to select all even or all odd numbers from this list. We are looking for a function <code>filter</code> that takes two arguments: first a predicate function that will be used to check each element and second the actual list of elements. The function will return a list with all matching elements. And of course our solution should work not only for Integers but for any other types as well. Here is the type signature of such a filter function:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>In the implementation we will use pattern matching to provide different behaviour for the <code>[]</code> and the <code>(x:xs)</code> case:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="fu">filter</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="fu">filter</span> <span class="fu">pred</span> []     <span class="ot">=</span> []</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a><span class="fu">filter</span> <span class="fu">pred</span> (x<span class="op">:</span>xs)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">pred</span> x         <span class="ot">=</span> x <span class="op">:</span> <span class="fu">filter</span> <span class="fu">pred</span> xs</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="fu">filter</span> <span class="fu">pred</span> xs</span></code></pre></div>
<p>The <code>[]</code> case is obvious. To understand the <code>(x:xs)</code> case we have to know that in addition to simple matching of the type constructors we can also use <em>pattern guards</em> to perform additional testing on the input data. In this case we compute <code>pred x</code> if it evaluates to <code>True</code>, <code>x</code> is a match and will be cons’ed with the result of <code>filter pred xs</code>. If it does not evaluate to <code>True</code>, we will not add <code>x</code> to the result list and thus simply call filter recursively on the remainder of the list.</p>
<p>Now we can use <code>filter</code> to select elements from our sample list:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="ot">someEvenNumbers ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>someEvenNumbers <span class="ot">=</span> <span class="fu">filter</span> <span class="fu">even</span> someNumbers</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a><span class="co">-- predicates may also be lambda-expresssions</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a><span class="ot">someOddNumbers ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>someOddNumbers <span class="ot">=</span> <span class="fu">filter</span> (\n <span class="ot">-&gt;</span> n <span class="ot">`rem`</span> <span class="dv">2</span> <span class="op">/=</span> <span class="dv">0</span>) someNumbers  </span></code></pre></div>
<p>Of course we don’t have to invent functions like <code>filter</code> on our own but can rely on the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-List.html">extensive set of predefined functions working on lists</a> in the Haskell base library.</p>
<h4 id="arithmetic-sequences">Arithmetic sequences</h4>
<p>There is a nice feature that often comes in handy when dealing with lists of numbers. It’s called <em>arithmetic sequences</em> and allows you to define lists of numbers with a concise syntax:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="ot">upToHundred ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>upToHundred <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>]</span></code></pre></div>
<p>As expected this assigns <code>upToHundred</code> with a list of integers from 1 to 100.</p>
<p>It’s also possible to define a step width that determines the increment between the subsequent numbers. If we want only the odd numbers we can construct them like this:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="ot">oddsUpToHundred ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>oddsUpToHundred <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="op">..</span><span class="dv">100</span>]</span></code></pre></div>
<p>Arithmetic sequences can also be used in more dynamic cases. For example we can define the <code>factorial</code> function like this:</p>
<pre class="math"><code>n! = 1 * 2 * 3 ... (n-2) * (n-1) * n, for integers &gt; 0</code></pre>
<p>In Haskell we can use an arithmetic sequence to define this function:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>fac&#39; n   <span class="ot">=</span> prod [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<h2 id="immutability">Immutability</h2>
<blockquote>
<p>In object-oriented and functional programming, an immutable object is an object whose state cannot be modified after it is created. This is in contrast to a mutable object (changeable object), which can be modified after it is created.</p>
<p>Quoted from <a href="https://en.wikipedia.org/wiki/Immutable_object">Wikipedia</a></p>
</blockquote>
<p>This is going to be a very short section. In Haskell all data is immutable. Period.</p>
<p>Let’s look at some interactions with the Haskell GHCi REPL (whenever you see the <code>λ&gt;</code> prompt in this article it is from a GHCi session):</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> a <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> a</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">reverse</span> a</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true"></a>[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true"></a>λ<span class="op">&gt;</span> a</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span></code></pre></div>
<p>In Haskell there is no way to change the value of <code>a</code> after its initial creation. There are no <em>destructive</em> operations available unlike some other functional languages such as Lisp, Scheme or ML.</p>
<p>The huge benefit of this is that refactoring becomes much simpler than in languages where every function or method might mutate data. Thus it will also be easier to reason about a given piece of code.</p>
<p>Of course this also makes programming of concurrent operations much easier. With a <em>shared nothing</em> approach, Haskell programs are automatically thread-safe.</p>
<h2 id="declarative-programming">Declarative programming</h2>
<p>In this section I want to explain how programming with <em>higher order</em> functions can be used to factor out many basic control structures and algorithms from the user code.</p>
<p>This will result in a more <em>declarative programming</em> style where the developer can simply declare <em>what</em> she wants to achieve but is not required to write down <em>how</em> it is to be achieved.</p>
<p>Code that applies this style will be much denser, and it will be more concerned with the actual elements of the problem domain than with the technical implementation details.</p>
<h3 id="mapping">Mapping</h3>
<p>We’ll demonstrate this with some examples working on lists. First we get the task to write a function that doubles all elements of a <code>[Integer]</code> list. We want to reuse the <code>double</code> function we have already defined above.</p>
<p>With all that we have learnt so far, writing a function <code>doubleAll</code> isn’t that hard:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true"></a><span class="co">-- compute the double value for all list elements</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true"></a><span class="ot">doubleAll ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true"></a>doubleAll [] <span class="ot">=</span> []</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true"></a>doubleAll (n<span class="op">:</span>rest) <span class="ot">=</span> double n <span class="op">:</span> doubleAll rest</span></code></pre></div>
<p>Next we are asked to implement a similar function <code>squareAll</code> that will use <code>square</code> to compute the square of all elements in a list. The naive way would be to implement it in the <em>WET</em> (We Enjoy Typing) approach:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true"></a><span class="co">-- compute squares for all list elements</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true"></a><span class="ot">squareAll ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true"></a>squareAll [] <span class="ot">=</span> []</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true"></a>squareAll (n<span class="op">:</span>rest) <span class="ot">=</span> square n <span class="op">:</span> squareAll rest</span></code></pre></div>
<p>Of course this is very ugly: both function use the same pattern matching and apply the same recursive iteration strategy. They only differ in the function applied to each element.</p>
<p>As role model developers we don’t want to repeat ourselves. We are thus looking for something that captures the essence of mapping a given function over a list of elements:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true"></a><span class="fu">map</span> f []     <span class="ot">=</span> []</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs</span></code></pre></div>
<p>This function abstracts away the implementation details of iterating over a list and allows to provide a user defined mapping function as well.</p>
<p>Now we can use <code>map</code> to simply <em>declare our intention</em> (the ‘what’) and don’t have to detail the ‘how’:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true"></a><span class="ot">doubleAll&#39; ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true"></a>doubleAll&#39; <span class="ot">=</span> <span class="fu">map</span> double</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true"></a><span class="ot">squareAll&#39; ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true"></a>squareAll&#39; <span class="ot">=</span> <span class="fu">map</span> square</span></code></pre></div>
<h3 id="folding">Folding</h3>
<p>Now let’s have a look at some related problem. Our first task is to add up all elements of a <code>[Integer]</code> list. First the naive approach which uses the already familiar mix of pattern matching plus recursion:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true"></a><span class="ot">sumUp ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true"></a>sumUp [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true"></a>sumUp (n<span class="op">:</span>rest) <span class="ot">=</span> n <span class="op">+</span> sumUp rest</span></code></pre></div>
<p>By looking at the code for a function that computes the product of all elements of a <code>[Integer]</code> list we can again see that we are repeating ourselves:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true"></a><span class="ot">prod ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true"></a>prod [] <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true"></a>prod (n<span class="op">:</span>rest) <span class="ot">=</span> n <span class="op">*</span> prod rest</span></code></pre></div>
<p>So what is the essence of both algorithms? At the core of both algorithms we have a recursive function which</p>
<ul>
<li>takes a binary operator (<code>(+)</code>or <code>(*)</code> in our case),</li>
<li>an initial value that is used as a starting point for the accumulation (typically the identity element (or neutral element) of the binary operator),</li>
<li>the list of elements that should be reduced to a single return value</li>
<li>performs the accumulation by recursively applying the binary operator to all elements of the list until the <code>[]</code> is reached, where the neutral element is returned.</li>
</ul>
<p>This essence is contained in the higher order function <code>foldr</code> which again is part of the Haskell standard library:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true"></a><span class="fu">foldr</span> f acc []     <span class="ot">=</span>  acc</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true"></a><span class="fu">foldr</span> f acc (x<span class="op">:</span>xs) <span class="ot">=</span>  f x (<span class="fu">foldr</span> f acc xs)</span></code></pre></div>
<p>Now we can use <code>foldr</code> to simply <em>declare our intention</em> (the ‘what’) and don’t have to detail the ‘how’:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true"></a><span class="ot">sumUp&#39; ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true"></a>sumUp&#39; <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true"></a><span class="ot">prod&#39; ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true"></a>prod&#39; <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">*</span>) <span class="dv">1</span></span></code></pre></div>
<p>With the functions <code>map</code> and <code>foldr</code> (or <code>reduce</code>) we have now two very powerful tools at hand that can be used in many situation where list data has to be processed.</p>
<p>Both functions can even be composed to form yet another very important programming concept: <em>Map/Reduce</em>. In Haskell this operation is provided by the function <code>foldMap</code>.</p>
<p>I won’t go into details here as it would go beyond the scope of this article, but I’ll invite you to read my <a href="https://github.com/thma/LtuPatternFactory#map-reduce">introduction to Map/Reduce in Haskell</a>.</p>
<h2 id="non-strict-evaluation">Non-strict Evaluation</h2>
<p>Now we come to topic that was one of the main drivers for the Haskell designers: they wanted to get away from the then standard model of strict evaluation.</p>
<p>Non-Strict Evaluation (aka. normal order reduction) has one very important property.</p>
<blockquote>
<p>If a lambda expression has a normal form, then normal order reduction will terminate and find that normal form.</p>
<p>Church-Rosser Theorem II</p>
</blockquote>
<p>This property does not hold true for other reduction strategies (like applicative order or call-by-value reduction).</p>
<p>This result from mathematical research on the <a href="https://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> is important as Haskell maintains the semantics of normal order reduction.</p>
<p>The real-world benefits of lazy evaluation include:</p>
<ul>
<li>Avoid endless loops in certain edge cases</li>
<li>The ability to define control flow (structures) as abstractions instead of primitives.</li>
<li>The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.</li>
</ul>
<p>So let’s have a closer look at those benefits:</p>
<h3 id="avoid-endless-loops">Avoid endless loops</h3>
<p>Consider the following example function:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true"></a><span class="ot">ignoreY ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true"></a>ignoreY x y <span class="ot">=</span> x</span></code></pre></div>
<p>It takes two integer arguments and returns the first one unmodified. The second argument is simply ignored.</p>
<p>In most programming languages both arguments will be evaluated before the function body is executed: they use applicative order reduction aka. eager evaluation or call-by-value semantics.</p>
<p>In Haskell on the other hand it is safe to call the function with a non-terminating expression in the second argument. First we create a non-terminating expression <code>viciousCircle</code>. Any attempt to evaluate it will result in an endless loop:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true"></a><span class="co">-- it&#39;s possible to define non-terminating expressions like</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true"></a><span class="ot">viciousCircle ::</span> a</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true"></a>viciousCircle <span class="ot">=</span> viciousCircle</span></code></pre></div>
<p>But if we use <code>viciousCircle</code> as second argument to the function <code>ignoreY</code> it will simply be ignored and the first argument is returned:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true"></a><span class="co">-- trying it in GHCi:</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true"></a>λ<span class="op">&gt;</span> ignoreY <span class="dv">42</span> viciousCircle</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true"></a><span class="dv">42</span></span></code></pre></div>
<h3 id="define-potentially-infinite-data-structures">Define potentially infinite data structures</h3>
<p>In the <a href="#lists">section on lists</a> we have already met <em>arithmetic sequences</em> like <code>[1..10]</code>.</p>
<p>Arithmetic sequences can also be used to define infinite lists of numbers. Here are a few examples:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true"></a><span class="co">-- all natural numbers</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true"></a>naturalNumbers <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true"></a></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true"></a><span class="co">-- all even numbers</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true"></a>evens <span class="ot">=</span> [<span class="dv">2</span>,<span class="dv">4</span><span class="op">..</span>]</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true"></a><span class="co">-- all odd numbers</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true"></a>odds  <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">3</span><span class="op">..</span>]</span></code></pre></div>
<p>Defining those infinite lists is rather easy. But what can we do with them? Are they useful for any purpose? In the <code>viciousCircle</code> example above we have learnt that defining that expression is fine but any attempt to evaluate it will result in an infinite loop.</p>
<p>If we try to print <code>naturalNumbers</code> we will also end up in an infinite loop of integers printed to the screen.</p>
<p>But if we are bit less greedy than asking for all natural numbers everything will be OK.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> naturalNumbers</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>]</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> evens</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true"></a>[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> odds</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>,<span class="dv">17</span>,<span class="dv">19</span>]</span></code></pre></div>
<p>We can also peek at a specific position in such an infinite list, using the <code>(!!)</code> operator:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> odds <span class="op">!!</span> <span class="dv">5000</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true"></a><span class="dv">10001</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> evens <span class="op">!!</span> <span class="dv">10000</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true"></a><span class="dv">20002</span></span></code></pre></div>
<h3 id="list-comprehension">List comprehension</h3>
<p>Do you remember <em>set comprehension</em> notation from your math classes?</p>
<p>As simple example would be the definition of the set of even numbers:</p>
<blockquote>
<p>Evens = {i | i = 2n ∧ n ∊ ℕ}</p>
</blockquote>
<p>Which can be read as: Evens is defined as the set of all <code>i</code> where <code>i = 2*n</code> and <code>n</code> is an element of the set of natural numbers.</p>
<p>The Haskell <em>list comprehension</em> allows us to define - potentially infinite - lists with a similar syntax:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true"></a>evens&#39; <span class="ot">=</span> [<span class="dv">2</span><span class="op">*</span>n <span class="op">|</span> n <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>]]</span></code></pre></div>
<p>Again we can avoid infinite loops by evaluating only a finite subset of <code>evens'</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">10</span> evens&#39;</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true"></a>[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>,<span class="dv">12</span>,<span class="dv">14</span>,<span class="dv">16</span>,<span class="dv">18</span>,<span class="dv">20</span>]</span></code></pre></div>
<p>List comprehension can be very useful for defining numerical sets and series in a (mostly) declarative way that comes close to the original mathematical definitions.</p>
<p>Take for example the set <code>PT</code> of all pythagorean triples</p>
<blockquote>
<p>PT = { (a,b,c) | a,b,c ∊ ℕ ∧ a² + b² = c² }</p>
</blockquote>
<p>The Haskell definition looks like this:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true"></a><span class="ot">pt ::</span> [(<span class="dt">Natural</span>,<span class="dt">Natural</span>,<span class="dt">Natural</span>)]</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true"></a>pt <span class="ot">=</span> [(a,b,c) <span class="op">|</span> c <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>],</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true"></a>                b <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>c],</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true"></a>                a <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>b],</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true"></a>                a<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> b<span class="op">^</span><span class="dv">2</span> <span class="op">==</span> c<span class="op">^</span><span class="dv">2</span>]</span></code></pre></div>
<h3 id="define-control-flow-structures-as-abstractions">Define control flow structures as abstractions</h3>
<p>In most languages it is not possible to define new conditional operations, e.g. your own <code>myIf</code> statement. A conditional operation will evaluate some of its arguments only if certain conditions are met. This is very hard - if not impossible - to implement in language with call-by-value semantics which evaluates all function arguments before actually evaluating the function body.</p>
<p>As Haskell implements call-by-need semantics, it is possible to define new conditional operations. In fact this is quite helpful when writing <em>domain specific languages</em>.</p>
<p>Here comes a very simple version of <code>myIf</code>:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true"></a><span class="ot">myIf ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true"></a>myIf p x y <span class="ot">=</span> <span class="kw">if</span> p <span class="kw">then</span> x <span class="kw">else</span> y </span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true"></a>λ<span class="op">&gt;</span> myIf (<span class="dv">4</span> <span class="op">&gt;</span> <span class="dv">2</span>) <span class="st">&quot;true&quot;</span> viciousCircle</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true"></a><span class="st">&quot;true&quot;</span></span></code></pre></div>
<p>A somewhat more useful control-structure is the <code>cond</code> (for conditional) function that stems from LISP and Scheme languages. It allows you to define a more table-like decision structure, somewhat resembling a <code>switch</code> statement from C-style languages:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true"></a><span class="ot">cond ::</span> [(<span class="dt">Bool</span>, a)] <span class="ot">-&gt;</span> a</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true"></a>cond []                 <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;make sure that at least one condition is true&quot;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true"></a>cond ((<span class="dt">True</span>,  v)<span class="op">:</span>rest)  <span class="ot">=</span> v</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true"></a>cond ((<span class="dt">False</span>, _)<span class="op">:</span>rest)  <span class="ot">=</span> cond rest</span></code></pre></div>
<p>With this function we can implement a signum function <code>sign</code> as follows:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true"></a><span class="ot">sign ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true"></a>sign x <span class="ot">=</span> cond [(x <span class="op">&gt;</span> <span class="dv">0</span>     , <span class="dv">1</span> )</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true"></a>              ,(x <span class="op">&lt;</span> <span class="dv">0</span>     , <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true"></a>              ,(<span class="fu">otherwise</span> , <span class="dv">0</span> )]</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true"></a></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true"></a>λ<span class="op">&gt;</span> sign <span class="dv">5</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true"></a>λ<span class="op">&gt;</span> sign <span class="dv">0</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true"></a><span class="dv">0</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true"></a>λ<span class="op">&gt;</span> sign (<span class="op">-</span><span class="dv">4</span>)</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true"></a><span class="op">-</span><span class="dv">1</span></span></code></pre></div>
<h2 id="type-classes">Type Classes</h2>
<p>Now we come to one of the most distinguishing features of Haskell: <em>type classes</em>.</p>
<p>In the section <a href="#polymorphic-data-types">Polymorphic Data Types</a> we have seen that type variables (or parameters) allow type declarations to be polymorphic like in:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true"></a><span class="kw">data</span> [a] <span class="ot">=</span> [] <span class="op">|</span> a <span class="op">:</span> [a]</span></code></pre></div>
<p>This approach is called <em>parametric polymorphism</em> and is used in several programming languages.</p>
<p>Type classes on the other hand address <em>ad hoc polymorphism</em> of data types. This approach is also known as <em>overloading</em>.</p>
<p>To get a first intuition let’s start with a simple example.</p>
<p>We would like to be able to use characters (represented by the data type <code>Char</code>) as if they were numbers. E.g. we would like to be able to things like:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="ch">&#39;A&#39;</span> <span class="op">+</span> <span class="dv">25</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true"></a><span class="ch">&#39;Z&#39;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true"></a><span class="co">-- please note that in Haskell a string is List of characters: type String = [Char]</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">5</span>) <span class="st">&quot;hello world&quot;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true"></a><span class="st">&quot;mjqqt%|twqi&quot;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true"></a></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">map</span> (\c <span class="ot">-&gt;</span> c <span class="op">-</span> <span class="dv">5</span>) <span class="st">&quot;mjqqt%|twqi&quot;</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true"></a><span class="st">&quot;hello world&quot;</span></span></code></pre></div>
<p>To enable this we will have to <em>overload</em> the infix operators <code>(+)</code> and <code>(-)</code> to work not only on numbers but also on characters. Now, let’s have a look at the type signature of the <code>(+)</code> operator:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span><span class="kw">type</span> (<span class="op">+</span>)</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true"></a><span class="ot">(+) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>So <code>(+)</code> is not just declared to be of type <code>(+) :: a -&gt; a -&gt; a</code> but it contains a <strong>constraint</strong> on the type variable <code>a</code>, namely <code>Num a =&gt;</code>. The whole type signature of <code>(+)</code> can be read as: for all types <code>a</code> that are members of the type class <code>Num</code> the operator <code>(+)</code> has the type <code>a -&gt; a -&gt; a</code>.</p>
<p>Next we obtain more information on the type class <code>Num</code>:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>info <span class="dt">Num</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true"></a><span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true"></a><span class="ot">  (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true"></a><span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true"></a><span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true"></a><span class="ot">  abs ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true"></a><span class="ot">  signum ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true"></a><span class="ot">  fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true"></a>  <span class="ot">{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true"></a>  	<span class="co">-- Defined in `GHC.Num&#39;</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Word</span> <span class="co">-- Defined in `GHC.Num&#39;</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Integer</span> <span class="co">-- Defined in `GHC.Num&#39;</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span> <span class="co">-- Defined in `GHC.Num&#39;</span></span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Float</span> <span class="co">-- Defined in `GHC.Float&#39;</span></span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Double</span> <span class="co">-- Defined in `GHC.Float&#39;</span></span></code></pre></div>
<p>This information details what functions a type <code>a</code> has to implement to be used as an instance of the <code>Num</code> type class. The line <code>{-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}</code> tells us what a minimal complete implementation has to provide. It also tells us that the types <code>Word</code>, <code>Integer</code>, <code>Int</code>, <code>Float</code> and <code>Double</code> are instances of the <code>Num</code> type class.</p>
<p>This is all we need to know to make the type <code>Char</code> an instance of the <code>Num</code> type class, so without further ado we dive into the implementation (please note that <code>fromEnum</code> converts a <code>Char</code> into an <code>Int</code> and <code>toEnum</code> converts an <code>Int</code> into an <code>Char</code>):</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true"></a>  a <span class="op">+</span> b       <span class="ot">=</span> <span class="fu">toEnum</span> (<span class="fu">fromEnum</span> a <span class="op">+</span> <span class="fu">fromEnum</span> b)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true"></a>  a <span class="op">-</span> b       <span class="ot">=</span> <span class="fu">toEnum</span> (<span class="fu">fromEnum</span> a <span class="op">-</span> <span class="fu">fromEnum</span> b)</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true"></a>  a <span class="op">*</span> b       <span class="ot">=</span> <span class="fu">toEnum</span> (<span class="fu">fromEnum</span> a <span class="op">*</span> <span class="fu">fromEnum</span> b)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true"></a>  <span class="fu">abs</span> c       <span class="ot">=</span> c</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true"></a>  <span class="fu">signum</span>      <span class="ot">=</span> <span class="fu">toEnum</span> <span class="op">.</span> <span class="fu">signum</span> <span class="op">.</span> <span class="fu">fromEnum</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="fu">toEnum</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true"></a>  <span class="fu">negate</span> c    <span class="ot">=</span> c</span></code></pre></div>
<p>This piece of code makes the type <code>Char</code> an instance of the <code>Num</code> type class. We can then use <code>(+)</code> and `(-) as demonstrated above.</p>
<p>Originally the idea for type classes came up to provide overloading of arithmetic operators in order to use the same operators across all numeric types.</p>
<p>But the type classes concept proved to be useful in a variety of other cases as well. This has lead to a rich sets of type classes provided by the Haskell base library and a wealth of programming techniques that make use of this powerful concept.</p>
<p>Here comes a graphic overview of some of the most important type classes in the Haskell base library:</p>
<figure>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/04/Base-classes.svg/510px-Base-classes.svg.png" alt="" /><figcaption>The hierarchy of basic type classes</figcaption>
</figure>
<p>I won’t go over all of these but I’ll cover some of the most important ones.</p>
<p>Let’s start with Eq:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true"></a>   (<span class="op">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true"></a>       <span class="co">-- Minimal complete definition:</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true"></a>       <span class="co">--      (==) or (/=)</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true"></a>   x <span class="op">/=</span> y     <span class="ot">=</span>  <span class="fu">not</span> (x <span class="op">==</span> y)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true"></a>   x <span class="op">==</span> y     <span class="ot">=</span>  <span class="fu">not</span> (x <span class="op">/=</span> y)</span></code></pre></div>
<p>This definition states two things:</p>
<ul>
<li>if a type <code>a</code> is to be made an instance of the class <code>Eq</code> it must support the functions <code>(==)</code> and <code>(/=)</code> both of them having type <code>a -&gt; a -&gt; Bool</code>.<br />
</li>
<li><code>Eq</code> provides <em>default definitions</em> for <code>(==)</code> and <code>(/=)</code> in terms of each other. As a consequence, there is no need for a type in <code>Eq</code> to provide both definitions - given one of them, the other will work automatically.</li>
</ul>
<p>Now we can turn some of the data types that we defined in the section on <a href="#algebraic-data-types">Algebraic Data Types</a> into instances of the <code>Eq</code> type class.</p>
<p>Here the type declarations as a recap:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Status</span>   <span class="ot">=</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Red</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Low</span> <span class="op">|</span> <span class="dt">Middle</span> <span class="op">|</span> <span class="dt">High</span> </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">PSS</span> <span class="dt">Status</span> <span class="dt">Severity</span></span></code></pre></div>
<p>First, we create Eq instances for the simple types <code>Status</code> and <code>Severity</code> by defining the <code>(==)</code> operator for each of them:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Status</span> <span class="kw">where</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true"></a>  <span class="dt">Green</span>  <span class="op">==</span> <span class="dt">Green</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true"></a>  <span class="dt">Yellow</span> <span class="op">==</span> <span class="dt">Yellow</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true"></a>  <span class="dt">Red</span>    <span class="op">==</span> <span class="dt">Red</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true"></a>  _      <span class="op">==</span> _      <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true"></a>  </span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Severity</span> <span class="kw">where</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true"></a>  <span class="dt">Low</span>    <span class="op">==</span> <span class="dt">Low</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true"></a>  <span class="dt">Middle</span> <span class="op">==</span> <span class="dt">Middle</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true"></a>  <span class="dt">High</span>   <span class="op">==</span> <span class="dt">High</span>   <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true"></a>  _      <span class="op">==</span> _      <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Next, we create an <code>Eq</code> instance for <code>PairStatusSeverity</code> by defining the <code>(==)</code> operator:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">PairStatusSeverity</span> <span class="kw">where</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true"></a>   (<span class="dt">PSS</span> sta1 sev1) <span class="op">==</span> (<span class="dt">PSS</span> sta2 sev2) <span class="ot">=</span> (sta1 <span class="op">==</span> sta2) <span class="op">&amp;&amp;</span> (sev1 <span class="op">==</span> sev2)</span></code></pre></div>
<p>With these definitions it is now possible to use the <code>(==)</code> and <code>(/=)</code> on our three types.</p>
<p>As you will have noticed, the code for implementing <code>Eq</code> is quite boring. Even a machine could do it!</p>
<p>That’s why the language designers have provided a <code>deriving</code> mechanism to let the compiler automatically implement type class instances if it’s automatically derivable as in the <code>Eq</code> case.</p>
<p>With this syntax it much easier to let a type implement the <code>Eq</code> type class:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Status</span>   <span class="ot">=</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Red</span>          <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Low</span> <span class="op">|</span> <span class="dt">Middle</span> <span class="op">|</span> <span class="dt">High</span>           <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">PSS</span> <span class="dt">Status</span> <span class="dt">Severity</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span></code></pre></div>
<p>This automatic deriving of type class instances works for many cases and reduces a lof of repetitive code.</p>
<p>For example, its possible to automatically derive instances of the <code>Ord</code> type class, which provides ordering functionality:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Ord</span> a <span class="kw">where</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true"></a><span class="ot">    compare              ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true"></a>    (<span class="op">&lt;</span>), (<span class="op">&lt;=</span>), (<span class="op">&gt;</span>),<span class="ot"> (&gt;=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true"></a>    <span class="fu">max</span>,<span class="ot"> min             ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true"></a>    <span class="op">...</span></span></code></pre></div>
<p>If you are using <code>deriving</code> for the <code>Status</code> and <code>Severity</code> types, the Compiler will implement the ordering according to the ordering of the constructors in the type declaration. That is <code>Green &lt; Yellow &lt; Red</code> and <code>Low &lt; Middle &lt; High</code>:</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Status</span>   <span class="ot">=</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Red</span>          <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Low</span> <span class="op">|</span> <span class="dt">Middle</span> <span class="op">|</span> <span class="dt">High</span>           <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<h3 id="read-and-show">Read and Show</h3>
<p>Two other quite useful type classes are <code>Read</code> and <code>Show</code> that also support automatic deriving.</p>
<p><code>Show</code> provides a function <code>show</code> with the following type signature:</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true"></a><span class="fu">show</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>This means that any type implementing <code>Show</code> can be converted (or <em>marshalled</em>) into a <code>String</code> representation. Creation of a <code>Show</code> instance can be achieved by adding a <code>deriving (Show)</code> clause to the type declaration.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">PSS</span> <span class="dt">Status</span> <span class="dt">Severity</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">show</span> (<span class="dt">PSS</span> <span class="dt">Green</span> <span class="dt">Low</span>)</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true"></a><span class="st">&quot;PSS Green Low&quot;</span></span></code></pre></div>
<p>The <code>Read</code> type class is used to do the opposite: <em>unmarshalling</em> data from a String with the function <code>read</code>:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true"></a><span class="fu">read</span><span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This signature says that for any type <code>a</code> implementing the <code>Read</code> type class the function <code>read</code> can reconstruct an instance of <code>a</code> from its String representation:</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">PairStatusSeverity</span> <span class="ot">=</span> <span class="dt">PSS</span> <span class="dt">Status</span> <span class="dt">Severity</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Status</span> <span class="ot">=</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Red</span>            <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>)</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Severity</span> <span class="ot">=</span> <span class="dt">Low</span> <span class="op">|</span> <span class="dt">Middle</span> <span class="op">|</span> <span class="dt">High</span>           <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>)</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true"></a></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true"></a>λ<span class="op">&gt;</span> marshalled <span class="ot">=</span> <span class="fu">show</span> (<span class="dt">PSS</span> <span class="dt">Green</span> <span class="dt">Low</span>)</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true"></a></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">read</span><span class="ot"> marshalled ::</span> <span class="dt">PairStatusSeverity</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true"></a><span class="dt">PSS</span> <span class="dt">Green</span> <span class="dt">Low</span></span></code></pre></div>
<p>Please note that it is required to specify the expected target type with the <code>:: PairStatusSeverity</code> clause. Haskell uses static compile time typing. At compile time there is no way to determine which type an expression <code>read "some string content"</code> will return. Thus the expected type must be specified at compile time. Either by an implicit declaration given by some function type signature, or as in the example above, by an explicit declaration.</p>
<p>Together <code>show</code> and <code>read</code> provide a convenient way to serialize (marshal) and deserialize (unmarshal) Haskell data structures. This mechanism does not provide any optimized binary representation, but it is still good enough for many practical purposes, the format is more compact than JSON, and it does not require a parser library.</p>
<h3 id="functor-and-foldable">Functor and Foldable</h3>
<p>The most interesting type classes are those derived from abstract algebra or category theory. Studying them is a very rewarding process that I highly recommend. However, it is definitely beyond the scope of this article. Thus, I’m only pointing to two resources covering this part of the Haskell type class hierarchy. The first one is the legendary <a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a> by Brent Yorgey. The second one is <a href="https://github.com/thma/LtuPatternFactory">Lambda the ultimate Pattern Factory</a> by myself. This text relates the algebraic type classes to software design patterns, and therefore we will only cover some of these type classes.</p>
<p>In the section on <a href="#declarative-programming">declarative programming</a> we came across two very useful concepts:</p>
<ul>
<li>mapping a function over all elements in a list (<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>)</li>
<li>reducing a list with a binary operation and the neutral (identity) element of that operation (<code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>)</li>
</ul>
<p>These concepts are not only useful for lists, but also for many other data structures. So it doesn’t come as a surprise that there are type classes that abstract these concepts.</p>
<h4 id="functor">Functor</h4>
<p>The <code>Functor</code> type class generalizes the functionality of applying a function to a value in a context without altering the context, (e.g. mapping a function over a list <code>[a]</code> which returns a new list <code>[b]</code> of the same length):</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Let’s take a closer look at this idea by playing with a simple binary tree:</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true"></a><span class="co">-- a simple instance binary tree:</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true"></a><span class="ot">statusTree ::</span> <span class="dt">Tree</span> <span class="dt">Status</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true"></a>statusTree <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">Green</span>) (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">Red</span>) (<span class="dt">Leaf</span> <span class="dt">Yellow</span>))</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true"></a><span class="co">-- a function mapping Status to Severity</span></span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true"></a><span class="ot">toSeverity ::</span> <span class="dt">Status</span> <span class="ot">-&gt;</span> <span class="dt">Severity</span></span>
<span id="cb78-9"><a href="#cb78-9" aria-hidden="true"></a>toSeverity <span class="dt">Green</span>  <span class="ot">=</span> <span class="dt">Low</span></span>
<span id="cb78-10"><a href="#cb78-10" aria-hidden="true"></a>toSeverity <span class="dt">Yellow</span> <span class="ot">=</span> <span class="dt">Middle</span></span>
<span id="cb78-11"><a href="#cb78-11" aria-hidden="true"></a>toSeverity <span class="dt">Red</span>    <span class="ot">=</span> <span class="dt">High</span></span></code></pre></div>
<p>We want to use the function <code>toSeverity :: Status -&gt; Severity</code> to convert all <code>Status</code> elements of the <code>statusTree</code> into <code>Severity</code> instances.</p>
<p>Therefore, we let <code>Tree</code> instantiate the <code>Functor</code> class:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a)   <span class="ot">=</span> <span class="dt">Leaf</span> (f a)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true"></a>  <span class="fu">fmap</span> f (<span class="dt">Node</span> a b) <span class="ot">=</span> <span class="dt">Node</span> (<span class="fu">fmap</span> f a) (<span class="fu">fmap</span> f b)</span></code></pre></div>
<p>We can now use <code>fmap</code> on <code>Tree</code> data structures:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">fmap</span> toSeverity statusTree</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true"></a><span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">Low</span>) (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">High</span>) (<span class="dt">Leaf</span> <span class="dt">Middle</span>))</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span><span class="kw">type</span> it</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true"></a><span class="ot">it ::</span> <span class="dt">Tree</span> <span class="dt">Severity</span></span></code></pre></div>
<p>As already described above, fmap maintains the tree structure unchanged but converts the type of each <code>Leaf</code> element, which effectively changes the type of the tree to <code>Tree Severity</code>.</p>
<p>As derivation of <code>Functor</code> instances is a boring task, it is again possible to use the <code>deriving</code> clause to let data types instantiate <code>Functor</code>:</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span> <span class="co">-- this pragma allows automatic deriving of Functor instances</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<h4 id="foldable">Foldable</h4>
<p>As already mentioned, <code>Foldable</code> provides the ability to perform <em>folding</em> operations on any data type instantiating the <code>Foldable</code> type class:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Foldable</span> t <span class="kw">where</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true"></a><span class="ot">  fold    ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> t m <span class="ot">-&gt;</span> m</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true"></a><span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m</span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true"></a><span class="ot">  foldr   ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true"></a><span class="ot">  foldr&#39;  ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true"></a><span class="ot">  foldl   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true"></a><span class="ot">  foldl&#39;  ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true"></a><span class="ot">  foldr1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true"></a><span class="ot">  foldl1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true"></a><span class="ot">  toList  ::</span> t a <span class="ot">-&gt;</span> [a]</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true"></a><span class="ot">  null    ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true"></a><span class="ot">  length  ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true"></a><span class="ot">  elem    ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true"></a><span class="ot">  maximum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true"></a><span class="ot">  minimum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true"></a><span class="ot">  sum     ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true"></a><span class="ot">  product ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>besides the abstraction of the <code>foldr</code> function, <code>Foldable</code> provides several other useful operations when dealing with <em>container</em>-like structures.</p>
<p>Because of the regular structure algebraic data types it is again possible to automatically derive <code>Foldable</code> instances by using the <code>deriving</code> clause:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE DeriveFunctor, DeriveFoldable #-}</span> <span class="co">-- allows automatic deriving of Functor and Foldable</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a) <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>)</span></code></pre></div>
<p>Of course, we can also implement the <code>foldr</code> function on our own:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true"></a>  <span class="fu">foldr</span> f acc (<span class="dt">Leaf</span> a)   <span class="ot">=</span> f a acc</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true"></a>  <span class="fu">foldr</span> f acc (<span class="dt">Node</span> a b) <span class="ot">=</span> <span class="fu">foldr</span> f (<span class="fu">foldr</span> f acc b) a</span></code></pre></div>
<p>We can now use <code>foldr</code> and other class methods of <code>Foldable</code>:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true"></a><span class="ot">statusTree ::</span> <span class="dt">Tree</span> <span class="dt">Status</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true"></a>statusTree <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">Green</span>) (<span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dt">Red</span>) (<span class="dt">Leaf</span> <span class="dt">Yellow</span>))</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true"></a>maxStatus <span class="ot">=</span> <span class="fu">foldr</span> <span class="fu">max</span> <span class="dt">Green</span> statusTree</span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true"></a>maxStatus&#39; <span class="ot">=</span> <span class="fu">maximum</span> statusTree</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true"></a><span class="co">-- using length from Foldable type class</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true"></a>treeSize <span class="ot">=</span> <span class="fu">length</span> statusTree</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true"></a></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true"></a><span class="co">-- in GHCi:</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">max</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true"></a><span class="fu">max</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true"></a></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">foldr</span> <span class="fu">max</span> <span class="dt">Green</span> statusTree</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true"></a><span class="dt">Red</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true"></a><span class="co">-- using maximum from Foldable type class:</span></span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="fu">maximum</span> statusTree</span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true"></a><span class="dt">Red</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true"></a>λ<span class="op">&gt;</span> treeSize</span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true"></a><span class="dv">3</span></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true"></a><span class="co">-- using toList from Foldable type class:</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true"></a>λ<span class="op">&gt;</span> toList statusTree</span>
<span id="cb85-23"><a href="#cb85-23" aria-hidden="true"></a>[<span class="dt">Green</span>,<span class="dt">Red</span>,<span class="dt">Yellow</span>]</span></code></pre></div>
<h3 id="the-maybe-monad">The Maybe Monad</h3>
<p>Now we will take the data type <code>Maybe</code> as an example to dive deeper into the more complex parts of the Haskell type class system.</p>
<p>The <code>Maybe</code> type is quite simple, it can be either a null value, called <code>Nothing</code> or a value of type <code>a</code> constructed by <code>Just a</code>:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true"></a><span class="kw">data</span>  <span class="dt">Maybe</span> a  <span class="ot">=</span>  <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>The Maybe type is helpful in situations where certain operation <em>may</em> return a valid result. Take for instance the function <code>lookup</code> from the Haskell base library. It looks up a key in a list of key-value pairs. If it finds the key, the associated value <code>val</code> is returned - but wrapped in a Maybe: <code>Just val</code>. If it doesn’t find the key, <code>Nothing</code> is returned:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [(a,b)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true"></a><span class="fu">lookup</span> _key []  <span class="ot">=</span>  <span class="dt">Nothing</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true"></a><span class="fu">lookup</span>  key ((k,val)<span class="op">:</span>rest)</span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true"></a>    <span class="op">|</span> key <span class="op">==</span> k  <span class="ot">=</span>  <span class="dt">Just</span> val</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span>  <span class="fu">lookup</span> key rest</span></code></pre></div>
<p>The <code>Maybe</code> type is a simple way to avoid NullPointer errors or similar issues with undefined results. Thus, many languages have adopted it under different names. In Java for instance, it is called <code>Optional</code>.</p>
<h4 id="total-functions">Total functions</h4>
<p>In Haskell, it is considered good practise to use <em>total functions</em> - that is functions that have defined return values for all possible input values - where ever possible to avoid runtime errors.</p>
<p>Typical examples for <em>partial</em> (i.e. non-total) functions are division and square roots. We can use <code>Maybe</code> to make them total:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true"></a><span class="ot">safeDiv ::</span> (<span class="dt">Eq</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true"></a>safeDiv _ <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true"></a>safeDiv x y <span class="ot">=</span> <span class="dt">Just</span> (x <span class="op">/</span> y)</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true"></a></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true"></a><span class="ot">safeRoot ::</span> (<span class="dt">Ord</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true"></a>safeRoot x</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Just</span> (<span class="fu">sqrt</span> x)</span></code></pre></div>
<p>In fact, there are alternative base libraries that don’t provide any partial functions.</p>
<h4 id="composition-of-maybe-operations">Composition of Maybe operations</h4>
<p>Now let’s consider a situation where we want to combine several of those functions. Say for example we first want to lookup the divisor from a key-value table, then perform a division with it and finally compute the square root of the quotient:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true"></a><span class="ot">findDivRoot ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [(<span class="dt">String</span>, <span class="dt">Double</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true"></a>findDivRoot x key <span class="fu">map</span> <span class="ot">=</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true"></a>  <span class="kw">case</span> <span class="fu">lookup</span> key <span class="fu">map</span> <span class="kw">of</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true"></a>      <span class="dt">Just</span> y  <span class="ot">-&gt;</span> <span class="kw">case</span> safeDiv x y <span class="kw">of</span></span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb89-7"><a href="#cb89-7" aria-hidden="true"></a>          <span class="dt">Just</span> d  <span class="ot">-&gt;</span> <span class="kw">case</span> safeRoot d <span class="kw">of</span></span>
<span id="cb89-8"><a href="#cb89-8" aria-hidden="true"></a>              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb89-9"><a href="#cb89-9" aria-hidden="true"></a>              <span class="dt">Just</span> r  <span class="ot">-&gt;</span> <span class="dt">Just</span> r</span>
<span id="cb89-10"><a href="#cb89-10" aria-hidden="true"></a></span>
<span id="cb89-11"><a href="#cb89-11" aria-hidden="true"></a><span class="co">-- and then in GHCi:</span></span>
<span id="cb89-12"><a href="#cb89-12" aria-hidden="true"></a>λ<span class="op">&gt;</span> findDivRoot <span class="dv">27</span> <span class="st">&quot;val&quot;</span> [(<span class="st">&quot;val&quot;</span>, <span class="dv">3</span>)]</span>
<span id="cb89-13"><a href="#cb89-13" aria-hidden="true"></a><span class="dt">Just</span> <span class="fl">3.0</span></span>
<span id="cb89-14"><a href="#cb89-14" aria-hidden="true"></a>λ<span class="op">&gt;</span> findDivRoot <span class="dv">27</span> <span class="st">&quot;val&quot;</span> [(<span class="st">&quot;val&quot;</span>, <span class="dv">0</span>)]</span>
<span id="cb89-15"><a href="#cb89-15" aria-hidden="true"></a><span class="dt">Nothing</span></span>
<span id="cb89-16"><a href="#cb89-16" aria-hidden="true"></a>λ<span class="op">&gt;</span> findDivRoot <span class="dv">27</span> <span class="st">&quot;val&quot;</span> [(<span class="st">&quot;val&quot;</span>, <span class="op">-</span><span class="dv">3</span>)]</span>
<span id="cb89-17"><a href="#cb89-17" aria-hidden="true"></a><span class="dt">Nothing</span></span></code></pre></div>
<p>The resulting control flow is depicted in the following diagram, which was inspired by the <a href="https://fsharpforfunandprofit.com/rop/">Railroad Oriented Programming</a> presentation: <img src="/img/maybe.png" width="924" alt="The Maybe Railroad"/></p>
<p>In each single step we have to check for <code>Nothing</code>, in that case we directly short circuit to an overall <code>Nothing</code> result value. In the <code>Just</code> case we proceed to the next processing step.</p>
<p>This kind of handling is repetitive and buries the actual intention under a lot of boilerplate. As Haskell uses layout (i.e. indentation) instead of curly brackets to separate blocks the code will end up in what is called the <em>dreaded staircase</em>: it marches to the right of the screen.</p>
<p>So we are looking for a way to improve the code by abstracting away the chaining of functions that return <code>Maybe</code> values and providing a way to <em>short circuit</em> the <code>Nothing</code> cases.</p>
<p>We need an operator <code>andThen</code> that takes the <code>Maybe</code> result of a first function application as first argument, and a function as second argument that will be used in the <code>Just x</code> case and again returns a <code>Maybe</code> result. In case that the input is <code>Nothing</code> the operator will directly return <code>Nothing</code> without any further processing. In case that the input is <code>Just x</code> the operator will apply the argument function <code>fun</code> to <code>x</code> and return its result:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true"></a><span class="ot">andThen ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true"></a>andThen <span class="dt">Nothing</span> _fun <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true"></a>andThen (<span class="dt">Just</span> x) fun <span class="ot">=</span> fun x</span></code></pre></div>
<p>We can then rewrite <code>findDivRoot</code> as follows:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true"></a>findDivRoot&#39;&#39;&#39;&#39; x key <span class="fu">map</span> <span class="ot">=</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true"></a>  <span class="fu">lookup</span> key <span class="fu">map</span> <span class="ot">`andThen`</span> \y <span class="ot">-&gt;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true"></a>  safeDiv x y    <span class="ot">`andThen`</span> \d <span class="ot">-&gt;</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true"></a>  safeRoot d</span></code></pre></div>
<p>(Side note: In Java the <code>Optional</code> type has a corresponding method: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html#flatMap-java.util.function.Function-">Optional.flatmap</a>)</p>
<p>This kind of chaining of functions in the context of a specific data type is quite common. So, it doesn’t surprise us that there exists an even more abstract <code>andThen</code> operator that works for arbitrary parameterized data types:</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>When we compare this <em>bind</em> operator with the type signature of the <code>andThen</code> operator:</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true"></a><span class="ot">andThen ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<p>We can see that both operators bear the same structure. The only difference is that instead of the concrete type <code>Maybe</code> the signature of <code>(&gt;&gt;=)</code> uses a type variable <code>m</code> with a <code>Monad</code> type class constraint. We can read this type signature as:</p>
<p>For any type <code>m</code> of the type class <code>Monad</code> the operator <code>(&gt;&gt;=)</code> is defined as <code>m a -&gt; (a -&gt; m b) -&gt; m b</code> Based on <code>(&gt;&gt;=)</code> we can rewrite the <code>findDivRoot</code> function as follows:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true"></a>findDivRoot&#39; x key <span class="fu">map</span> <span class="ot">=</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true"></a>  <span class="fu">lookup</span> key <span class="fu">map</span> <span class="op">&gt;&gt;=</span> \y <span class="ot">-&gt;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true"></a>  safeDiv x y    <span class="op">&gt;&gt;=</span> \d <span class="ot">-&gt;</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true"></a>  safeRoot d</span></code></pre></div>
<p>Monads are a central element of the Haskell type class ecosystem. In fact the monadic composition based on <code>(&gt;&gt;=)</code> is so frequently used that there exists some specific syntactic sugar for it. It’s called the do-Notation. Using do-Notation <code>findDivRoot</code> looks like this:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true"></a>findDivRoot&#39;&#39;&#39; x key <span class="fu">map</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true"></a>  y <span class="ot">&lt;-</span> <span class="fu">lookup</span> key <span class="fu">map</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true"></a>  d <span class="ot">&lt;-</span> safeDiv x y</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true"></a>  safeRoot d</span></code></pre></div>
<p>This looks quite like a sequence of statements (including variable assignments) in an imperative language. Due to this similarity Monads have been aptly called <a href="http://book.realworldhaskell.org/read/monads.html#id642960">programmable semicolons</a>. But as we have seen: below the syntactic sugar it’s a purely functional composition!</p>
<h3 id="purity">Purity</h3>
<p>A function is called pure if it corresponds to a function in the mathematical sense: it associates each possible input value with an output value, and does nothing else. In particular,</p>
<ul>
<li>it has no side effects, that is to say, invoking it produces no observable effect other than the result it returns; it cannot also e.g. write to disk, or print to a screen.</li>
<li>it does not depend on anything other than its parameters, so when invoked in a different context or at a different time with the same arguments, it will produce the same result.</li>
</ul>
<p>Purity makes it easy to reason about code, as it is so close to mathematical calculus. The properties of a Haskell program can thus often be determined with equational reasoning. (As an example I have provided an <a href="https://github.com/thma/WhyHaskellMatters/blob/master/functor-proof.md">example for equational reasoning in Haskell</a>).</p>
<p>Purity also improves testability: It is much easier to set up tests without worrying about mocks or stubs to factor out access to backend layers.</p>
<p>All the functions that we have seen so far are all <em>pure</em> code that is free from side effects.</p>
<p>So how can we achieve side effects like writing to a database or serving HTTP requests in Haskell?</p>
<p>The Haskell language designers came up with a solution that distinguishes Haskell from most other languages: Side effects are always explicitly declared in the function type signature. In the next section we will learn how exactly this works.</p>
<h3 id="explicit-side-effects-with-the-io-monad">Explicit side effects with the IO Monad</h3>
<blockquote>
<p>Monadic I/O is a clever trick for encapsulating sequential, imperative computation, so that it can “do no evil” to the part that really does have precise semantics and good compositional properties.</p>
<p><a href="http://conal.net/blog/posts/is-haskell-a-purely-functional-language">Conal Elliott</a></p>
</blockquote>
<p>The most prominent Haskell Monad is the <code>IO</code> monad. It is used to compose operations that perform I/O. We’ll study this with a simple example.</p>
<p>In an imperative language, reading a String from the console simply returns a String value (e.g. <code>BufferedReader.readline()</code> in Java: <code>public String readLine() throws IOException</code>).</p>
<p>In Haskell the function <code>getLine</code> does not return a <code>String</code> value but an <code>IO String</code>:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true"></a><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></span></code></pre></div>
<p>This could be interpreted as: <code>getLine</code> returns a String in an IO context. In Haskell, it is not possible to extract the String value from its IO context (In Java on the other hand you could always catch away the <code>IOException</code>).</p>
<p>So how can we use the result of <code>getLine</code> in a function that takes a <code>String</code> value as input parameter?</p>
<p>We need the monadic bind operation <code>(&gt;&gt;=)</code> to do this in the same as we already saw in the <code>Maybe</code> monad:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true"></a><span class="co">-- convert a string to upper case</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true"></a><span class="ot">strToUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true"></a>strToUpper <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toUpper</span> </span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true"></a> </span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true"></a><span class="ot">up ::</span> <span class="dt">IO</span> () </span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true"></a>up <span class="ot">=</span> </span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true"></a>  <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \str <span class="ot">-&gt;</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true"></a>  <span class="fu">print</span> (strToUpper str)</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true"></a></span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true"></a><span class="co">-- and then in GHCi:</span></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t <span class="fu">print</span></span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true"></a><span class="fu">print</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true"></a>λ<span class="op">&gt;</span> up</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true"></a>hello world</span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true"></a><span class="st">&quot;HELLO WORLD&quot;</span></span></code></pre></div>
<p>or with do-Notation:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true"></a><span class="ot">up&#39; ::</span> <span class="dt">IO</span> () </span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true"></a>up&#39; <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true"></a>  str <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true"></a>  <span class="fu">print</span> (strToUpper str)</span></code></pre></div>
<p>Making side effects explicit in function type signatures is one of the most outstanding achievements of Haskell. This feature will lead to a very rigid distinction between code that is free of side effects (aka <em>pure</em> code) and code that has side effects (aka <em>impure</em> code).</p>
<p>Keeping domain logic <em>pure</em> - particularly when working only with <em>total</em> functions - will dramatically improve reliability and testability as tests can be run without setting up mocks or stubbed backends.</p>
<p>It’s not possible to introduce side effects without making them explicit in type signatures. There is nothing like the <em>invisible</em> Java <code>RuntimeExceptions</code>. So you can rely on the compiler to detect any violations of a rule like “No impure code in domain logic”.</p>
<p>I’ve written a simple Restaurant Booking REST Service API that explains how Haskell helps you to keep domain logic pure by organizing your code according to the <a href="https://github.com/thma/RestaurantReservation">ports and adapters pattern</a>.</p>
<p>The section on type classes (and on Monads in particular) have been quite lengthy. Yet, they have hardly shown more than the tip of the iceberg. If you want to dive deeper into type classes, I recommend <a href="https://wiki.haskell.org/Typeclassopedia">The Typeclassopedia</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We have covered quite a bit of terrain in the course of this article.</p>
<p>It may seem that Haskell has invented an intimidating mass of programming concepts. But in fact, Haskell inherits much from earlier functional programming languages.</p>
<p>Features like first class functions, comprehensive list APIs or declarative programming had already been introduced with Lisp and Scheme.</p>
<p>Several others, like pattern matching, non-strict evaluation, immutability, purity, static and strong typing, type inference, algebraic data types and polymorphic data types have been invented in languages like Hope, Miranda and ML.</p>
<p>Only a few features like type classes and explicit side effects / monadic I/O were first introduced in Haskell.</p>
<p>So if you already know some functional language concepts, Haskell shouldn’t seem too alien to you. For developers with a background in OO languages, the conceptual gap will be much larger.</p>
<p>I hope that this article helped to bridge that gap a bit and to better explain <a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf">why functional programming</a> - and Haskell in particular - matters.</p>
<p>Using functional programming languages - or applying some of their techniques - will help to create designs that are closer to the problem domain (as intented by domain driven design), more readable (due to their declarative character), allow equational reasoning, will provide more rigid separation of business logic and side effects, are more flexible for future changes or extensions, provide better testability (supporting BDD, TDD and property based testing), will need much less debugging, are better to maintain and, last but not least, will be more fun to write.</p>
]]></description>
    <pubDate>Wed, 01 Apr 2020 00:00:00 UT</pubDate>
    <guid>https://thma.github.io/LambdaBlog//posts/2020-04-01-why-haskell-matters.html</guid>
    <dc:creator>Thomas Mahler</dc:creator>
</item>

    </channel>
</rss>
