<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>lambda is not a four letter word - Writing a Haskell persistence layer using Generics and Reflection</title>
    <link rel="stylesheet" type="text/css" href="../css/composeconference.css" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />

    <!-- MATH JAX-->
    <script type="text/javascript" src="../static/mathjax/tex-mml-chtml.js"></script>

    <!-- favicon stuff-->
    <link rel="apple-touch-icon" sizes="57x57" href="../apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="manifest" href="../manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>
<body>

<header>
    <div class="heading">
        <div class="logo">
            <div style="float: left">
                <img src="../img/lambda-150.png" alt="\" height="40px" valign="bottom" />
            </div>
            <div>
                <a href="../">&nbsp;lambda is not a four letter word</a>
            </div>
        </div>
        <nav>
            <a href="../">home</a> | <a href="../about.html">about</a> | <a href="https://github.com/thma"><img valign="middle" src="../img/GitHub-Mark-32px.png" height="20px" alt="GitHub"></a>
        </nav>
    </div>
</header>

<main class="markdown-body" role="main">
    <h1>Writing a Haskell persistence layer using Generics and Reflection</h1>
    <div class="info">
    <em>Posted on January 21, 2023
    
        by Thomas Mahler
    </em><br /><br />
</div>

<!--
[![Actions Status](https://github.com/thma/generic-persistence/workflows/Haskell%20CI/badge.svg)](https://github.com/thma/generic-persistenceactions)
-->
<p><a href="https://github.com/thma/generic-persistence/tree/archive-blog-post-2023-01-23"><img src="https://thma.github.io/img/forkme.png" height="20"></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I’ll describe how to write a minimalistic Haskell persistence layer (on top of HDBC).
My approach will rely heavily on Generics (<code>Data.Data</code>, <code>Data.Typeable</code>) and Reflection (<code>Type.Reflection</code>).</p>
<p>The design goal is to avoid any boilerplate code.</p>
<p><strong>Please note:</strong> I received some helpful feedback on this post. I have now updated the code to reflect the suggestions.
So the code in this post is now outdated. Please refer to the <a href="https://github.com/thma/generic-persistence/">GitHub repository</a> for the latest version.</p>
<h2 id="introduction">Introduction</h2>
<p>The <em>functional goal</em> of my persistence layer is to provide hassle-free RDBMS persistence for Haskell data types in
Record notation (for brevity I call them <em>Entities</em>).</p>
<p>That is, it must provide means for inserting, updating, deleting and quering such enties to/from relational databases.</p>
<p>Not in scope for the current state of the library are things like:</p>
<ul>
<li>A query language</li>
<li>User-definable mappings of Haskell types to RDBMS types</li>
<li>Handling of relationships between entities (1:1, 1:n, n:m)</li>
<li>Handling of transactions</li>
<li>Handling of database migrations</li>
<li>Handling of database schemas</li>
<li>Handling of database connections and sessions</li>
<li>Handling of prepared statements</li>
<li>Handling auto-incrementing primary keys</li>
<li>Caching</li>
<li>…</li>
</ul>
<p>So as of now it’s just about the bare minimum to get some data into a database and to get it back out again.</p>
<p>The main <em>design goal</em> is to minimize the <em>boilerplate</em> code required. Ideally I would like to achieve the following:</p>
<ul>
<li>no manual instantiation of type classes</li>
<li>no implementation of encoders/decoders</li>
<li>no special naming convention for types and their attributes</li>
<li>no special types to define entities and attributes</li>
<li>no Template Haskell scaffolding of glue code</li>
</ul>
<p>In an ideal world we would be able to take any POHO (Plain old Haskell Object)
and persist it to any RDBMS without any additional effort.</p>
<h2 id="short-demo">Short demo</h2>
<p>Here now follows a short demo that shows how the library looks and feels from the user’s point of view.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable#-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span> ( <span class="dt">Data</span> )</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">TypeInfo</span> ( typeInfo ) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GenericPersistence</span>( delete, persist, retrieveAll, retrieveById )</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.HDBC</span> (disconnect, runRaw, commit) </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.HDBC.Sqlite3</span> ( connectSqlite3 )</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | define a data type with several fields, using record syntax.</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> personID ::</span> <span class="dt">Int</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> name ::</span> <span class="dt">String</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> age ::</span> <span class="dt">Int</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> address ::</span> <span class="dt">String</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Data</span>)</span></code></pre></div>
<p>The persistent data type must be deriving the <code>Data.Data</code> type class. This is required
to enable all the Generics magic to work behind the scenes.
Fortunately, deriving <code>Data</code> needs no manual implementation, we get it for free by enabling <code>DeriveDataTypeable</code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- initialize Person table</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    conn <span class="ot">&lt;-</span> connectSqlite3 <span class="st">&quot;sqlite.db&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    runRaw conn <span class="st">&quot;DROP TABLE IF EXISTS Person;&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    runRaw conn <span class="st">&quot;CREATE TABLE IF NOT EXISTS Person (personID INT PRIMARY KEY, name TEXT, age INT, address TEXT);&quot;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    commit conn</span></code></pre></div>
<p>As of now my library does not cover the creation of database tables. So this is still a manual step.
As already mentioned, the library does not cover any user defined mapping of data type attributes to columns.
As of now the same names for the attributes and the columns are used.
For the column types we are choosing types that can be automatically converted by HDBC.</p>
<p>Now we move on to using the actual library functions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- create a Person entity</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> alice <span class="ot">=</span> <span class="dt">Person</span> {personID <span class="ot">=</span> <span class="dv">123456</span>, name <span class="ot">=</span> <span class="st">&quot;Alice&quot;</span>, age <span class="ot">=</span> <span class="dv">25</span>, address <span class="ot">=</span> <span class="st">&quot;Elmstreet 1&quot;</span>}</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- insert a Person into a database</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    persist conn alice</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- update a Person</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    persist conn alice {address <span class="ot">=</span> <span class="st">&quot;Main Street 200&quot;</span>}  </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- select a Person from a database</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- The result type must be provided explicitly, as `retrieveById` has a polymorphic return type `IO a`.</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    alice' <span class="ot">&lt;-</span> retrieveById conn <span class="st">&quot;123456&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Person</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- delete a Person from a database</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    delete conn alice'</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- close connection</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    disconnect conn</span></code></pre></div>
<p>And here comes the output of the demo program. As you can see, there is some trace output for each of the database operations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> main</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Inserting</span> <span class="dt">Person</span> <span class="dv">123456</span> <span class="st">&quot;Alice&quot;</span> <span class="dv">25</span> <span class="st">&quot;Elmstreet 1&quot;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Updating</span> <span class="dt">Person</span> <span class="dv">123456</span> <span class="st">&quot;Alice&quot;</span> <span class="dv">25</span> <span class="st">&quot;Main Street 200&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Retrieve</span> <span class="dt">Person</span> with <span class="fu">id</span> <span class="dv">123456</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Deleting</span> <span class="dt">Person</span> with <span class="fu">id</span> <span class="dv">123456</span></span></code></pre></div>
<p>Summarizing, we can state that there is virtually no boilerplate code required in the user code.
The only thing we have to do is to derive the <code>Data</code> type class for our persistent data types.
The library takes care of the rest.</p>
<h2 id="a-deeper-dive-into-the-library">A deeper dive into the library</h2>
<h3 id="the-persist-function">The <code>persist</code> function</h3>
<p>In this section we are taking a closer look at the library internals. Let’s start with the <code>persist</code> function:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that persists an entity  to a database.</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- The function takes an HDBC connection and an entity as parameters.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- The entity is either inserted or updated, depending on whether it already exists in the database.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- The required SQL statements are generated dynamically using Haskell generics and reflection</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="ot">persist ::</span> (<span class="dt">IConnection</span> conn, <span class="dt">Data</span> a) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>persist conn entity <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  resultRows <span class="ot">&lt;-</span> quickQuery conn selectStmt []</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> resultRows <span class="kw">of</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>      trace <span class="op">$</span> <span class="st">&quot;Inserting &quot;</span> <span class="op">++</span> gshow entity</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>      runRaw conn insertStmt</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>      commit conn</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    [_singleRow] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>      trace <span class="op">$</span> <span class="st">&quot;Updating &quot;</span> <span class="op">++</span> gshow entity</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>      runRaw conn updateStmt</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>      commit conn</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;More than one entity found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo entity</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    eid <span class="ot">=</span> entityId entity</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    selectStmt <span class="ot">=</span> selectStmtFor ti eid</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    insertStmt <span class="ot">=</span> insertStmtFor entity</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    updateStmt <span class="ot">=</span> updateStmtFor entity</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the primary key value of an entity as a String.    </span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="ot">entityId ::</span> <span class="kw">forall</span> d<span class="op">.</span> (<span class="dt">Data</span> d) <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>entityId x <span class="ot">=</span> fieldValueAsString x (idColumn (typeInfo x))</span></code></pre></div>
<p>The overall logic of this function is as follows:</p>
<ol type="1">
<li>Perform a select query against the table corresponding to type <code>a</code> to check whether a record is already present for the primary key value derived from <code>entity</code>.</li>
<li>If the list of resulting rows is empty, the entity has not been persisted before and an <code>INSERT</code>-statement has to be excecuted.</li>
<li>If the list contains exactly one row, the entity already was stored in the DB and an <code>UPDATE</code>-statement has to be executed.</li>
<li>If the list contains more than one row, something is wrong and an error is thrown.</li>
</ol>
<p>The <code>selectStmtFor</code>, <code>insertStmtFor</code> and <code>updateStmtFor</code> functions are used to generate the required SQL statements dynamically.</p>
<h4 id="inserting-an-entity">Inserting an entity</h4>
<p>Let’s start with <code>insertStmtFor</code> as it is the simplest one.</p>
<p>Let’s say we have a Person entity:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alice ::</span> <span class="dt">Person</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>alice <span class="ot">=</span> <span class="dt">Person</span> {personID <span class="ot">=</span> <span class="dv">123456</span>, name <span class="ot">=</span> <span class="st">&quot;Alice&quot;</span>, age <span class="ot">=</span> <span class="dv">25</span>, address <span class="ot">=</span> <span class="st">&quot;Elmstreet 1&quot;</span>}</span></code></pre></div>
<p>Then the corresponding insert statement is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">INSERT</span> <span class="kw">INTO</span> Person (<span class="kw">id</span>, name, age, address) <span class="kw">VALUES</span> (<span class="dv">123456</span>, <span class="ot">&quot;Alice&quot;</span>, <span class="dv">25</span>, <span class="ot">&quot;Elmstreet 1&quot;</span>);</span></code></pre></div>
<p>So in order to generate the insert statement we need to know the table name, the column names and the values.
The idea is to use Haskell Generics to obtain these from the entity instance.
As of now I’m using the type- and attribute-names directly as column names. But this could be easily changed later on.
The tricky business is to dynamically inspect the entity instance and extract the values of the attributes.</p>
<p>So here comes the code for <code>insertStmtFor</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insertStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>insertStmtFor x <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;INSERT INTO &quot;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> typeName x</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; (&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNames x)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;) VALUES (&quot;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldValues x)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;);&quot;</span></span></code></pre></div>
<p>The overall construction of the insert statement is obvious. We just need to know a bit more about the <code>typeName</code>, <code>fieldNames</code> and <code>fieldValues</code> functions from the <code>TypeInfo</code> module:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the (unqualified) type name of an entity.</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="ot">typeName ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>typeName <span class="ot">=</span> dataTypeName <span class="op">.</span> dataTypeOf</span></code></pre></div>
<p>The <code>typeName</code> function uses the <code>dataTypeOf :: a -&gt; DataType</code> function of the <code>Data</code>type class to obtain the type of a <code>Data</code>instance.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that take an entity as input paraemeter and returns a list of </span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   Strings representing the values of all fields of the entity.</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   Example: fieldValues (Person &quot;John&quot; 42) = [&quot;John&quot;, &quot;42&quot;]</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValues ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>fieldValues <span class="ot">=</span> gmapQ gshow</span></code></pre></div>
<p>The function <code>fieldValues</code> is a bit more tricky. It uses the <code>gmapQ</code> function from the <code>Data.Data</code> module to map the <code>gshow</code> function over all attributes of the entity. The <code>gshow</code> function is a generic version of the <code>show</code> function that works on any <code>Data</code> instance.
If you want to know more about <code>gmapQ</code> and <code>gshow</code>, you can read Chris Done’s <a href="https://chrisdone.com/posts/data-typeable/">Typeable and Data in Haskell</a>.</p>
<p>To understand the <code>fieldNames</code> function, we need to take a look at <code>TypeInfo</code> and <code>FieldInfo</code> first:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A data type that holding information about a type. The Phantom type parameter `a` ensures type safety.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeInfo</span> a <span class="ot">=</span> <span class="dt">TypeInfo</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  { <span class="co">-- | The constructors of the type.</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    typeConstructor ::</span> <span class="dt">Constr</span>,</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The fields of the type.</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    typeFields      ::</span> [<span class="dt">FieldInfo</span>]</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A data type that holds information about a field of a data type.</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FieldInfo</span> <span class="ot">=</span> <span class="dt">FieldInfo</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  { <span class="co">-- | The name of the field, Nothing if it has none.</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldName        ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>,</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The constructor of the field.</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldConstructor ::</span> <span class="dt">Constr</span>,</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | The type of the field.</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    fieldType        ::</span> <span class="dt">TypeRep</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)  </span></code></pre></div>
<p>A <code>TypeInfo</code> can be obtained from an entity using the <code>typeInfo</code> function:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeInfo ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TypeInfo</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>typeInfo x <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TypeInfo</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    { typeConstructor <span class="ot">=</span> toConstr x,</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      typeFields <span class="ot">=</span> fieldInfo x</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Where <code>toConstr :: a -&gt; Constr</code> is a function from the <code>Data</code> type class that returns the constructor of a <code>Data a</code> instance; and
<code>fieldInfo</code> is a function that returns the list of <code>FieldInfo</code> instances for a given entity:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns a list of FieldInfos representing the name, constructor and type of each field in the data type `a`.</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldInfo ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">FieldInfo</span>]</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>fieldInfo x <span class="ot">=</span> <span class="fu">zipWith3</span> <span class="dt">FieldInfo</span> names constrs types</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    constructor <span class="ot">=</span> toConstr x</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    candidates <span class="ot">=</span> constrFields constructor</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    constrs <span class="ot">=</span> gmapQ toConstr x</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    types <span class="ot">=</span> gmapQ typeOf x</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    names ::</span> [<span class="dt">Maybe</span> <span class="dt">String</span>] <span class="ot">=</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> <span class="fu">length</span> candidates <span class="op">==</span> <span class="fu">length</span> constrs</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="fu">map</span> <span class="dt">Just</span> candidates</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="fu">replicate</span> (<span class="fu">length</span> constrs) <span class="dt">Nothing</span></span></code></pre></div>
<p>The <code>fieldInfo</code> function uses the <code>constrFields :: Constr -&gt; [String]</code> function from the <code>Data</code> type class to obtain the names of the fields of the constructor of the entity. If type <code>a</code> is a record type, the names of the fields are returned. Otherwise an empty list is returned.
This list of candidate field names then used to create a list <code>names</code> of <code>Maybe String</code> values . If the length of the candidate list is equal to the length of the list of actual field constructors, the entity is a record type and the candidate names are used. Otherwise the list of names is filled with <code>Nothing</code> values.</p>
<p>The <code>gmapQ</code> function is used to map the <code>toConstr</code> and <code>typeOf</code> functions over the entity to obtain the constructors and types of the fields.</p>
<p>Finally the <code>zipWith3</code> function is used to combine the three lists into a list of <code>FieldInfo</code> instances.</p>
<p>Now back to the <code>fieldNames</code> function:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the list of field names of an entity of type `a`.  </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldNames ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>fieldNames <span class="ot">=</span> fieldNamesFromTypeInfo <span class="op">.</span> typeInfo</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the list of field names of a `TypeInfo a` object.</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   An error is thrown if the type does not have named fields.</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldNamesFromTypeInfo ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>fieldNamesFromTypeInfo ti <span class="ot">=</span> <span class="fu">map</span> (expectJust errMsg <span class="op">.</span> fieldName) (typeFields ti)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    errMsg <span class="ot">=</span> <span class="st">&quot;Type &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot; does not have named fields&quot;</span></span></code></pre></div>
<p>The <code>fieldNames</code> function uses the <code>typeInfo</code> function to obtain the <code>TypeInfo</code> instance for the entity and then maps the <code>fieldNamesFromTypeInfo</code> function over all type fields to obtain the list of field names.</p>
<p>This is all tooling that we need to generate the insert statement for an entity by dynamically inspecting its type information. This statement is then used to insert the entity into the database by using the HDBC API.</p>
<h4 id="updating-an-entity">Updating an entity</h4>
<p>The update statement is generated in a similar way. The only difference is that we need to know the primary key of the entity in order to generate the <code>WHERE</code> clause of the update statement.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns an SQL update statement for an entity. Type 'a' must be an instance of Data.</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">updateStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>updateStmtFor x <span class="ot">=</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;UPDATE &quot;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> typeName x</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; SET &quot;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> updatePairs</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> fieldValueAsString x (idColumn ti)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    updatePairs <span class="ot">=</span> <span class="fu">zipWith</span> (\n v <span class="ot">-&gt;</span> n <span class="op">++</span> <span class="st">&quot; = &quot;</span> <span class="op">++</span> v) (fieldNames x) (fieldValues x)</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo x</span></code></pre></div>
<p>The primary key column is obtained using the <code>idColumn</code> function:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the name of the primary key column for a type 'a'.</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  By convention we are using the following name: convert the type name to lower case and append &quot;ID&quot;.</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">idColumn ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>idColumn ti <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toLower</span> (tiTypeName ti) <span class="op">++</span> <span class="st">&quot;ID&quot;</span></span></code></pre></div>
<p>The <code>fieldValueAsString</code> function takes an entity and a field name as input parameters and returns the value of the field as a String:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that takes an entity and a field name as input parameters and returns the value of the field as a String.</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  Example: fieldValueAsString (Person &quot;John&quot; 42) &quot;name&quot; = &quot;John&quot;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  Example: fieldValueAsString (Person &quot;John&quot; 42) &quot;age&quot; = &quot;42&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co">--  if the field is not present in the entity, an error is thrown.</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValueAsString ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>fieldValueAsString x field <span class="ot">=</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  valueList <span class="op">!!</span> <span class="fu">index</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    fieldList <span class="ot">=</span> fieldNames x</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    valueList <span class="ot">=</span> fieldValues x</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> <span class="ot">=</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>      expectJust</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;Field &quot;</span> <span class="op">++</span> field <span class="op">++</span> <span class="st">&quot; is not present in type &quot;</span> <span class="op">++</span> typeName x)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        (elemIndex field fieldList)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that take an entity as input parameter and returns a list of </span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">--   Strings representing the values of all fields of the entity.</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">--   Example: fieldValues (Person &quot;John&quot; 42) = [&quot;John&quot;, &quot;42&quot;]</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="ot">fieldValues ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>fieldValues <span class="ot">=</span> gmapQ gshow</span></code></pre></div>
<h4 id="selecting-an-entity">Selecting an entity</h4>
<p>Creating a select query with <code>selectStmtFor</code> works slightly different than <code>insertStmtFor</code> and <code>updateStmtFor</code>. When creating a <code>SELECT</code> statement we don’t have an entity to inspect. Instead we need to know the type of the entity and the primary key value of the entity we want to select.
That’s why we need to pass the type information and the primary key value as parameters to the <code>selectStmtFor</code> function:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `TypeInfo` object and a primary key value as input parameters and returns a select statement for the entity.</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ot">selectStmtFor ::</span> (<span class="dt">Show</span> <span class="fu">id</span>) <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="fu">id</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>selectStmtFor ti eid <span class="ot">=</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SELECT &quot;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNamesFromTypeInfo ti)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; FROM &quot;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> tiTypeName ti</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that returns the (unqualified) type name of `a` from a `TypeInfo a` object.</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tiTypeName ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>tiTypeName <span class="ot">=</span> dataTypeName <span class="op">.</span> constrType <span class="op">.</span> typeConstructor    </span></code></pre></div>
<p>Apart from <code>tiTypeName</code> we have already seen all the other ingredients of the <code>selectStmtFor</code> function.</p>
<h3 id="the-retrievebyid-function">The <code>retrieveById</code> function</h3>
<p>The <code>retrieveById</code> function is the counterpart of the <code>persist</code> function. It takes a connection and a primary key value as input parameters and returns the entity with the given primary key value. If no unique entity with the given primary key value exists, an error is thrown.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A function that retrieves an entity from a database.</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   The function takes an HDBC connection and an entity id as parameters.</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   It returns the entity of type `a` with the given id.</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   An error is thrown if no such entity exists or if there are more than one entity with the given id.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">retrieveById ::</span> <span class="kw">forall</span> a conn <span class="fu">id</span><span class="op">.</span> (<span class="dt">Data</span> a, <span class="dt">IConnection</span> conn, <span class="dt">Show</span> <span class="fu">id</span>) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> <span class="fu">id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>retrieveById conn eid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ti <span class="ot">=</span> typeInfoFromContext </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>      stmt <span class="ot">=</span> selectStmtFor ti eid</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Retrieve &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot; with id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>  resultRowsSqlValues <span class="ot">&lt;-</span> quickQuery conn stmt []</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> resultRowsSqlValues <span class="kw">of</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;No &quot;</span> <span class="op">++</span> <span class="fu">show</span> (typeConstructor ti) <span class="op">++</span> <span class="st">&quot; found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    [singleRowSqlValues] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> </span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        expectJust </span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>          (<span class="st">&quot;No &quot;</span> <span class="op">++</span> <span class="fu">show</span> (typeConstructor ti) <span class="op">++</span> <span class="st">&quot; found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid) </span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>          (buildFromRecord ti<span class="ot"> singleRowSqlValues ::</span> <span class="dt">Maybe</span> a)</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;More than one entity found for id &quot;</span> <span class="op">++</span> <span class="fu">show</span> eid</span></code></pre></div>
<p>We have already seen the <code>selectStmtFor</code> function in the previous section. But we have two other quite elaborated ingredients to make the <code>retrieveById</code> function work:</p>
<ul>
<li>The <code>typeInfoFromContext</code> function is a helper function that returns the <code>TypeInfo</code> instance for the entity type <code>a</code>:</li>
<li>The <code>buildFromRecord</code> function takes a <code>TypeInfo</code> instance and a list of <code>SqlValue</code> objects and returns the entity of type <code>a</code> if the list of <code>SqlValue</code> objects can be converted to the entity type <code>a</code>. If the conversion fails, <code>Nothing</code> is returned.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function creates a TypeInfo object from the context of a function call.</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   The Phantom Type parameter `a` is used to convince the compiler that the `TypeInfo a` object really describes type `a`.  </span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   See also https://stackoverflow.com/questions/75171829/how-to-obtain-a-data-data-constr-etc-from-a-type-representation</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="ot">typeInfoFromContext ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>typeInfoFromContext <span class="ot">=</span> </span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dt <span class="ot">=</span> dataTypeOf (<span class="fu">undefined</span><span class="ot"> ::</span> a)   <span class="co">-- This is the trick to get the type from the context. </span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      constr <span class="ot">=</span> <span class="kw">case</span> dataTypeConstrs dt <span class="kw">of</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        [cnstr] <span class="ot">-&gt;</span> cnstr</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        _       <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;typeInfoFromContext: Only types with one constructor are supported&quot;</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>      evidence <span class="ot">=</span> fromConstr<span class="ot"> constr ::</span> a  <span class="co">-- this is evidence for the compiler that we have created a value of type `a`</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> typeInfo evidence</span></code></pre></div>
<p>This is quite dense, so let’s take it step by step:</p>
<p>First we use <code>dataTypeOf :: a -&gt; DataType</code> to get the <code>DataType</code> object for the type <code>a</code>.
As we don’t have a value of type <code>a</code> at hand, we have to take it from thin air. So we use an <code>undefined :: a</code> as parameter.
This looks a bit awkward, but seems to be the official way to do it.</p>
<p>Then we use <code>dataTypeConstrs</code> to get a list of <code>DataConstr</code> objects for the type <code>a</code>.
If the list contains exactly one constructor, we use it to create a sample value of type <code>a</code> with <code>fromConstr</code>.
Otherwise we throw an error.</p>
<p>Finally, this sample value <code>evidence</code> is used to create a <code>TypeInfo a</code> object for the type <code>a</code>.
It is important to understand that <code>evidence</code> being of type <code>a</code> forms a proof that the <code>TypeInfo a</code>
object really describes the type <code>a</code> from the context of the function.</p>
<p>Cudos to <a href="https://stackoverflow.com/questions/75171829/how-to-obtain-a-data-data-constr-etc-from-a-type-representation">the brilliant people on stackoverflow</a>
for the explanation of how to get the <code>DataType</code> object from thin air.</p>
<p>The <code>buildFromRecord</code> function is even a bit more complex.
It takes a <code>TypeInfo a</code> object and a list of <code>SqlValue</code> objects and tries to construct an entity of type <code>a</code>
from the list of <code>SqlValue</code> objects. If the construction fails, <code>Nothing</code> is returned:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `TypeInfo a`and a List of HDBC `SqlValue`s and returns a `Maybe a`.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  If the construction of an entity fails, Nothing is returned, otherwise Just a.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">buildFromRecord ::</span> (<span class="dt">Data</span> a) <span class="ot">=&gt;</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> [<span class="dt">SqlValue</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>buildFromRecord ti record <span class="ot">=</span> applyConstr ctor dynamicsArgs</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    ctor <span class="ot">=</span> typeConstructor ti</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    types <span class="ot">=</span> <span class="fu">map</span> fieldType (typeFields ti)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    dynamicsArgs <span class="ot">=</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>      expectJust</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>        (<span class="st">&quot;buildFromRecord: error in converting record &quot;</span> <span class="op">++</span> <span class="fu">show</span> record)</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>        (zipWithM convert types record)</span></code></pre></div>
<p>Before we can apply the <code>applyConstr</code> function to instantiate an <code>a</code> value, we have to do some preparation work.
The <code>[SqlValue]</code> list contains the values of the fields of the entity as they are coming from the database.
In order to use these values to instantiate an <code>a</code> value, we have to convert them to the types of the fields of the entity.
In order to use them as list elements we wrap them in <code>Dynamic</code> objects.
See also this Haskell Wiki entry on <a href="https://wiki.haskell.org/Heterogenous_collections#A_Universal_type">heterogenous collections with <code>Dynamic</code></a></p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | convert a SqlValue into a Dynamic value that is backed by a value of the type represented by the SomeTypeRep parameter.</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  If conversion fails, return Nothing.</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  conversion to Dynamic is required to allow the use of fromDynamic in applyConstr</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">--  see also https://stackoverflow.com/questions/46992740/how-to-specify-type-of-value-via-typerep</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">convert ::</span> <span class="dt">SomeTypeRep</span> <span class="ot">-&gt;</span> <span class="dt">SqlValue</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Dynamic</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>convert (<span class="dt">SomeTypeRep</span> rep) val</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Double</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Double</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">String</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">String</span>)</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Char</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Char</span>)</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">B.ByteString</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">B.ByteString</span>)</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Word32</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Word32</span>)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Word64</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Word64</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int32</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int32</span>)</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Int64</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Int64</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Integer</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Integer</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Bool</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Bool</span>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">UTCTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">UTCTime</span>)</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">POSIXTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">POSIXTime</span>)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">LocalTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">LocalTime</span>)</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">ZonedTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">ZonedTime</span>)</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TimeOfDay</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TimeOfDay</span>)</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Day</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Day</span>)</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">NominalDiffTime</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">NominalDiffTime</span>)</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">Ratio</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">Ratio</span> <span class="dt">Integer</span>)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TL.Text</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TL.Text</span>)</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Just</span> <span class="dt">HRefl</span> <span class="ot">&lt;-</span> eqTypeRep rep (typeRep <span class="op">@</span><span class="dt">TS.Text</span>) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> toDyn (fromSql<span class="ot"> val ::</span> <span class="dt">TS.Text</span>)</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>The <code>convert</code> function takes a <code>SomeTypeRep</code>, representing the type of a given entity field, and a <code>SqlValue</code> object and tries to convert the <code>SqlValue</code> to the type represented by <code>SomeTypeRep</code>. If the conversion fails, <code>Nothing</code> is returned. This explicit conversion is needed keep the compiler happy.
As you can see the list of supported types already covers most of the types supported by HDBC.</p>
<p>Now we are ready to use the <code>applyConstr</code> function to instantiate an <code>a</code> value. The <code>applyConstr</code> function takes a <code>Constr</code> object and a list of <code>Dynamic</code> objects and tries to construct an entity of type <code>a</code> fromthe list of <code>Dynamic</code> objects. If the construction fails, <code>Nothing</code> is returned.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function takes a `Constr` and a list of `Dynamic` values and returns a `Maybe a`.</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   If an `a`entity could be constructed, Just a is returned, otherwise Nothing.</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   See also https://stackoverflow.com/questions/47606189/fromconstrb-or-something-other-useful</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   for Info on how to use fromConstrM</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="ot">applyConstr ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Constr</span> <span class="ot">-&gt;</span> [<span class="dt">Dynamic</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>applyConstr ctor args <span class="ot">=</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span><span class="ot"> nextField ::</span> <span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> <span class="dt">StateT</span> [<span class="dt">Dynamic</span>] <span class="dt">Maybe</span> d</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>      nextField <span class="ot">=</span> <span class="dt">StateT</span> uncons <span class="op">&gt;&gt;=</span> lift <span class="op">.</span> fromDynamic</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="kw">case</span> runStateT (fromConstrM nextField ctor) args <span class="kw">of</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (x, []) <span class="ot">-&gt;</span> <span class="dt">Just</span> x</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        _            <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- runtime type error or too few / too many arguments</span></span></code></pre></div>
<h3 id="the-retrieveall-function">The <code>retrieveAll</code> function</h3>
<p>This function is used to retrieve all entities of a given type from the database. It takes an HDBC connection as parameter and returns a list of entities of type <code>a</code>. The type <code>a</code> is determined by the context of the function call.</p>
<p>As you can see, thisd function reuses most of the ingredients from <code>retrieveById</code> but just uses a simpler SQL statement to retrieve all entities of a given type:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function retrieves all entities of type `a` from a database.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">--  The function takes an HDBC connection as parameter.</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co">--  The type `a` is determined by the context of the function call.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="ot">retrieveAll ::</span> <span class="kw">forall</span> a conn<span class="op">.</span> (<span class="dt">Data</span> a, <span class="dt">IConnection</span> conn) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>retrieveAll conn <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ti <span class="ot">=</span> typeInfoFromContext</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>      stmt <span class="ot">=</span> selectAllStmtFor ti</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Retrieve all &quot;</span> <span class="op">++</span> tiTypeName ti <span class="op">++</span> <span class="st">&quot;s&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  resultRowsSqlValues <span class="ot">&lt;-</span> quickQuery conn stmt []</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">map</span> (expectJust <span class="st">&quot;No entity found&quot;</span>) (<span class="fu">map</span> (buildFromRecord ti)<span class="ot"> resultRowsSqlValues ::</span> [<span class="dt">Maybe</span> a])</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="ot">selectAllStmtFor ::</span> <span class="dt">TypeInfo</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>selectAllStmtFor ti <span class="ot">=</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;SELECT &quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> intercalate <span class="st">&quot;, &quot;</span> (fieldNamesFromTypeInfo ti)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; FROM &quot;</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> tiTypeName ti</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span></code></pre></div>
<h3 id="the-delete-function">The <code>delete</code> function</h3>
<p>This function is used to delete an entity from the database. It takes an HDBC connection and an entity of type <code>a</code> as parameters. It also does not bring anything new to the table. It just uses the <code>deleteStmtFor</code> function to generate the SQL statement to delete the entity from the database:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">delete ::</span> (<span class="dt">IConnection</span> conn, <span class="dt">Data</span> a) <span class="ot">=&gt;</span> conn <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>delete conn entity <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  trace <span class="op">$</span> <span class="st">&quot;Deleting &quot;</span> <span class="op">++</span> typeName entity <span class="op">++</span> <span class="st">&quot; with id &quot;</span> <span class="op">++</span> entityId entity</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  runRaw conn (deleteStmtFor entity)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  commit conn</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteStmtFor ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>deleteStmtFor x <span class="ot">=</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;DELETE FROM &quot;</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="fu">show</span> (typeName x)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; WHERE &quot;</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> idColumn ti</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot; = &quot;</span></span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> fieldValueAsString x (idColumn ti)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span> <span class="st">&quot;;&quot;</span></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>    ti <span class="ot">=</span> typeInfo x</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>We have learnt ho use <code>Data</code> based Generics to implement a simple persistence library. The user will not have to write any boilerplate code. The library will generate the SQL statements and the code to convert back and forth between the database records and Haskell entities.</p>
<p>The library is by no means complete. Right now it’s just a proof of concept.
But it shows that it is possible to use Generics to eliminate a lot of handwritten code in the implementation of a persistence library.</p>
<p>I’m explicitely asking for your feedback here:</p>
<ul>
<li>Do you regard such a persistence API as useful?</li>
<li>Do you have any suggestions for improvements?</li>
<li>Which feature would you like to see most urgently?</li>
<li>Do you think it makes sense to extend this proof of concept to a full fledged solution,
or are there already enough libraries out there that do the same?</li>
</ul>

</main>

<footer>
    Site proudly generated by
    <a href="http://jaspervdj.be/hakyll">Hakyll</a> | 
    Source code is available at 
    <a href="https://github.com/thma/thma.github.io">GitHub</a>
</footer>

</body>
</html>
