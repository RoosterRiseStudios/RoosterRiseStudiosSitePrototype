<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>lambda is not a four letter word - Implementing a Functional Language with Graph Reduction</title>
    <link rel="stylesheet" type="text/css" href="../css/composeconference.css" />
    <link rel="alternate" type="application/atom+xml" href="../atom.xml" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" />

    <!-- MATH JAX-->
    <script type="text/javascript" src="../static/mathjax/tex-mml-chtml.js"></script>

    <!-- favicon stuff-->
    <link rel="apple-touch-icon" sizes="57x57" href="../apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="../apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="../apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="../apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="../apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="../apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="../apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="../apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
    <link rel="manifest" href="../manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>
<body>

<header>
    <div class="heading">
        <div class="logo">
            <div style="float: left">
                <img src="../img/lambda-150.png" alt="\" height="40px" valign="bottom" />
            </div>
            <div>
                <a href="../">&nbsp;lambda is not a four letter word</a>
            </div>
        </div>
        <nav>
            <a href="../">home</a> | <a href="../about.html">about</a> | <a href="https://github.com/thma"><img valign="middle" src="../img/GitHub-Mark-32px.png" height="20px" alt="GitHub"></a>
        </nav>
    </div>
</header>

<main class="markdown-body" role="main">
    <h1>Implementing a Functional Language with Graph Reduction</h1>
    <div class="info">
    <em>Posted on December 27, 2021
    
        by Thomas Mahler
    </em><br /><br />
</div>

<p><a href="https://github.com/thma/lambda-ski/actions"><img src="https://github.com/thma/lambda-ski/workflows/Haskell-CI/badge.svg" alt="Actions Status" /></a> <a href="https://github.com/thma/lambda-ski"><img src="../img/forkme.png" height="20"></a></p>
<h2 id="abstract">Abstract</h2>
<p>Implementing a small functional language with a classic combinator based graph-reduction machine in Haskell.</p>
<p>The implementation is structured into three parts:</p>
<ol type="1">
<li><p>A λ-calculus parser from <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">A Combinatory Compiler</a> which was extended to cover a tiny functional language based on the untyped λ-calculus.</p></li>
<li><p>A compiler from λ-calculus to combinatory logic combinators (S,K,I,B,C and Y) which is based on bracket-abstraction and some optimization rules.</p></li>
<li><p>A graph-reducer. Combinator terms are allocated into a graph data-structure. Which is then reduced by applying combinator graph-reduction. The destructive inplace reduction of the graph is made possible by using <code>STRef</code> mutable references.</p></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>In my <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">last blog post</a> I presented two ways of transforming λ-terms into variable free representations: - bracket abstraction to combinatory logic terms (SKI) and - bracket abstraction to terms of closed cartesian categories (CCC).</p>
<p>I demonstrated that both representations are equivalent as they imply the same reduction rules.</p>
<p>My original intention was to extend an existing Haskell CCC implementation to a proof-of-concept implementation of a small functional language. I even promised to cover this in my next blog post.</p>
<p>I invested a lot of time in this idea but I failed to get it off the ground. <a href="https://github.com/thma/lambda-cat">At least the code of these experiments has been preserved</a>.</p>
<p>So I came back to writing a SKI graph-reduction as the backend of my language implementation. This is a well-worn path. I took the basic ideas from the classic <a href="https://www.goodreads.com/book/show/3468677-compiling-functional-languages">compiling functional languages</a> which dates back to 1988.</p>
<p>Fortunately, I did not fail this time! In the following I’m explaining my implementation approach. I’ll also share some of my insights and talk about possible future extensions.</p>
<h2 id="representing-λ-expressions">representing λ-expressions</h2>
<p>I’m aiming at a very rudimentary language that is basically just pure λ-calculus plus integers. Here is an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">Y</span>    <span class="ot">=</span> λf <span class="op">.</span> (λx <span class="op">.</span> x x)(λx <span class="op">.</span> f(x x))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>fact <span class="ot">=</span> <span class="dt">Y</span>(\f n <span class="ot">-&gt;</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="op">*</span> n (f (sub1 n))))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>main <span class="ot">=</span> fact <span class="dv">10</span></span></code></pre></div>
<p>As you can see it’s possible to use classical λ-calculus notation <code>λx . x x</code> as well as Haskell syntax: <code>\x -&gt; x x</code>. It’s also possible to freely mix both styles.</p>
<p>λ-expressions can be assigned to names in a top-level environment by using the <code>=</code> sign. those names may be referred to in other λ-expressions. As of now recursive (also mutually recursive) references are not supported.</p>
<p>The <code>main</code> expression has a special meaning; it is interpreted as the entry point to a program.</p>
<p>With this knowledge at hand you will immediately recognize that the above program will compute the factorial of 10. Where <code>fact</code> is defined in a non-recursive way by means of the fixed-point combinator <code>Y</code>.</p>
<p>Expressions of this language are represented by the data type <code>Expr</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">:@</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Expr</span> <span class="op">:@</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Integer</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>The top-level environment which maps names to λ-Expressions is represented by the following type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Environment</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Expr</span>)]</span></code></pre></div>
<h2 id="the-parser">The Parser</h2>
<p>There is not much to see in <a href="https://github.com/thma/lambda-ski/blob/main/src/Parser.hs">this area</a>. It’s just a simple Parsec based parser. Most of the code was taken from <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">A Combinatory Compiler</a>. I just added the parsing of Integers.</p>
<p>The parser module exports to function <code>parseEnvironmentEither</code> and <code>parseEnvironment</code>. The former is a total function returning an Either: <code>parseEnvironmentEither :: String -&gt; Either ParseError Environment</code>, whereas the latter simply returns an <code>Environment</code> but may throw run-time errors.</p>
<p>The following <a href="https://github.com/thma/lambda-ski/blob/main/app/Main.hs">snippet</a> demonstrates how a program is parsed into an Environment:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">testSource ::</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>testSource <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>       <span class="st">&quot;Y    = λf -&gt; (λx -&gt; x x)(λx -&gt; f(x x)) \n&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;fact = Y(λf n -&gt; if (is0 n) 1 (* n (f (sub1 n)))) \n&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;main = fact 10 \n&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="kw">let</span> env <span class="ot">=</span> parseEnvironment testSource</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="fu">mapM_</span> <span class="fu">print</span> env</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>This code results in the following output, which shows all <code>(String, Expr)</code> tuples in the environment:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="st">&quot;Y&quot;</span>,   <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="op">:@</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(<span class="st">&quot;fact&quot;</span>,<span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> <span class="op">:@</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> (((<span class="dt">Var</span> <span class="st">&quot;if&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;is0&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>)) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">1</span>) <span class="op">:@</span> </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        ((<span class="dt">Var</span> <span class="st">&quot;*&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;sub1&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>))))))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>(<span class="st">&quot;main&quot;</span>,<span class="dt">Var</span> <span class="st">&quot;fact&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">10</span>)</span></code></pre></div>
<h2 id="bracket-abstraction">Bracket abstraction</h2>
<h3 id="motivation">Motivation</h3>
<p>Of course it is possible to write interpreters that evaluate these λ-expression to normalform. This is what any Lisp or Scheme eval/apply interpreter does at its core <a href="http://www.sicpdistilled.com/section/4.1/">(See a tiny example here)</a>.</p>
<p>One of the most problematic areas of these interpreters is the handling of variables. In order to provide static binding you will need closures that captures the current environment of variable bindings and thread them through the whole interpreter execution.</p>
<p>Language implemetors have thus experimented with many ways to tackle this issue. One of the most influential ideas was to completely get rid of variables by abstracting them.</p>
<p>The earliest version of this approach was <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">the SKI combinator calculus</a> invented by Haskell Curry and Moses Schönfinkel.</p>
<p>A λ-term that does not contain any free variables is said to be closed. Closed lambda terms are also called <em>combinators</em>.</p>
<p>Schönfinkel and Curry found out that any closed λ-term can be rewritten in terms of three basic combinators I, K and S (in fact only <em>K</em> and <em>S</em> are essential, as <em>I</em> can be expressed as SKK):</p>
<p><img style="align:center;" src="https://latex.codecogs.com/gif.latex?\begin{array}{rcl}&space;I&space;&&space;=&space;&&space;\lambda&space;x.x&space;\\&space;K&space;&&space;=&space;&&space;\lambda&space;x.&space;\lambda&space;y.x&space;\\&space;S&space;&&space;=&space;&&space;\lambda&space;f.(\lambda&space;g.(\lambda&space;x.fx(gx)))&space;\end{array}" title="\begin{array}{rcl} I & = & \lambda x.x \\ K & = & \lambda x. \lambda y.x \\ S & = & \lambda f.(\lambda g.(\lambda x.fx(gx))) \end{array}" /></p>
<p>In Haskell these combinators can simply be defined as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>i x <span class="ot">=</span> x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>k x y <span class="ot">=</span> x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>s f g x <span class="ot">=</span> f x (g x)</span></code></pre></div>
<h2 id="the-basic-abstraction-rules">The basic abstraction rules</h2>
<p>The idea of bracket abstraction is to rewrite any closed λ-term in terms of I, K and S. This recursive transformation is defined by the following equations:</p>
<p><img src="https://latex.codecogs.com/gif.latex?\begin{array}{rcl}&space;\left&space;\lceil&space;\lambda&space;x.x&space;\right&space;\rceil&space;&&space;=&space;&&space;I&space;\\&space;\left&space;\lceil&space;\lambda&space;x.y&space;\right&space;\rceil&space;&&space;=&space;&&space;K&space;y&space;\\&space;\left&space;\lceil&space;\lambda&space;x.M&space;N&space;\right&space;\rceil&space;&&space;=&space;&&space;S&space;\left&space;\lceil&space;\lambda&space;x.M&space;\right&space;\rceil&space;\left&space;\lceil&space;\lambda&space;x.N&space;\right&space;\rceil&space;\end{array}" title="\begin{array}{rcl} \left \lceil \lambda x.x \right \rceil & = & I \\ \left \lceil \lambda x.y \right \rceil & = & K y \\ \left \lceil \lambda x.M N \right \rceil & = & S \left \lceil \lambda x.M \right \rceil \left \lceil \lambda x.N \right \rceil \end{array}" /></p>
<p>This can be implemented in Haskell as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- | most basic bracket abstraction (plus resolution of free variables in the environment).</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">babs0 ::</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>babs0 env (<span class="dt">Lam</span> x e) <span class="co">-- this clause implements the three basic equations for bracket abstraction</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Var</span> y <span class="ot">&lt;-</span> t, x <span class="op">==</span> y     <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="op">|</span> x <span class="ot">`notElem`</span> fv [] t    <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> t</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  <span class="op">|</span> m <span class="op">:@</span> n <span class="ot">&lt;-</span> t            <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> babs0 env (<span class="dt">Lam</span> x m) <span class="op">:@</span> babs0 env (<span class="dt">Lam</span> x n)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  <span class="kw">where</span> t <span class="ot">=</span> babs0 env e</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>babs0 env (<span class="dt">Var</span> s) <span class="co">-- this clause resolves free variables by looking them up in the environment env</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> t <span class="ot">&lt;-</span> <span class="fu">lookup</span> s env <span class="ot">=</span> babs0 env t</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>              <span class="ot">=</span> <span class="dt">Var</span> s</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>babs0 env  (m <span class="op">:@</span> n)        <span class="ot">=</span> babs0 env m <span class="op">:@</span> babs0 env n  <span class="co">-- this clause recurses into applications</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>babs0 _env x               <span class="ot">=</span> x                           <span class="co">-- returns anything else unchanged</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="co">-- | compute the list of free variables of a lambda expression</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="ot">fv ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>fv vs (<span class="dt">Var</span> s) <span class="op">|</span> s <span class="ot">`elem`</span> vs <span class="ot">=</span> []</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>              <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">=</span> [s]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>fv vs (x <span class="op">:@</span> y)              <span class="ot">=</span> fv vs x <span class="ot">`union`</span> fv vs y</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>fv vs (<span class="dt">Lam</span> s f)             <span class="ot">=</span> fv (s<span class="op">:</span>vs) f</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>fv vs _                     <span class="ot">=</span> vs</span></code></pre></div>
<p>Let’s have a look at a simple example. first we parse a simple expression into a lambda-term:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> env <span class="ot">=</span> parseEnvironment <span class="st">&quot;main = (λx -&gt; + 4 x) 5\n&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> env</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>[(<span class="st">&quot;main&quot;</span>,<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">5</span>)]</span></code></pre></div>
<p>Next we apply bracket abstraction:</p>
<pre><code>ghci&gt; skiExpr = babs env (snd . head $ env)
ghci&gt; skiExpr
((Var &quot;s&quot; :@ (Var &quot;k&quot; :@ (Var &quot;+&quot; :@ Int 4))) :@ Var &quot;i&quot;) :@ Int 5</code></pre>
<p>The result of bracket abstraction is still a lambda-term, but one where all <code>Lam</code>-expression have been eliminated.</p>
<h3 id="optimization">Optimization</h3>
<p>Even from this simple example it is obvious that the SKI-combinator terms become larger than the original expressions. This will be an impediment to efficient implementation. So many different approaches have been conceived to mitigate this issue.</p>
<p>The earliest solution, already suggested by Schönfinkel, is to introduce additional combinators B and C that cover specific patterns in the source code. Here are the reduction rules for B and C.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">C</span> f g x <span class="ot">=</span> ((f x) g)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="dt">B</span> f g x <span class="ot">=</span> (f (g x))</span></code></pre></div>
<p>We could extend <code>babs</code> to cover B and C. But the most common way is to run a second optimization pass over the SKI-expression.</p>
<p>Here is is a simple example of such an optimization:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">opt ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>opt (<span class="dt">Var</span> <span class="st">&quot;i&quot;</span> <span class="op">:@</span> n<span class="op">@</span>(<span class="dt">Int</span> _n))                           <span class="ot">=</span> n</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e1)) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e2)) <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> (e1 <span class="op">:@</span> e2)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e2))              <span class="ot">=</span> (<span class="dt">Var</span> <span class="st">&quot;c&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> e2</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e1)) <span class="op">:@</span> e2)              <span class="ot">=</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> e2</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>opt (x <span class="op">:@</span> y)                                          <span class="ot">=</span> opt x <span class="op">:@</span> opt y</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>opt x                                                 <span class="ot">=</span> x</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="ot">ropt ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>ropt expr <span class="ot">=</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  <span class="kw">let</span> expr' <span class="ot">=</span> opt expr</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>  <span class="kw">in</span>  <span class="kw">if</span> expr' <span class="op">==</span> expr</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>        <span class="kw">then</span> expr</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>        <span class="kw">else</span> <span class="kw">case</span> expr' <span class="kw">of</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>          (x <span class="op">:@</span> y) <span class="ot">-&gt;</span> ropt <span class="op">$</span> ropt x <span class="op">:@</span> ropt y</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>          _        <span class="ot">-&gt;</span> ropt expr'</span></code></pre></div>
<p>Let’s try this out:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optExpr <span class="ot">=</span> ropt skiExpr</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optEpr</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>((<span class="dt">Var</span> <span class="st">&quot;b&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span>)) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">5</span></span></code></pre></div>
<p>This looks much better than before. See <a href="https://crypto.stanford.edu/~blynn/lambda/logski.html">this project for a more in depth coverage of optimization techniques</a>. I’m also planning to write a separate blog post on this subtopic.</p>
<p>The <a href="https://github.com/thma/lambda-ski/blob/main/src/LambdaToSKI.hs">sourcecode for this section can be found here</a></p>
<h2 id="graph-reduction-in-a-nutshell">Graph-reduction in a nutshell</h2>
<p>So now that we have eliminated lambda abstractions from our lambda terms it should be straight forward to evaluate these expressions with a simple interpreter.</p>
<p>Let’s have a look at a simple example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>sqr  <span class="ot">=</span> λx <span class="ot">-&gt;</span> <span class="op">*</span> x x</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>main <span class="ot">=</span> sqr (<span class="op">+</span> <span class="dv">3</span> <span class="dv">2</span>)</span></code></pre></div>
<p>When we implement a strict interpreter with applicative-order semantics, <code>(+ 3 2)</code> will be computed first and the result bound to the variable <code>x</code> in the local environment and then the body of <code>sqr</code> will be evaluated in this environment. That’s fine. but it’s not normal-order reduction.</p>
<p>When implementing a lazy interpreter with normal-order semantics, we can not compute <code>(+ 3 2)</code> before binding it to <code>x</code>. Thus we will have to bind an un-evaluated <em>thunk</em> to <code>x</code>. We will also have to make sure that <code>x</code> is only evaluated when needed and only once, even when it is used at several places in the body of <code>sqr</code>. (See <a href="https://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/lazyevaluation.html">these lecture notes for all the intricacies of this approach</a>)</p>
<p>Graph-reduction on the other hand, has some very interesting features: - It maintains normal-order reduction (that is lazy evaluation) - double evaluations of terms is avoided - dealing with local environments, variable scope, etc. at run-time is avoided - copying of argument data is significantly reduced as compared to eval/apply interpreters</p>
<p>Let’s see this in action with our toy example. The above program can be transformed into the following SKI combinator term:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">2</span>)</span></code></pre></div>
<p>This term can be represented as a binary graph, where each application <code>:@</code> is represented as an <code>@</code> node, all combinators like <code>(Var "s")</code> are represented with Constructors like <code>S</code>, <code>I</code>, <code>MUL</code>, <code>ADD</code> and integer values like <code>Int 2</code> are just shown as numeric values like <code>2</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>          <span class="op">@</span>                   </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>         <span class="op">/</span> \              </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>        <span class="op">/</span>   \               </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>       <span class="op">/</span>     <span class="op">@</span>          </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>      <span class="op">/</span>     <span class="op">/</span> \          </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>     <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    <span class="op">@</span>     <span class="op">/</span> \     </span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>   <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>    </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>  <span class="op">@</span>   <span class="dt">I</span>            </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a> <span class="op">/</span> \             </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a><span class="dt">S</span>  <span class="dt">MUL</span>   </span></code></pre></div>
<p>In the following diagram we follow the reduction of this graph:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>          <span class="op">@</span>                   <span class="op">@</span>                   <span class="op">@</span>                  <span class="op">@</span>           <span class="dv">25</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>         <span class="op">/</span> \                 <span class="op">/</span> \                 <span class="op">/</span> \                <span class="op">/</span> \</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        <span class="op">/</span>   \               <span class="op">/</span>   \               <span class="op">/</span>   \              <span class="op">/</span>   <span class="op">|</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>       <span class="op">/</span>     <span class="op">@</span>             <span class="op">/</span>     <span class="op">@</span>             <span class="op">/</span>     <span class="op">@</span>            <span class="op">/</span>   <span class="op">/</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>      <span class="op">/</span>     <span class="op">/</span> \           <span class="op">@</span>     <span class="op">/</span> \           <span class="op">@</span>     <span class="op">/</span> \          <span class="op">@</span>   <span class="op">/</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>     <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         <span class="op">/</span> \   <span class="dt">I</span>   <span class="op">|</span>         <span class="op">/</span> \   <span class="dt">I</span>   <span class="op">|</span>        <span class="op">/</span> \ <span class="op">/</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="op">@</span>     <span class="op">/</span> \           <span class="op">/</span>   <span class="op">@</span> ––––<span class="op">/</span>         <span class="op">/</span>   <span class="dv">5</span> ––––<span class="op">/</span>        <span class="op">/</span>   <span class="dv">5</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>   <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>         <span class="op">/</span>   <span class="op">/</span> \             <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  <span class="op">@</span>   <span class="dt">I</span>               <span class="op">/</span>   <span class="op">@</span>   <span class="dv">2</span>           <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a> <span class="op">/</span> \                 <span class="op">/</span>   <span class="op">/</span> \             <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a><span class="dt">S</span>  <span class="dt">MUL</span>             <span class="dt">MUL</span>  <span class="dt">ADD</span> <span class="dv">3</span>           <span class="dt">MUL</span>                <span class="dt">MUL</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a><span class="dt">Step</span> <span class="dv">0</span>             <span class="dt">Step</span> <span class="dv">1</span>               <span class="dt">Step</span> <span class="dv">2</span>             <span class="dt">Step</span> <span class="dv">3</span>                <span class="dt">Step</span> <span class="dv">4</span></span></code></pre></div>
<ul>
<li><p><strong>Step 0</strong>: This is just the initial state of the graph as explained above. Please note that in this state the <code>S</code> is our <em>redex</em> (i.e. the left-most ancestor of the root node) and <em>saturated</em> (i.e all three arguments of the combinator) are populated, so according to the reduction rule <code>s f g x = f x (g x)</code> we expect to see a reduction <code>S MUL I (ADD 3 2) = MUL (ADD 3 2) (I (ADD 3 2))</code> in step 1.</p></li>
<li><p><strong>Step 1</strong>: As expected the first reduction step mutates the graph to represent <code>MUL (ADD 3 2) (I (ADD 3 2))</code>. Please note that both occurrences of <code>(ADD 3 2)</code> are represented by references to one and the same node.</p></li>
<li><p><strong>Step 2</strong>: Now <code>MUL</code> has become the <em>redex</em> (short for reducible expression). But this time both arguments <code>(ADD 3 2)</code> and <code>I (ADD 3 2)</code> are not in normal-form and thus have to be reduced first before <code>MUL</code> can be executed. So first <code>(ADD 3 2)</code> is reduced to <code>5</code>. Please note that both references to the former <code>(ADD 3 2)</code> node now point to <code>5</code>. So in effect the <code>I (ADD 3 2)</code> node has changed to <code>I 5</code> as <code>(ADD 3 2)</code> was a shared node.</p></li>
<li><p><strong>Step 3</strong>: next the <code>I 5</code> node is reduced according to the equation <code>i x = x</code>. That is, the reference to the application node <code>I @ 5</code> is modified to directly point to <code>5</code> instead. Please note that both arguments point to one and the same numeric value <code>5</code>.</p></li>
<li><p><strong>Step 4</strong>: As a result of the transformation in step 3 both arguments of <code>MUL</code> are in normal-form. So now <code>MUL 5 5</code> can be performed: Accordingly the root node is now changed to <code>25</code>.</p></li>
</ul>
<p>Now that we have a basic understanding of the ideas behind graph-reduction we will have a closer look at the actual implementation in the following sections.</p>
<h2 id="allocating-a-graph-with-mutable-references">Allocating a Graph with mutable references</h2>
<p>As we have seen in the last section we will have to deal with mutable references in order to implement things like node sharing and in-place mutation of nodes.</p>
<p>I will use the Haskell datatype <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-STRef.html"><code>Data.STRef</code></a> which provides mutable references in the <code>ST</code> monad.</p>
<p>Here comes a basic example that demonstrates the basic functionality of <code>STRef</code>. A list of numbers is summed up by adding each of them to an accumulator. The accumulator is implemented by a reference <code>acc</code> pointing to an initial value of <code>0</code>. Then we iterate over the list of numbers and update the value of the accumulator by adding each number <code>x</code> to it. Finally the result is read out from the accumulator and extracted from the ST Monad by runST. From this example we can see that <code>STRef</code>s work much like pointers in imperative languages:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.STRef</span>       (<span class="dt">STRef</span>, modifySTRef, newSTRef, readSTRef writeSTRef)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span> (runST)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="co">-- | sum up a list of numerical values </span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ot">sumST ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>sumST numbers <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span> <span class="co">-- runST takes stateful ST code and makes it pure.</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  acc <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>        <span class="co">-- Create an STRef (a mutable variable) to an accumulator</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  forM_ numbers <span class="op">$</span> \x <span class="ot">-&gt;</span>    <span class="co">-- iterate over all numbers</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    modifySTRef acc (<span class="op">+</span> x)  <span class="co">-- add each number to what we have in acc.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  readSTRef acc            <span class="co">-- read the value of acc, which will be returned by the runST above.</span></span></code></pre></div>
<p>This looks promising. So now lets implement a binary graph for our compiled combinator terms with it:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">:@:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Graph</span> s</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="ot">=</span> (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="op">:@:</span> (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Comb</span> <span class="dt">Combinator</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Num</span> <span class="dt">Integer</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Combinator</span> <span class="ot">=</span> <span class="dt">I</span> <span class="op">|</span> <span class="dt">K</span> <span class="op">|</span> <span class="dt">S</span> <span class="op">|</span> <span class="dt">B</span> <span class="op">|</span> <span class="dt">C</span> <span class="op">|</span> <span class="dt">Y</span> <span class="op">|</span> <span class="dt">P</span> <span class="op">|</span> <span class="dt">ADD</span> <span class="op">|</span> <span class="dt">SUB</span> <span class="op">|</span> <span class="dt">MUL</span> <span class="op">|</span> <span class="dt">DIV</span> <span class="op">|</span> <span class="dt">REM</span> <span class="op">|</span> <span class="dt">SUB1</span> <span class="op">|</span> <span class="dt">EQL</span> <span class="op">|</span> <span class="dt">ZEROP</span> <span class="op">|</span> <span class="dt">IF</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>So we basically mimic the <code>Expr</code> data type used to encode λ-expression but without variables and lambda-abstractions. The data type <code>Combinator</code> contains constructors for combinators that we intend to implement in the graph-reduction engine.</p>
<p>Next we define a function <code>allocate</code> that allows to allocate a ‘lambda-abstracted’ λ-expression (of type <code>Expr</code>) into a reference to a <code>Graph</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">-- | allocate a 'lambda-abstracted' Expr into a referenced Graph</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="ot">allocate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>allocate (<span class="dt">Var</span> name) <span class="ot">=</span> newSTRef <span class="op">$</span> <span class="dt">Comb</span> <span class="op">$</span> fromString name</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>allocate (<span class="dt">Int</span> val)  <span class="ot">=</span> newSTRef <span class="op">$</span> <span class="dt">Num</span> val</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>allocate (l <span class="op">:@</span> r)   <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  lg <span class="ot">&lt;-</span> allocate l</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  rg <span class="ot">&lt;-</span> allocate r</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  newSTRef <span class="op">$</span> lg <span class="op">:@:</span> rg</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>allocate (<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;lambdas must already be abstracted away!&quot;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="co">-- | lookup Combinator constructors by their names</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="ot">fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Combinator</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>fromString <span class="st">&quot;i&quot;</span>    <span class="ot">=</span> <span class="dt">I</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>fromString <span class="st">&quot;k&quot;</span>    <span class="ot">=</span> <span class="dt">K</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>fromString <span class="st">&quot;s&quot;</span>    <span class="ot">=</span> <span class="dt">S</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>fromString <span class="st">&quot;b&quot;</span>    <span class="ot">=</span> <span class="dt">B</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>fromString <span class="st">&quot;c&quot;</span>    <span class="ot">=</span> <span class="dt">C</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>fromString <span class="st">&quot;y&quot;</span>    <span class="ot">=</span> <span class="dt">Y</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>fromString <span class="st">&quot;p&quot;</span>    <span class="ot">=</span> <span class="dt">P</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>fromString <span class="st">&quot;+&quot;</span>    <span class="ot">=</span> <span class="dt">ADD</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>fromString <span class="st">&quot;sub&quot;</span>  <span class="ot">=</span> <span class="dt">SUB</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a>fromString <span class="st">&quot;div&quot;</span>  <span class="ot">=</span> <span class="dt">DIV</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>fromString <span class="st">&quot;rem&quot;</span>  <span class="ot">=</span> <span class="dt">REM</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>fromString <span class="st">&quot;*&quot;</span>    <span class="ot">=</span> <span class="dt">MUL</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a>fromString <span class="st">&quot;sub1&quot;</span> <span class="ot">=</span> <span class="dt">SUB1</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a>fromString <span class="st">&quot;eq&quot;</span>   <span class="ot">=</span> <span class="dt">EQL</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>fromString <span class="st">&quot;is0&quot;</span>  <span class="ot">=</span> <span class="dt">ZEROP</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a>fromString <span class="st">&quot;if&quot;</span>   <span class="ot">=</span> <span class="dt">IF</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a>fromString _c     <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;unknown combinator &quot;</span> <span class="op">++</span> _c</span></code></pre></div>
<p>So let’s see this in action:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optExpr <span class="ot">=</span> ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">2</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> graph <span class="ot">=</span> allocate optExpr</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString graph </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="st">&quot;(((S :@: MUL) :@: I) :@: ((ADD :@: 3) :@: 2))&quot;</span></span></code></pre></div>
<p>I’m using the <code>mToString</code> helper function to render <code>ST s (STRef s (Graph s))</code> instances:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">mToString ::</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">String</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>mToString g <span class="ot">=</span> toString <span class="op">=&lt;&lt;</span> g     </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">toString ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">String</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>toString graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a> g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a> toString' g <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>   toString' (<span class="dt">Comb</span> c) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> c</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>   toString' (<span class="dt">Num</span> i) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> i</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>   toString' (lP <span class="op">:@:</span> rP) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>     lG <span class="ot">&lt;-</span> readSTRef lP</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>     rG <span class="ot">&lt;-</span> readSTRef rP</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>     lStr <span class="ot">&lt;-</span> toString' lG</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>     rStr <span class="ot">&lt;-</span> toString' rG</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a>     <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> lStr <span class="op">++</span> <span class="st">&quot; :@: &quot;</span> <span class="op">++</span> rStr <span class="op">++</span> <span class="st">&quot;)&quot;</span> </span></code></pre></div>
<p>Now that we have allocated our expression as an <code>ST s (STRef s (Graph s))</code> the next step will be to perform graph reduction on it.</p>
<h2 id="performing-graph-reduction">Performing graph-reduction</h2>
<p>First we have to compute the stack of left ancestors - or <em>spine</em> - of a graph for an efficient reduction.</p>
<p>In the following diagram I have marked the members of this stack with <code>-&gt;</code> arrows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">-&gt;</span>           <span class="op">@</span>                   </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>            <span class="op">/</span> \              </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>           <span class="op">/</span>   \               </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>          <span class="op">/</span>     <span class="op">@</span>          </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>         <span class="op">/</span>     <span class="op">/</span> \          </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         </span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="ot">-&gt;</span>     <span class="op">@</span>     <span class="op">/</span> \     </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>    </span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="ot">-&gt;</span>   <span class="op">@</span>   <span class="dt">I</span>            </span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    <span class="op">/</span> \             </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">S</span>  <span class="dt">MUL</span>   </span></code></pre></div>
<p>The following function <code>spine</code> computes this left ancestors’ stack by traversing all application nodes to the left:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- we simply represent the stack as a list of references to graph nodes</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">=</span> [<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">spine ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">LeftAncestorsStack</span> s)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>spine graph <span class="ot">=</span> spine' graph [] </span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a><span class="ot">    spine' ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">LeftAncestorsStack</span> s)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    spine' graph stack <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>      g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>      <span class="kw">case</span> g <span class="kw">of</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>        (l <span class="op">:@:</span> _r) <span class="ot">-&gt;</span> spine' l (graph <span class="op">:</span> stack)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>        _          <span class="ot">-&gt;</span> <span class="fu">return</span> (graph <span class="op">:</span> stack)</span></code></pre></div>
<p>Using this <code>spine</code> function we can implement a function <code>step</code> that performs a single reduction step on a <code>Graph</code> node:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">step ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>step graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  (top<span class="op">:</span>stack) <span class="ot">&lt;-</span> spine graph</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  node <span class="ot">&lt;-</span> readSTRef top</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="kw">case</span> node <span class="kw">of</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    (<span class="dt">Comb</span> k) <span class="ot">-&gt;</span> reduce k stack</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>    _        <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span></code></pre></div>
<p>If a combinator is found in redex position, <code>reduce</code> is called to perform the actual reduction work according to the combinator specific reduction rules.</p>
<p>Let’s study this for some of the combinators, starting with the most simple one, <code>I x = x</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>        <span class="op">|</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>p  <span class="ot">-&gt;</span>   <span class="op">@</span>   </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>       <span class="op">/</span> \</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">I</span>   x</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">reduce ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>reduce <span class="dt">I</span> (p <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  (_I <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>  xVal <span class="ot">&lt;-</span> readSTRef xP</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>  writeSTRef p xVal</span></code></pre></div>
<p>In this case a reference <code>p</code> to <code>(I :@: xP )</code> is on top of the stack. The actual value of x is read from <code>xP</code> with <code>readSTRef</code> and than <code>p</code> is made to point to this value by using <code>writeSTRef</code>.</p>
<p>The reduction of <code>S f g x = f x (g x)</code> is already a bit more involved:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>            <span class="op">|</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>p3 <span class="ot">-&gt;</span>       <span class="op">@</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>           <span class="op">/</span> \</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>p2 <span class="ot">-&gt;</span>     <span class="op">@</span>   x</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>         <span class="op">/</span> \</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>p1 <span class="ot">-&gt;</span>   <span class="op">@</span>   g</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>       <span class="op">/</span> \</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">S</span>   f</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>reduce <span class="dt">S</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> p3 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  (_S <span class="op">:@:</span> fP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  (_  <span class="op">:@:</span> gP) <span class="ot">&lt;-</span> readSTRef p2</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  (_  <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p3</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>  node1 <span class="ot">&lt;-</span> newSTRef <span class="op">$</span> fP <span class="op">:@:</span> xP</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>  node2 <span class="ot">&lt;-</span> newSTRef <span class="op">$</span> gP <span class="op">:@:</span> xP</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>  writeSTRef p3 (node1 <span class="op">:@:</span> node2)</span></code></pre></div>
<p>In this case reference to f (<code>fP</code>), g (<code>gP</code>) and x (<code>xP</code>) are obtained. Then a new application node is created that represents <code>((f @ x) @ (g @ x))</code>. Then <code>p3</code> is made to point to this new node.</p>
<p>Binary arithmentic combinators like <code>ADD</code> and <code>MUL</code> are implemented as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>reduce <span class="dt">ADD</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> binaryMathOp (<span class="op">+</span>) p1 p2</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>reduce <span class="dt">MUL</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> binaryMathOp (<span class="op">*</span>) p1 p2</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="ot">binaryMathOp ::</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>  (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="co">-- ^ a binary arithmetic function on Integers like (+)</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span>               <span class="co">-- ^ first node on the spine stack</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span>               <span class="co">-- ^ second node on spine stack</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  <span class="dt">ST</span> s ()                            </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>binaryMathOp op p1 p2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  (_ <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a>  (_ <span class="op">:@:</span> yP) <span class="ot">&lt;-</span> readSTRef p2</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>  (<span class="dt">Num</span> xVal) <span class="ot">&lt;-</span> (readSTRef <span class="op">&lt;=&lt;</span> normalForm) xP  <span class="co">-- reduce xP to normal form and obtain its value as xVal</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>  (<span class="dt">Num</span> yVal) <span class="ot">&lt;-</span> (readSTRef <span class="op">&lt;=&lt;</span> normalForm) yP  <span class="co">-- reduce yP to normal form and obtain its value as yVal</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>  writeSTRef p2 (<span class="dt">Num</span> <span class="op">$</span> xVal <span class="ot">`op`</span> yVal)         <span class="co">-- apply op on xVal and yVal, modify p2 to point to the resulting value</span></span></code></pre></div>
<p>The interesting bit here is that the arithmetic combinators are <em>strict</em>, that is they require their arguments to be in normalform. (Please note that <code>S</code>, <code>I</code>, <code>K</code>, etc. don’t have this requirement. They are <em>non-strict</em> or <em>lazy</em>).</p>
<p><code>normalForm</code> just applies <code>step</code> in a loop while the graph has not been reduced to a combinator or an integer:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">normalForm ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>normalForm graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  step graph</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>  g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>  <span class="kw">case</span> g <span class="kw">of</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>    _lP <span class="op">:@:</span> _rP <span class="ot">-&gt;</span> normalForm graph</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>    <span class="dt">Comb</span> _com   <span class="ot">-&gt;</span> <span class="fu">return</span> graph</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>    <span class="dt">Num</span> _n      <span class="ot">-&gt;</span> <span class="fu">return</span> graph</span></code></pre></div>
<p>Using a helper function <code>reduceGraph</code> that computes the normal-form of a graph while staying entirely in the <code>ST</code>-Monad, we can finally reduce our tiny toy graph:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="ot">reduceGraph ::</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>reduceGraph graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  gP <span class="ot">&lt;-</span> graph</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  normalForm gP</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString graph</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a><span class="st">&quot;(((S :@: MUL) :@: I) :@: ((ADD :@: 3) :@: 2))&quot;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString <span class="op">$</span> reduceGraph graph</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a><span class="st">&quot;25&quot;</span></span></code></pre></div>
<h2 id="recursion">Recursion</h2>
<p>λ-calculus does not directly support recursion using self-referential functions <a href="https://sookocheff.com/post/fp/recursive-lambda-functions/">(see this nice exposition)</a>. That’s why we need a fixed-point combinator to realize recursive operation. Here once again the definition of the factorial function that makes use of the <code>Y</code>-Combinator to implement recursive behaviour:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="dt">Y</span>    <span class="ot">=</span> λf <span class="op">.</span> (λx <span class="op">.</span> x x)(λx <span class="op">.</span> f(x x))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>fact <span class="ot">=</span> <span class="dt">Y</span>(\f n <span class="ot">-&gt;</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="op">*</span> n (f (sub1 n))))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>main <span class="ot">=</span> fact <span class="dv">10</span></span></code></pre></div>
<p>With only a few lines of equational reasoning we can demonstrate the special property of the <code>Y</code>-combinator when applied to any function <code>g</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="dt">Y</span> g <span class="ot">=</span> (λf<span class="op">.</span>(λx<span class="op">.</span>x x)(λx<span class="op">.</span>f(x x))) g  <span class="co">-- (1) by definition of Y</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="ot">=</span> (λx<span class="op">.</span>g (x x))(λx<span class="op">.</span>g (x x))    <span class="co">-- (2) by function application of λf</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>    <span class="ot">=</span> g((λx<span class="op">.</span>g (x x))(λx<span class="op">.</span>g (x x))) <span class="co">-- (3) by function application of λx.g(x x) to λx.g(x x)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>    <span class="ot">=</span> g(<span class="dt">Y</span> g)                      <span class="co">-- (4) by equation (2)</span></span></code></pre></div>
<p>Applying equation <code>(4)</code> repeatedly will lead to:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="dt">Y</span> g <span class="ot">=</span> g(g(<span class="dt">Y</span> g))                    <span class="co">-- (5) by equation (4)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="ot">=</span> g(<span class="op">...</span>g(<span class="dt">Y</span> g) <span class="op">...</span>)             <span class="co">-- (6) by repeatedly applying (4)</span></span></code></pre></div>
<p>In this way the <code>Y</code>-combinator achieves recursion by reproducing a (self-reproducing) copy of the function’s self-application with each application of <code>(4)</code>.</p>
<p>This self-reproducing pattern becomes even more visible when looking at the graph-structure of the reduction of <code>(Y g)</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>                                            __</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  <span class="op">@</span>    <span class="op">==&gt;</span>    <span class="op">@</span>     <span class="op">==&gt;</span>   <span class="op">@</span>    <span class="op">==&gt;</span>  <span class="op">...</span>   <span class="op">@</span>   \</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a> <span class="op">/</span> \         <span class="op">/</span> \         <span class="op">/</span> \             <span class="op">/</span> \__<span class="op">/</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a><span class="dt">Y</span>   g       g   <span class="op">@</span>       g   <span class="op">@</span>           g</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>               <span class="op">/</span> \         <span class="op">/</span> \</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>              <span class="dt">Y</span>   g       g   <span class="op">@</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>                             <span class="op">/</span> \</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a>                            <span class="dt">Y</span>   g</span></code></pre></div>
<p>One can see how at each application of <code>(4)</code> another copy of (Y g) is generated and incorporated into the graph as an argument of g.</p>
<p>The last step of the diagram shows that - in the graph - self-reproduction can be achieved by simply bending the argument pointer back to the application node.</p>
<p>This realization leads us to the following implementation of the Y-combinator:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>reduce <span class="dt">Y</span> (p1 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  (_YP <span class="op">:@:</span> gP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  writeSTRef p1 (gP <span class="op">:@:</span> p1)</span></code></pre></div>
<p>Using this implementation of the Y-combinator instead of the source level defined version <code>Y = λf.(λx.x x)(λx.f(x x))</code> reduces the execution time for <code>fact 10000</code> by a factor of about 250.</p>
<p>The <a href="https://github.com/thma/lambda-ski/blob/main/src/LambdaToSKI.hs">sourcecode for this section can be found here</a>.</p>
<h2 id="next-steps">Next steps</h2>
<p>Here are some ideas for possible future extensions and improvements.</p>
<ul>
<li>Extending this very basic setup to a fully working pogramming environment with a REPL</li>
<li>Implement direct and mutual recursion (i.e. <code>letrec</code>) for global function definitions</li>
<li>experimemnt with different bracket abstraction algorithms to improve object code size and execution time.</li>
<li>Implement bracket abstraction from λ-expressions to <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">closed cartesian categories</a> and extend the graph-reduction to also cover the resulting combinators <code>apply</code> and <code>(△)</code>.</li>
<li>extend the language to include lists, maybe even provide it with a LISPKIT frontend.</li>
<li>Add support for implicit and explicit parallelism of the graph-reduction engine. (implicit parallelism for strict operations, and an explicit <code>P</code>-combinator)</li>
</ul>

</main>

<footer>
    Site proudly generated by
    <a href="http://jaspervdj.be/hakyll">Hakyll</a> | 
    Source code is available at 
    <a href="https://github.com/thma/thma.github.io">GitHub</a>
</footer>

</body>
</html>
