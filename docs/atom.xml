<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>LambdaBlog: lambda is not a four letter word</title>
    <link href="https://thma.github.io//atom.xml" rel="self" />
    <link href="https://thma.github.io/" />
    <id>https://thma.github.io//atom.xml</id>
    <author>
        <name>Thomas Mahler</name>
        <email>Thomas.Mahler@ista.com</email>
    </author>
    <updated>2022-02-05T00:00:00Z</updated>
    <entry>
    <title>Evaluating SKI combinators as native Haskell functions</title>
    <link href="https://thma.github.io//posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html" />
    <id>https://thma.github.io//posts/2022-02-05-Evaluating-SKI-combinators-as-native-Haskell-functions.html</id>
    <published>2022-02-05T00:00:00Z</published>
    <updated>2022-02-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on February  5, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/lambda-ski/actions"><img src="https://github.com/thma/lambda-ski/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a> <a href="https://github.com/thma/lambda-ski"><img src="https://thma.github.io/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>In this post I present an alternative approach to combinator-based implementation of functional languages that is significantly faster than classical graph-reduction based solutions.</p>
<p>As this approach makes use of combinator reduction directly implemented as Haskell functions it is also much simpler and smaller in size than explicit graph-reduction.</p>
<h2 id="introduction">Introduction</h2>
<p>In a <a href="https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html">previous post</a> I presented a classical approach to implement a functional language with combinator based graph-reduction in Haskell.</p>
<p>The implementation was structured into three parts:</p>
<ol type="1">
<li><p>A parser for a tiny functional language based on the untyped λ-calculus.</p></li>
<li><p>A small compiler from λ-calculus to a fixed set of combinatory logic combinators (S,K,I,B,C and Y (aka. SICKBY)).</p></li>
<li><p>A graph-reduction engine which implements the combinator rewrite rules as an efficient graph reduction</p></li>
</ol>
<p>The basic idea is as follows:</p>
<p>Take a program like <code>main = (\x y -&gt; x) 3 4</code> and compile it to a variable-free combinator expressions, in this case <code>K 3 4</code>. Then apply the combinator reduction rules like <code>K x y = x</code> until normal-form is reached.</p>
<p>Graph-reduction is used as an efficient implementation technique for these reduction rules. For example the reduction of <code>K</code> is implemented as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">reduce ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">-- K x y = x</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>reduce <span class="dt">K</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  (_K <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  xVal <span class="ot">&lt;-</span> readSTRef xP</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  writeSTRef p2 xVal</span></code></pre></div>
<p>This code transforms the graph by directly writing the value <code>xVal</code>, stored in <code>xP</code> into the root node <code>p2</code>, as depicted below:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>p2<span class="op">:</span>    <span class="op">@</span>   <span class="op">==&gt;</span>  <span class="dv">3</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>      <span class="op">/</span> \</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>p1<span class="op">:</span>  <span class="op">@</span>   <span class="dv">4</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="op">/</span> \</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="dt">K</span>   <span class="dv">3</span></span></code></pre></div>
<p>In this post I’m looking for an alternative backend that can replace the graph-reduction engine.</p>
<h2 id="gaining-a-new-perspective">Gaining a new perspective</h2>
<p>The SICKBY combinators can be defined as ordinary Haskell functions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>i x      <span class="ot">=</span> x         <span class="co">-- i = id</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>k x y    <span class="ot">=</span> x         <span class="co">-- k = const</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>s f g x  <span class="ot">=</span> f x (g x)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>c f g x  <span class="ot">=</span> ((f x) g)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>b f g x  <span class="ot">=</span> (f (g x))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>y        <span class="ot">=</span> fix</span></code></pre></div>
<p>So why don’t we just use the Haskell native implementations of these combinators to reduce our expressions <code>implicitely</code>, rather than building our own graph reduction to <code>explicitly</code> reduce them?</p>
<p>It turns out that Matthew Naylor already wrote about this idea more than a decade ago in <a href="https://wiki.haskell.org/wikiupload/0/0a/TMR-Issue10.pdf">The Monad Reader, issue 10</a> (see also this <a href="https://smunix.github.io/kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html">more recent coverage of the idea</a>).</p>
<p>In the following section I will walk you through the details of this concept.</p>
<h2 id="translating-sickby-expressions">Translating SICKBY expressions</h2>
<p>In order to make use of Haskell functions to implement combinator reduction we’ll first need a data structure that allows to include native functions in addition to the actual terms:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">LambdaToSKI</span> (<span class="dt">Combinator</span> (..), fromString)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="co">-- | a compiled expression may be:</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">CExpr</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">CComb</span> <span class="dt">Combinator</span>       <span class="co">-- a known combinator symbol</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">CApp</span> <span class="dt">CExpr</span> <span class="dt">CExpr</span>       <span class="co">-- an application (f x)</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">CFun</span> (<span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>)  <span class="co">-- a native haskell function of type (CExpr -&gt; CExpr)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">CInt</span> <span class="dt">Integer</span>           <span class="co">-- an integer</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a><span class="co">-- | declaring a show instance for CExpr</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">CExpr</span> <span class="kw">where</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">CComb</span> k)  <span class="ot">=</span> <span class="fu">show</span> k</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">CApp</span> a b) <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="fu">show</span> b <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">CFun</span> _f)  <span class="ot">=</span> <span class="st">&quot;&lt;function&gt;&quot;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">CInt</span> i)   <span class="ot">=</span> <span class="fu">show</span> i</span></code></pre></div>
<p>Translation from SICKBY terms (that is abstracted lambda expresssions) to <code>CExpr</code> is straightforward:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- | translating an abstracted lambda expression into a compiled expression</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">translate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>translate (fun <span class="op">:@</span> arg)   <span class="ot">=</span> <span class="dt">CApp</span> (translate fun) (translate arg)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>translate (<span class="dt">Int</span> k)        <span class="ot">=</span> <span class="dt">CInt</span> k</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>translate (<span class="dt">Var</span> c)        <span class="ot">=</span> <span class="dt">CComb</span> (fromString c)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>translate lam<span class="op">@</span>(<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;lambdas should already be abstracted: &quot;</span> <span class="op">++</span> <span class="fu">show</span> lam</span></code></pre></div>
<ol type="1">
<li>Applications are translated by forming a <code>CApp</code> of the translated function and it’s argument.</li>
<li>Integers are kept as is, just wrapped with a <code>CInt</code> constructor</li>
<li>After performing bracket abstraction any remaining <code>Var</code> must be a combinator. They are thus translated into a fixed combinator symbol; <code>fromString</code> looks up combinator symbols.</li>
<li>After bracket abstraction any remaining <code>Lam</code> expressions would be an error, so we treat it as such.</li>
</ol>
<p>Please note that we do not use the <code>CFun</code> constructor in the translate stage. So right now the result of <code>translate</code> is just an ordinary data structure. Let’s see an example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> testSource <span class="ot">=</span> <span class="st">&quot;main = (\\x y -&gt; x) 3 4&quot;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> env <span class="ot">=</span> parseEnvironment testSource</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>ghci<span class="op">&gt;</span> compile env babs0</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>(((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span>)) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>ghci<span class="op">&gt;</span> cexpr <span class="ot">=</span> translate expr</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>ghci<span class="op">&gt;</span> cexpr</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>((((<span class="dt">S</span> (<span class="dt">K</span> <span class="dt">K</span>)) <span class="dt">I</span>) <span class="dv">3</span>) <span class="dv">4</span>)</span></code></pre></div>
<p>Now it’s time to do the real work. We will have to perform two essential transformations:</p>
<ol type="1">
<li><p>All combinators of the form <code>(CComb comb)</code> have to be replaced by the haskell functions implementing the combinator reduction rule.</p></li>
<li><p>All applications <code>(CApp fun arg)</code> have to be replaced by actual function application. In our case we want apply functions of type <code>CExpr -&gt; CExpr</code> that are wrapped by a <code>CFun</code> constructor. For this particular case we define an application operator <code>(!)</code> as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- | apply a CExpr of shape (CFun f) to argument x by evaluating (f x)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">0</span> <span class="op">!</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ot">(!) ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>(<span class="dt">CFun</span> f) <span class="op">!</span> x <span class="ot">=</span> f x</span></code></pre></div></li>
</ol>
<p>Both tasks are performed by the following <code>link</code> function:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- | a global environment of combinator definitions</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">GlobalEnv</span> <span class="ot">=</span> [(<span class="dt">Combinator</span>,<span class="dt">CExpr</span>)]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">-- | &quot;link&quot; a compiled expression into Haskell native functions.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="co">--   application terms will be transformed into (!) applications</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a><span class="co">--   combinator symbols will be replaced by their actual function definition</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="ot">link ::</span> <span class="dt">GlobalEnv</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>link globals (<span class="dt">CApp</span> fun arg) <span class="ot">=</span> link globals fun <span class="op">!</span> link globals arg</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>link globals (<span class="dt">CComb</span> comb)   <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> comb globals</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>link _globals expr          <span class="ot">=</span> expr</span></code></pre></div>
<p>The global set of combinators is defined as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">primitives ::</span> <span class="dt">GlobalEnv</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>primitives <span class="ot">=</span> <span class="kw">let</span> (<span class="op">--&gt;</span>) <span class="ot">=</span> (,) <span class="kw">in</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  [ <span class="dt">I</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> <span class="fu">id</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  , <span class="dt">K</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (<span class="dt">CFun</span> <span class="op">.</span> <span class="fu">const</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  , <span class="dt">S</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>x<span class="op">!</span>(g<span class="op">!</span>x))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  , <span class="dt">B</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>(g<span class="op">!</span>x))</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  , <span class="dt">C</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\f <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \x <span class="ot">-&gt;</span> f<span class="op">!</span>x<span class="op">!</span>g)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  , <span class="dt">IF</span>     <span class="op">--&gt;</span> <span class="dt">CFun</span> (\(<span class="dt">CInt</span> cond) <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \thenExp <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \elseExp <span class="ot">-&gt;</span> </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>                                        <span class="kw">if</span> cond <span class="op">==</span> <span class="dv">1</span> <span class="kw">then</span> thenExp <span class="kw">else</span> elseExp)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>  , <span class="dt">Y</span>      <span class="op">--&gt;</span> <span class="dt">CFun</span> (\(<span class="dt">CFun</span> f) <span class="ot">-&gt;</span> fix f)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>  , <span class="dt">ADD</span>    <span class="op">--&gt;</span> arith (<span class="op">+</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  , <span class="dt">SUB</span>    <span class="op">--&gt;</span> arith (<span class="op">-</span>)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  , <span class="dt">SUB1</span>   <span class="op">--&gt;</span> <span class="dt">CFun</span> sub1</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  , <span class="dt">MUL</span>    <span class="op">--&gt;</span> arith (<span class="op">*</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  , <span class="dt">EQL</span>    <span class="op">--&gt;</span> arith eql</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  , <span class="dt">GEQ</span>    <span class="op">--&gt;</span> arith geq</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  , <span class="dt">ZEROP</span>  <span class="op">--&gt;</span> <span class="dt">CFun</span> isZero</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true"></a>  ]</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true"></a><span class="ot">arith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true"></a>arith op <span class="ot">=</span> <span class="dt">CFun</span> <span class="op">$</span> \(<span class="dt">CInt</span> a) <span class="ot">-&gt;</span> <span class="dt">CFun</span> <span class="op">$</span> \(<span class="dt">CInt</span> b) <span class="ot">-&gt;</span> <span class="dt">CInt</span> (op a b)</span></code></pre></div>
<p>As you can see, the combinators are implemented as <code>CFun</code> wrapped functions. So they bear some minor overhead for pattern matching the <code>CFun</code> constructor when using the <code>(!)</code> operator. But apart from that, they are ordinary Haskell functions.</p>
<p>Trying out <code>link</code> in GHCi looks like follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> link primitives cexpr</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="dv">3</span></span></code></pre></div>
<p>So our initial expression <code>main = (\\x y -&gt; x) 3 4</code> got translated into a haskell function applied to it’s two arguments. As the function is fully saturated, the ghci implicit <code>show</code> request triggers its evaluation and we see the correct result <code>3</code> returned.</p>
<h2 id="we-can-still-do-better">We can still do better</h2>
<p>I took the idea of having two passes, <code>translate</code> and <code>link</code> to transform the input SICKBY expressions verbatim from Matthew Naylor’s paper. I think it’s easier to explain the overall idea when breaking it down into these two separate steps. But it’s perfectly possible do the transformation in one pass:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="co">-- | translate and link in one go</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="co">--   application terms will directly be transformed into (!) applications</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a><span class="co">--   combinator symbols will be replaced by their actual function definition</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a><span class="ot">transLink ::</span> <span class="dt">GlobalEnv</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>transLink globals (fun <span class="op">:@</span> arg)  <span class="ot">=</span> transLink globals fun <span class="op">!</span> transLink globals arg</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>transLink _globals (<span class="dt">Int</span> k)      <span class="ot">=</span> <span class="dt">CInt</span> k</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>transLink globals (<span class="dt">Var</span> c)       <span class="ot">=</span> fromJust <span class="op">$</span> <span class="fu">lookup</span> (fromString c) globals</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>transLink _globals l<span class="op">@</span>(<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;lambdas should be abstracted already &quot;</span> <span class="op">++</span> <span class="fu">show</span> l</span></code></pre></div>
<p>In this case the <code>CExpr</code> type becomes even simpler, as no intermediate constructors are required for applications and combinators:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- | a compiled expression</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">CExpr</span> <span class="ot">=</span> </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="dt">CFun</span> (<span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">CInt</span> <span class="dt">Integer</span></span></code></pre></div>
<h2 id="the-good-new-and-the-good-news">The good new and the good news</h2>
<p>If you studied <a href="(https://thma.github.io/posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html)">my post on the roll your own graph-reduction idea</a> you will be amazed how much simpler the current approach is.</p>
<p>But it is also tremendously faster!</p>
<p>I’ve assembled a set of <a href="https://github.com/thma/lambda-ski/blob/main/benchmark/ReductionBenchmarks.hs">criterion micro-benchmarks for some typical recursive functions</a> on integers.</p>
<p>The table below compares the mean execution times for reducing the same program with GraphReduction and with the “combinators as native functions”. the third column gives the ratio between both execution times:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">SICKBY GraphReduction [μs]</th>
<th style="text-align: right;">SICKBY as functions [μs] | ratio|</th>
<th style="text-align: right;">ratio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/factorial.ths">factorial</a></td>
<td style="text-align: right;">1273</td>
<td style="text-align: right;">24.92</td>
<td style="text-align: right;">51</td>
</tr>
<tr class="even">
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/fibonacci.ths">fibonacci</a></td>
<td style="text-align: right;">484</td>
<td style="text-align: right;">50.70</td>
<td style="text-align: right;">10</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/ackermann.ths">ackermann</a></td>
<td style="text-align: right;">386</td>
<td style="text-align: right;">16,88</td>
<td style="text-align: right;">23</td>
</tr>
<tr class="even">
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/gaussian.ths">gaussian sum</a></td>
<td style="text-align: right;">1414</td>
<td style="text-align: right;">16,18</td>
<td style="text-align: right;">87</td>
</tr>
<tr class="odd">
<td><a href="https://github.com/thma/lambda-ski/blob/main/test/tak.ths">tak</a></td>
<td style="text-align: right;">3204</td>
<td style="text-align: right;">75,69</td>
<td style="text-align: right;">42</td>
</tr>
</tbody>
</table>
<p>For the fibonacci function the “combinators as native functions” approach is ten times faster, for the gaussian sum almost 90 times.</p>
<h2 id="room-for-further-improvements">Room for further improvements</h2>
<p>It’s interesting to see how the “combinators as native functions” execution performs in comparison to actual Haskell implementations of our five test functions. The Haskell native implementations can be found in the <a href="https://github.com/thma/lambda-ski/blob/main/benchmark/ReductionBenchmarks.hs">benchmark definition</a>.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: right;">SICKBY as functions [μs]</th>
<th style="text-align: right;">Haskell native [μs] | rat</th>
<th style="text-align: right;">ratio</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>factorial</td>
<td style="text-align: right;">24.92</td>
<td style="text-align: right;">4.743</td>
<td style="text-align: right;">5</td>
</tr>
<tr class="even">
<td>fibonacci</td>
<td style="text-align: right;">50.70</td>
<td style="text-align: right;">2.824</td>
<td style="text-align: right;">18</td>
</tr>
<tr class="odd">
<td>ackermann</td>
<td style="text-align: right;">16,88</td>
<td style="text-align: right;">0.497</td>
<td style="text-align: right;">34</td>
</tr>
<tr class="even">
<td>gaussian sum</td>
<td style="text-align: right;">16,18</td>
<td style="text-align: right;">1.302</td>
<td style="text-align: right;">12</td>
</tr>
<tr class="odd">
<td>tak</td>
<td style="text-align: right;">75,69</td>
<td style="text-align: right;">0.084</td>
<td style="text-align: right;">903</td>
</tr>
</tbody>
</table>
<p>For simple unary function like <code>factorial</code> and <code>gaussian sum</code> the native implementation is only 5 to 12 times faster. That’s not bad for such a simple approach!</p>
<p>But for more complex functions like <code>fibonacci</code> and in particular for binary or ternary functions like <code>ackermann</code> and <code>tak</code> the performance is not that good.</p>
<p>This is caused by the inefficient “code generation” of the classic bracket abstraction: <a href="https://tromp.github.io/cl/LC.pdf">The output size grows quadratic</a> with internal complexity and number of variables. As each additional combinator or application will require additional execution time it’s easy to see why a quadratic growth in combinator code size will drastically decrease performance. There have been many attempts to optimize bracket abstraction by <a href="https://www.cantab.net/users/antoni.diller/brackets/intro.html">introducing additional combinators</a> and by <a href="https://tromp.github.io/cl/LC.pdf">applying additional optimization rules</a>.</p>
<p>I leave it as an exercise to the interested reader to improve the bracket abstraction rules applied here in order to sigificantly speed up both the graph-reduction as the “combinators as native functions” implementations.</p>
]]></summary>
</entry>
<entry>
    <title>Writing a Wiki Server with Yesod</title>
    <link href="https://thma.github.io//posts/2022-01-09-Writing-a-Wiki-Server-with-Yesod.html" />
    <id>https://thma.github.io//posts/2022-01-09-Writing-a-Wiki-Server-with-Yesod.html</id>
    <published>2022-01-09T00:00:00Z</published>
    <updated>2022-01-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on January  9, 2022
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<a href="https://github.com/thma/HsWiki/actions"><img src="https://github.com/thma/HsWiki/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a> <a href="https://github.com/thma/HsWiki"><img src="https://thma.github.io/img/forkme.png" height="20"></a>
</p>
<h2 id="abstract">Abstract</h2>
<p>In this blog post I’m presenting an implementation of a Wiki System in the spirit of the legendary <a href="http://wiki.c2.com/">C2-Wiki</a> - written in Haskell with the <a href="https://www.yesodweb.com/">Yesod</a> framework.</p>
<p>There will also be some nice add-ons like a graphical representation of the page links.</p>
<h2 id="introduction">Introduction</h2>
<blockquote>
<p>The WikiWikiWeb is the first wiki, or user-editable website. It was launched on 25 March 1995 by its inventor, programmer Ward Cunningham, to accompany the Portland Pattern Repository website discussing software design patterns.</p>
<p><a href="https://en.wikipedia.org/wiki/WikiWikiWeb">cited from Wikipedia</a></p>
</blockquote>
<p>The <a href="http://wiki.c2.com/">WikiWikiWeb</a> was the earliest incarnation of a collaborative hypertext platform on the internet. It started with a small set of features which proved to provide the essential tools required to create a large content base with a dense hyperlink structure. Editing and creating new pages was extremely simple which fostered free contributions and a high frequency of interactions between participants.</p>
<p>The most prominent features are:</p>
<ul>
<li>A tiny markup language allows basic adjustments of typography and layout.</li>
<li>All content is rendered as HTML and thus allow easy navigation with any web browser.</li>
<li>An inplace editor allows adhoc creation and editing of pages. On saving edited content, the page switches back to display mode, which renders the markup as HTML.</li>
<li>WikiWords, that is Text in PascalCase or <a href="https://en.wikipedia.org/wiki/Camel_case">Upper Camel Case</a> are interpreted as hyperlinks. If such a hyperlink does not link to an existing page, the editor is opened for creating a new page. This mechanism allows to create hyperlinked content in a very fast manner.</li>
<li>Clicking on a Page Title will display a list of all references to the current page. This allows to identify related topics and also to organize semantic networks by creating category pages that just keep links to all pages in the category <a href="http://wiki.c2.com/?CategoryCategory">CategoryCategory</a></li>
<li>The RecentChanges page shows the latest creation and edits to pages and thus makes it easy to identify hot topics</li>
<li>There is a full text search available.</li>
</ul>
<p>In the following I’m going to explain how I implemented each of those features.</p>
<h2 id="a-simple-markup-language-just-use-markdown">A simple markup language: Just use Markdown</h2>
<p>The original WikiWikiWeb markup language provided basic syntax for layouting text content. Modern markup languages like Markdown are a more convenient to use, provide much more features and are already widely used. So I’m going to use Markdown instead of the original markup language.</p>
<h2 id="rendering-content-as-html">Rendering content as HTML</h2>
<p>Yesod comes with a set of <a href="https://www.yesodweb.com/book/shakespearean-templates">templating mechanisms</a> that ease the generation of HTML, CSS and Javascript for dynamic web content. The HTML templating is backed by the <a href="https://hackage.haskell.org/package/blaze-html">Blaze Html generator</a>. Thus Yesod is optimized to use <a href="https://hackage.haskell.org/package/blaze-html">Blaze</a> for HTML content. If, for example, the Blaze <code>Html</code> data type is returned from route-handlers, Yesod will automatically set the Content-Type to <code>text/html</code>.</p>
<p>So my basic idea is to use a Markdown renderer that can output Blaze <code>Html</code>-data and let Yesod do all the heavy lifting.</p>
<p>I’m using the <a href="https://hackage.haskell.org/package/cmark-gfm">cmark-gfm</a> library to render (GitHub flavoured) Markdown content to HTML. In order to output <code>Html</code>-data, my <code>renderMdToHtml</code> function has to look like follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">CMarkGFM</span>        (commonmarkToHtml)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Data.Text</span>       (<span class="dt">Text</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Text.Blaze.Html</span> (<span class="dt">Html</span>, preEscapedToHtml)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="ot">renderMdToHtml ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>renderMdToHtml <span class="ot">=</span> preEscapedToHtml <span class="op">.</span> commonmarkToHtml [] []</span></code></pre></div>
<h2 id="inplace-content-editing">Inplace Content Editing</h2>
<h3 id="type-safe-page-names">Type safe page names</h3>
<p>In order to work with the wiki page names in a type safe manner we first introduce a newtype <code>PageName</code>. In order to make sure that only proper <a href="https://en.wikipedia.org/w/index.php?title=WikiWord">WikiWords</a> can be used as page names I’m using a <a href="https://wiki.haskell.org/Smart_constructors">smart constructor</a> <code>pageName</code> which only constructs a <code>PageName</code>instance if the intented page name matches the <code>wikiWordMatch</code> regular expression:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">PageName</span> <span class="ot">=</span> <span class="dt">Page</span> <span class="dt">Text</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">pageName ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">PageName</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>pageName name <span class="ot">=</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="kw">if</span> isWikiWord name</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Page</span> name)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>    <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="co">-- | checks if a given Text is a WikiWord</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a><span class="ot">isWikiWord ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>isWikiWord pageName <span class="ot">=</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  <span class="kw">case</span> find wikiWordMatch pageName <span class="kw">of</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a><span class="co">-- | the magic WikiWord Regex</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a><span class="ot">wikiWordMatch ::</span> <span class="dt">Regex</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>wikiWordMatch <span class="ot">=</span> <span class="st">&quot;([A-Z][a-z0-9]+){2,}&quot;</span>    </span></code></pre></div>
<h3 id="the-yesod-routes-for-the-editor">The Yesod routes for the editor</h3>
<p>The following <code>PathPiece</code> instance declaration is required to use the <code>PageName</code> as part of a Yesod route definition:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">PathPiece</span> <span class="dt">PageName</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  toPathPiece page   <span class="ot">=</span> asText page</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  fromPathPiece text <span class="ot">=</span> pageName text</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="ot">asText ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>asText (<span class="dt">Page</span> name) <span class="ot">=</span> name</span></code></pre></div>
<p>Again the usage of the <code>pageName</code> smart constructor ensures that only proper WikiWord pagenames are constructed.</p>
<p>Here comes the <a href="https://www.yesodweb.com/book/basics#basics_routing">Yesod route definition</a> for displaying and editing of wiki pages:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">HsWiki</span> <span class="ot">=</span> <span class="dt">HsWiki</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  {<span class="ot"> contentDir ::</span> <span class="dt">String</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  }</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>/#PageName      PageR     GET             -- (1)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>/edit/#PageName EditR     GET POST        -- (2)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>|]</span></code></pre></div>
<p>Definition (1) can be read as follows: for any <code>PageName</code> that is accessed via a HTTP GET a route PageR is defined, which (according to the rules of the Yesod routing DSL) requires us to implement a function with the following signature:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span></code></pre></div>
<p>This function will have to lookup an existing page, render its Markdown content to Html and return it a <code>Handler Html</code> object. We’ll have a look at this function shortly.</p>
<p>The definition (2) states that for any route /edit/<code>PageName</code> two functions must be defined, one for GET one for POST:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">getEditR  ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span></code></pre></div>
<p>If you want to know how exactly handler function are invoked from the Yesod framework and how the route dispatching works, please have a look at the excellent <a href="https://www.yesodweb.com/book/">Yesod documentation</a> which features a complete walkthrough with a HelloWorld application.</p>
<h3 id="serving-an-editor">Serving an editor</h3>
<p>Now let’s study the implementation of these two function step by step, first the GET handler:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- | handler for GET /edit/#PageName</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">getEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>getEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root </span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName  <span class="co">-- check whether file already exists</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  markdown <span class="ot">&lt;-</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>    <span class="kw">if</span> exists</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>      <span class="kw">then</span> liftIO <span class="op">$</span> TIO.readFile fileName    <span class="co">-- if file exists, assign markdown with file content</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>      <span class="kw">else</span> <span class="fu">return</span> newPage                    <span class="co">-- else assign markdown with default content</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> buildEditorFor pageName markdown  <span class="co">-- return Html for an Editor page</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a><span class="co">-- | retrieve the name of the HsWiki {contentDir} attribute, defaults to &#39;content&#39;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="ot">getDocumentRoot ::</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>getDocumentRoot <span class="ot">=</span> getsYesod contentDir  </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a><span class="co">-- | construct the proper file name for a PageName</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a><span class="ot">fileNameFor ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span>  <span class="ot">-&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>fileNameFor path pageName <span class="ot">=</span> path <span class="op">++</span> <span class="st">&quot;/&quot;</span> <span class="op">++</span> asString pageName <span class="op">++</span> <span class="st">&quot;.md&quot;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true"></a><span class="co">-- | create default content for a new page</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true"></a><span class="ot">newPage ::</span> <span class="dt">Text</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true"></a>newPage <span class="ot">=</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true"></a>     <span class="st">&quot;Use WikiWords in PascalCase for Links. \n\n&quot;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true"></a>  <span class="op">&lt;&gt;</span> <span class="st">&quot;Use [Markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) to format page content&quot;</span></span></code></pre></div>
<p>As we can see from the reading of markdown content from files, the idea is to just keep all pages as static content files in the filesystem. By default these files reside in the local folder <em>content</em> (this folder can be configured by a commandline argument).</p>
<p>Next we’ll have a look at the <code>buildEditorFor</code> function that will generate the actual Html content of the editor page:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">buildEditorFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>buildEditorFor pageName markdown <span class="ot">=</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  toHtml</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    [ pageHeader <span class="dt">False</span>,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>      menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>      renderMdToHtml <span class="op">$</span> <span class="st">&quot;# &quot;</span> <span class="op">&lt;&gt;</span> page <span class="op">&lt;&gt;</span> <span class="st">&quot; \n&quot;</span>,</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>      preEscapedToHtml <span class="op">$</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>        <span class="st">&quot;&lt;form action=\&quot;&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> page</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;\&quot; method=\&quot;POST\&quot;&gt;&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;textarea style=\&quot;height: auto;\&quot; name=\&quot;content\&quot; cols=\&quot;120\&quot; rows=\&quot;25\&quot;&gt;&quot;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> markdown</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;/textarea&gt;&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;input type=\&quot;submit\&quot; name=\&quot;save\&quot; value=\&quot;save\&quot; /&gt; &amp;nbsp; &quot;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;input class=\&quot;button button-outline\&quot; type=\&quot;button\&quot; name=\&quot;cancel\&quot; value=\&quot;cancel\&quot; onClick=\&quot;window.history.back()\&quot; /&gt; &quot;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a>          <span class="op">&lt;&gt;</span> <span class="st">&quot;&lt;/form&gt;&quot;</span>,</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a>      pageFooter</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>    ]</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a>  <span class="kw">where</span> page <span class="ot">=</span> asText pageName</span></code></pre></div>
<p>The most important element here is the creation of an Html <code>&lt;form ...&gt;...&lt;/form&gt; element. The action for that form is just the same page but with a</code>POST<code>-method (we'll come to the respective handler function</code>postEditR` shortly).</p>
<p>Now imagine we point our browser to <code>http://localhost:3000/edit/BrandNewPage</code>. Yesod will do the routing to <code>getEditR (Page "BrandNewPage")</code> and the generated Html for editing a new page ‘BrandNewPage’ will be sent back to the browser. The page will look like this:</p>
<figure>
<img src="../img/editor.png" alt="" /><figcaption>The Editor for a new page</figcaption>
</figure>
<p>As we can see, I’ve applied some basic CSS styling <a href="https://milligram.io/">(using Milligram CSS)</a>. This is done in the <code>pageHeader</code> function.</p>
<h3 id="processing-the-posting-of-data">processing the posting of data</h3>
<p>The editor has two buttons, <em>SAVE</em> and <em>CANCEL</em>. On cancel we just navigate back to the previous page in the browser history. On save the browser sends the form data via the <code>POST</code> method to the server. To handle this incoming POST-request we’ll the <code>postEditR</code> handler function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>postEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>  maybeContent <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;content&quot;</span>  <span class="co">-- retrieve POST data</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  client <span class="ot">&lt;-</span> remoteHost <span class="op">&lt;$&gt;</span> waiRequest        <span class="co">-- retrieve info on remote client from request</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  <span class="kw">case</span> maybeContent <span class="kw">of</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>    <span class="dt">Just</span> content <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>      TIO.writeFile fileName content         <span class="co">-- if content exists write it to disk</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>      writeLogEntry path pageName client     <span class="co">-- also write a log entry to file RecentChanges</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()                     <span class="co">-- no content: do nothing</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  redirect <span class="op">$</span> <span class="dt">PageR</span> pageName                  <span class="co">-- redirect to GET Page route (display content)</span></span></code></pre></div>
<p>So essentially we are just writing the markdown content into a file. After that we redirect to the <code>PageR</code> route. This will result in redirecting the browser to <code>http://localhost:3000/BrandNewPage</code>. As you can see in the following screen-shot the markdown content that was entered in the editor form is now rendered as HTML:</p>
<figure>
<img src="../img/renderPage.png" alt="" /><figcaption>render an existing page</figcaption>
</figure>
<h3 id="rendering-page-content">rendering page content</h3>
<p>As promised above we’ll now have a closer look at the <code>getPageR</code> route handler function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="co">-- | Handler for GET /#PageName</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>getPageR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                            <span class="co">-- obtain path to document root </span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>  maybeShowRefs <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;showBackrefs&quot;</span>     <span class="co">-- check whether URL ends with &#39;?showBackrefs&#39;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>  maybeBackrefs <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                          <span class="co">-- if showBackrefs was set, Just [PageName] </span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>    computeMaybeBackrefs path pageName maybeShowRefs <span class="co">-- else Nothing</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName           <span class="co">-- compute proper filename from pageName</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName          <span class="co">-- check whether such a file exists</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true"></a>  <span class="kw">if</span> exists</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true"></a>    <span class="kw">then</span> <span class="kw">do</span>                                                                  </span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true"></a>      content <span class="ot">&lt;-</span> liftIO <span class="op">$</span> TIO.readFile fileName      <span class="co">-- file exists, read its content</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true"></a>      <span class="fu">return</span> <span class="op">$</span> buildViewFor </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true"></a>        pageName content maybeBackrefs               <span class="co">-- build HTML for content and return it</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true"></a>      redirect <span class="op">$</span> <span class="dt">EditR</span> pageName                      <span class="co">-- file does not exist, redirect to EditR</span></span></code></pre></div>
<p>Let’s ignore the lines with <code>maybeShowRefs</code> and <code>maybeBackrefs</code> for a moment. We just assume that <code>maybeBackrefs == Nothing</code>. So we first check whether a file exists for the given <code>pageName</code>. If yes, the file-content is read and bound to <code>content</code>; next we build a HTML view for the page with <code>buildViewFor</code> and return it. If no file was found matching <code>pageName</code> we redirect directly to the <code>EditR</code>which will in turn open up an editor for an empty page as already shown in the previous section.</p>
<p>Let’s have a closer look at <code>buildViewFor</code>. It will first evaluate the <code>maybeBackrefs</code> arguments. For the moment let’s assume equals <code>Nothing</code>, so that <code>hasBackref</code> is bound to <code>True</code> and <code>backrefEntry</code> to <code>""</code>.</p>
<p>Then the actual HTML for the page is constructed from a set of template functions: - <code>pageHeader</code> creates the HTML head with css definitions, - <code>menuBar</code> creates the menu line on top of the page, - <code>pageTitle</code> creates a headline from the <code>pageName</code>, - <code>backrefEntry</code> is just empty text in this scenario - <code>renderMdToHtml (wikiWordToMdLink content)</code> first replaces all ocurrences of <em>WikiWords</em> with proper Markdown hyperlinks of the form <code>[WikiWord](WikiWord)</code> the result is then rendered to HTML (this is the single place where we convert from <em>WikiWords</em> to hyperlinks and thus make the Wiki magic happen…), - finally <code>pageFooter</code> closes all open html tags:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">buildViewFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>buildViewFor pageName content maybeBackrefs <span class="ot">=</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="kw">let</span> (hasBackref, backrefEntry) <span class="ot">=</span> <span class="kw">case</span> maybeBackrefs <span class="kw">of</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>        <span class="dt">Nothing</span>       <span class="ot">-&gt;</span> (<span class="dt">False</span>, text <span class="st">&quot;&quot;</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>        <span class="dt">Just</span> backrefs <span class="ot">-&gt;</span> (<span class="dt">True</span>, renderedBackrefs)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>          <span class="kw">where</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="ot">            concatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>            <span class="fu">concatMap</span> <span class="ot">=</span> (T.intercalate <span class="st">&quot;&quot;</span> <span class="op">.</span>) <span class="op">.</span> <span class="fu">map</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>            renderedBackrefs <span class="ot">=</span> renderMdToHtml <span class="op">$</span> <span class="fu">concatMap</span> ((\b <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;](/&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;) \n&quot;</span>) <span class="op">.</span> asText) backrefs</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>   <span class="kw">in</span> toHtml [pageHeader <span class="dt">False</span>, </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>              menuBar (asText pageName), </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>              pageTitle pageName hasBackref, </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>              backrefEntry, </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>              renderMdToHtml (wikiWordToMdLink content), </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>              pageFooter]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true"></a><span class="co">-- | converts a WikiWord into a Markdown link: [WikiWord](WikiWord)</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true"></a><span class="ot">wikiWordToMdLink ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true"></a>wikiWordToMdLink text <span class="ot">=</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true"></a>  <span class="kw">let</span> match <span class="ot">=</span> wikiWordMatch</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true"></a>      replace <span class="ot">=</span> <span class="st">&quot;[$0]($0)&quot;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true"></a>   <span class="kw">in</span> replaceAll match replace text              </span></code></pre></div>
<h2 id="displaying-back-links-aka-reverse-index-for-each-page">Displaying back links (aka reverse index) for each page</h2>
<p>Another important feature of the original WikiWiki was the seamless integration of back links:</p>
<blockquote>
<p>If page A links to page B, then a ‘back link’ would be a link which goes from page B back to page A.</p>
<p>On this wiki, the title of each page works as a back link. Clicking on the title of any page finds all the pages referring to that page. It works for any wiki page. E.g. to find all pages that link to this page, click the title at the top of this page.</p>
<p><a href="http://wiki.c2.com/?BackLink">quoted from the WikiWiki</a></p>
</blockquote>
<p>This feature can best be demonstrated with an example. First we lookup up page <code>http://localhost:3000/CategoryMammal</code>, a page meant to represent the class of all mammaĺ animals:</p>
<figure>
<img src="../img/CategoryMammal.png" alt="" /><figcaption>normal view of a category page</figcaption>
</figure>
<p>The headline of this page is a hyperlink which references <code>http://localhost:3000/CategoryMammal?showBackrefs</code>. Following the link results in the following page:</p>
<figure>
<img src="../img/CategoryMammalWithBackLinks.png" alt="" /><figcaption>the category page with the listing of back references</figcaption>
</figure>
<p>Now we see a bullet point list of all pages linking to <em>CategoryMammal</em> above the normal page content. Following one of these links, e.g. <code>http://localhost:3000/SpeciesCat</code>, leads to the following page:</p>
<figure>
<img src="../img/SpeciesCat.png" alt="" /><figcaption>a wiki page referencing to the category page</figcaption>
</figure>
<p>At the bottom of this page we see the <em>WikiWord</em> CategoryMammal. This is interpreted as a link from <em>SpeciesCat</em> to <em>CategoryMammal</em>. And as a result the back-link display on page <em>CategoryMammal</em> contains a link to <em>SpeciesCat</em>.</p>
<p>Let’s see how this works on the code level. In fact we already came across this mechanism but had skipped over it for the time being. Now it’s time to revisit. We start with the <code>getPageR</code> function.</p>
<p>In our scenario a click on the link <code>http://localhost:3000/CategoryMammal?showBackrefs</code> leads to a call to <code>getPageR</code>. But this time <code>lookupGetParam "showBackrefs"</code> will succeed and thus now <code>maybeShowRefs</code> is bound to <code>Just ""</code>. This will lead to a different execution path in the call to <code>computeMaybeBackrefs</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- | Handler for GET /#PageName</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">getPageR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>getPageR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                            <span class="co">-- obtain path to document root </span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  maybeShowRefs <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;showBackrefs&quot;</span>     <span class="co">-- check whether URL ends with &#39;?showBackrefs&#39;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>  maybeBackrefs <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                          <span class="co">-- if showBackrefs was set, Just [PageName] </span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>    computeMaybeBackrefs path pageName maybeShowRefs <span class="co">-- else Nothing</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName           <span class="co">-- compute proper filename from pageName</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>  exists <span class="ot">&lt;-</span> liftIO <span class="op">$</span> doesFileExist fileName          <span class="co">-- check whether such a file exists</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true"></a>  <span class="kw">if</span> exists</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true"></a>    <span class="kw">then</span> <span class="kw">do</span>                                                                  </span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true"></a>      content <span class="ot">&lt;-</span> liftIO <span class="op">$</span> TIO.readFile fileName      <span class="co">-- file exists, read its content</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true"></a>      <span class="fu">return</span> <span class="op">$</span> buildViewFor </span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true"></a>        pageName content maybeBackrefs               <span class="co">-- build HTML for content and return it</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true"></a>      redirect <span class="op">$</span> <span class="dt">EditR</span> pageName                      <span class="co">-- file does not exist, redirect to EditR</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true"></a><span class="co">-- | if maybeShowRefs isJust then a list of a pages referencing pageName is computed</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true"></a><span class="ot">computeMaybeBackrefs ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">PageName</span>])</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true"></a>computeMaybeBackrefs path pageName maybeShowRefs <span class="ot">=</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true"></a>  <span class="kw">case</span> maybeShowRefs <span class="kw">of</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span>                      <span class="co">-- if maybeShowRefs == Nothing, return Nothing</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true"></a>    <span class="dt">Just</span> _  <span class="ot">-&gt;</span> <span class="kw">do</span>                                  <span class="co">-- else compute list of all references to page by</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true"></a>      allPages <span class="ot">&lt;-</span> computeIndex path                <span class="co">-- computing list of all pages in wiki</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true"></a>      backrefs <span class="ot">&lt;-</span> computeBackRefs path pageName allPages <span class="co">-- compute all back references</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true"></a>      <span class="fu">return</span> <span class="op">$</span> <span class="dt">Just</span> backrefs                       <span class="co">-- return this list wrapped as a Maybe</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true"></a></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true"></a></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true"></a><span class="co">-- | compute a list of all pages that contain references to pageName</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true"></a><span class="ot">computeBackRefs ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">PageName</span>]</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true"></a>computeBackRefs path pageName allPages <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true"></a>  <span class="kw">let</span> filteredPages <span class="ot">=</span> delete pageName allPages   <span class="co">-- filter pagename from list of pages</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true"></a>  markRefs <span class="ot">&lt;-</span> <span class="fu">mapM</span>                               <span class="co">-- create a list of bools: True if a page contains</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true"></a>    (<span class="fu">fmap</span> containsBackref <span class="op">.</span> TIO.readFile <span class="op">.</span> fileNameFor path)             <span class="co">-- a reference, else False</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true"></a>    filteredPages</span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true"></a>  <span class="kw">let</span> pageBoolPairs <span class="ot">=</span> <span class="fu">zip</span> filteredPages markRefs <span class="co">-- create a zipped list of (pageName, Bool) pairs</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">map</span> <span class="fu">fst</span> (<span class="fu">filter</span> <span class="fu">snd</span> pageBoolPairs)    <span class="co">-- return only pages marked True</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true"></a>    containsBackref content <span class="ot">=</span>                    <span class="co">-- returns True if content contains pageName</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true"></a>      asText pageName <span class="ot">`T.isInfixOf`</span> content</span></code></pre></div>
<p>Next we revisit <code>buildViewFor</code>. Here we see a case match on <code>maybeBackrefs</code>. In our current scenario it will match to <code>Just backrefs</code>. Thus <code>renderedBackrefs</code> will be bound to Html generated by rendering a Markdown list of hyperlinks that is constructed from the <code>backrefs</code> list of PageNames.</p>
<p>This generated Html is then included as <code>backrefEntry</code> into the overall page layout:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">buildViewFor ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>buildViewFor pageName content maybeBackrefs <span class="ot">=</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="kw">let</span> (hasBackref, backrefEntry) <span class="ot">=</span> <span class="kw">case</span> maybeBackrefs <span class="kw">of</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>        <span class="dt">Nothing</span>       <span class="ot">-&gt;</span> (<span class="dt">False</span>, text <span class="st">&quot;&quot;</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>        <span class="dt">Just</span> backrefs <span class="ot">-&gt;</span> (<span class="dt">True</span>, renderedBackrefs)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>          <span class="kw">where</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a><span class="ot">            concatMap ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Text</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>            <span class="fu">concatMap</span> <span class="ot">=</span> (T.intercalate <span class="st">&quot;&quot;</span> <span class="op">.</span>) <span class="op">.</span> <span class="fu">map</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>            renderedBackrefs <span class="ot">=</span> </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a>              renderMdToHtml <span class="op">$</span> <span class="fu">concatMap</span> </span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>                  ((\b <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;](/&quot;</span> <span class="op">&lt;&gt;</span> b <span class="op">&lt;&gt;</span> <span class="st">&quot;) \n&quot;</span>) <span class="op">.</span> asText) </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>                  backrefs</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>   <span class="kw">in</span> toHtml [pageHeader <span class="dt">False</span>, </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a>              menuBar (asText pageName), </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a>              pageTitle pageName hasBackref, </span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a>              backrefEntry, </span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a>              renderMdToHtml (wikiWordToMdLink content), </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true"></a>              pageFooter]        </span></code></pre></div>
<h2 id="show-the-latest-creation-and-edits-to-pages">Show the latest creation and edits to pages</h2>
<p>I already covered the <code>postEditR</code> function, but I did not explain the <code>writeLogEntry</code> function which traces each change to page-content. So here comes the full picture:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">postEditR ::</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>postEditR pageName <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                    <span class="co">-- obtain path to document root</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path pageName   <span class="co">-- construct a file from the page name</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  maybeContent <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;content&quot;</span>  <span class="co">-- retrieve POST data</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>  client <span class="ot">&lt;-</span> remoteHost <span class="op">&lt;$&gt;</span> waiRequest        <span class="co">-- retrieve info on remote client from request</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a>  <span class="kw">case</span> maybeContent <span class="kw">of</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>    <span class="dt">Just</span> content <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a>      TIO.writeFile fileName content         <span class="co">-- if content exists write it to disk</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a>      writeLogEntry path pageName client     <span class="co">-- also write a log entry to file RecentChanges</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()                     <span class="co">-- no content: do nothing</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a>  redirect <span class="op">$</span> <span class="dt">PageR</span> pageName                  <span class="co">-- redirect to GET Page route (display content)</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>  </span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a><span class="co">-- | write a log entry to the RecentChanges page</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a><span class="ot">writeLogEntry ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">PageName</span> <span class="ot">-&gt;</span> <span class="dt">SockAddr</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a>writeLogEntry path pageName client <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a>  <span class="kw">let</span> fileName <span class="ot">=</span> fileNameFor path recentChanges <span class="co">-- path to RecentChanges page</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>  now <span class="ot">&lt;-</span> getCurrentTime                         <span class="co">-- create timestamp</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a>  <span class="kw">let</span> logEntry <span class="ot">=</span> toStrict <span class="op">$</span>                     <span class="co">-- create a log entry consisting of:</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a>        format (<span class="st">&quot;- &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot; &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot; from &quot;</span> <span class="op">%</span> string <span class="op">%</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a>          (asString pageName)                   <span class="co">-- page edited/created</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a>          (<span class="fu">takeWhile</span> (<span class="op">/=</span> <span class="ch">&#39;.&#39;</span>) (<span class="fu">show</span> now))       <span class="co">-- current timestamp</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>          (<span class="fu">takeWhile</span> (<span class="op">/=</span> <span class="ch">&#39;:&#39;</span>) (<span class="fu">show</span> client))    <span class="co">-- IP address of client</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a>  TIO.appendFile fileName logEntry              <span class="co">-- add log entry at end of log file</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="co">-- | the RecentChanges PageName</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true"></a><span class="ot">recentChanges ::</span> <span class="dt">PageName</span></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true"></a>recentChanges <span class="ot">=</span> <span class="dt">Page</span> <span class="st">&quot;RecentChanges&quot;</span></span></code></pre></div>
<p>And here comes a sample screen shot of the RecentChanges page:</p>
<figure>
<img src="../img/RecentChanges.png" alt="" /><figcaption>The RecentChanges page</figcaption>
</figure>
<h2 id="have-a-full-text-search">Have a full text search</h2>
<p>For the full text search Iǜe provided a specific route <code>/actions/find</code> to avoid overlap with ordinary content pages:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>/actions/find/  FindR     GET</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>|]</span></code></pre></div>
<p>The corresponding handler function <code>getFindR</code> is defined as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="co">-- | handler for GET /actions/find</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="ot">getFindR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>getFindR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  path <span class="ot">&lt;-</span> getDocumentRoot                       <span class="co">-- obtain path to document root</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  allPages <span class="ot">&lt;-</span> liftIO <span class="op">$</span> computeIndex path        <span class="co">-- compute a list of all page names in wiki</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>  maybeSearch <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;search&quot;</span>        <span class="co">-- check whether query param &#39;search&#39; is set</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>  <span class="kw">case</span> maybeSearch <span class="kw">of</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>    <span class="dt">Nothing</span>     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> buildFindPage <span class="st">&quot;&quot;</span> [] <span class="co">-- if maybeSearch == Nothing or Just &quot;&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>    <span class="dt">Just</span> <span class="st">&quot;&quot;</span>     <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> buildFindPage <span class="st">&quot;&quot;</span> [] <span class="co">-- then return empty find page</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a>    <span class="dt">Just</span> search <span class="ot">-&gt;</span> <span class="kw">do</span>                           </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a>      markMatches <span class="ot">&lt;-</span> liftIO <span class="op">$</span>                   <span class="co">-- else create a list of Bools by</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a>        <span class="fu">mapM</span>                                    <span class="co">-- returning True for each file that matches</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a>          (\p <span class="ot">-&gt;</span> <span class="fu">fmap</span> containsSearchText <span class="op">$</span>      <span class="co">-- search, else False</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true"></a>            <span class="fu">return</span> (asText p) <span class="op">&lt;&gt;</span> TIO.readFile (fileNameFor path p)) </span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true"></a>          allPages</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true"></a>      <span class="kw">let</span> pageBoolPairs <span class="ot">=</span> <span class="fu">zip</span> allPages markMatches  <span class="co">-- create a zipped list [(PageName, Bool)]</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true"></a>      <span class="kw">let</span> matchingPages <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> (<span class="fu">filter</span> <span class="fu">snd</span> pageBoolPairs) <span class="co">-- filter for all matching pages</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true"></a>      <span class="fu">return</span> <span class="op">$</span> buildFindPage search matchingPages   <span class="co">-- build find page with search term and </span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true"></a>        <span class="kw">where</span>                                       <span class="co">-- list of matching pages</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true"></a>          containsSearchText content <span class="ot">=</span> T.toLower search <span class="ot">`T.isInfixOf`</span> T.toLower content</span></code></pre></div>
<p>The <code>buildFindPage</code> function is responsible for assembling the Html view of this page.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">buildFindPage ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [<span class="dt">PageName</span>] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>buildFindPage search pages <span class="ot">=</span> toHtml</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  [ pageHeader <span class="dt">True</span>,</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    renderMdToHtml <span class="st">&quot;# FindPage &quot;</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>    searchBox search,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>    renderMdToHtml <span class="op">$</span> T.pack <span class="op">$</span> <span class="fu">concatMap</span> (\p <span class="ot">-&gt;</span> <span class="st">&quot;- [&quot;</span> <span class="op">++</span> asString p <span class="op">++</span> <span class="st">&quot;](/&quot;</span> <span class="op">++</span> asString p <span class="op">++</span> <span class="st">&quot;) \n&quot;</span>) pages,</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>    pageFooter</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  ]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a><span class="ot">searchBox ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>searchBox search <span class="ot">=</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true"></a>    <span class="st">&quot;&lt;script type=\&quot;text/javascript\&quot;&gt;&quot;</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;function init()&quot;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;{&quot;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;     document.getElementById(\&quot;search\&quot;).focus();&quot;</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;}&quot;</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;&lt;/script&gt;&quot;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true"></a>    <span class="op">++</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true"></a>    <span class="st">&quot;&lt;form action=\&quot;/actions/find\&quot;&quot;</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot; method=\&quot;GET\&quot;&gt;&quot;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;input type=\&quot;text\&quot; id=\&quot;search\&quot; name=\&quot;search\&quot; value=\&quot;&quot;</span> <span class="op">++</span> T.unpack search <span class="op">++</span> <span class="st">&quot;\&quot; &quot;</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;onfocus=\&quot;this.setSelectionRange(9999, 9999)\&quot; &quot;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;onkeyup=\&quot;this.form.submit()\&quot; /&gt; &quot;</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;input type=\&quot;submit\&quot; value=\&quot;find\&quot; /&gt;&quot;</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;/form&gt;&quot;</span></span></code></pre></div>
<p>The only interesting thing here is that I’ve include a bit of JavaScript to enable page updates while typing into the find box. See the FindPage in action below:</p>
<figure>
<img src="../img/FindPage.png" alt="" /><figcaption>The FindPage</figcaption>
</figure>
<h2 id="provide-a-graph-view-of-pages-and-their-links">Provide a graph view of pages and their links</h2>
<p>So far I’ve just reimplemented stuff that was already there in the original WikiWiki. While toying around with my HsWiki I thought it might be a nice addition to have a graph representation of the site content.</p>
<p>As always I try to code as little as possible myself and get the hard work done by the experts. In this case I’m relying on my alltime favourite Graph rendering library <a href="https://graphviz.org/">GraphViz</a>. This time in it’s web assembly incarnation <a href="https://github.com/magjac/d3-graphviz">d3-graphviz</a>.</p>
<p>So again we’ll have a specific route:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>mkYesod <span class="st">&quot;HsWiki&quot;</span> [parseRoutes|</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>/actions/graph  GraphR    GET</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>|]</span></code></pre></div>
<p>And a corresponding route handler function:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">-- | handler for GET /actions/graph</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="ot">getGraphR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>getGraphR <span class="ot">=</span> <span class="kw">do</span>                                    </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  path     <span class="ot">&lt;-</span> getDocumentRoot                     <span class="co">-- obtain document root folder</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  allPages <span class="ot">&lt;-</span> liftIO <span class="op">$</span> computeIndex path          <span class="co">-- compute list of all wiki pages</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  allRefs  <span class="ot">&lt;-</span> liftIO <span class="op">$</span> <span class="fu">mapM</span>                       <span class="co">-- compute list of all back references</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>    (\p <span class="ot">-&gt;</span> computeBackRefs path p allPages)       </span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>    allPages                                      <span class="co">-- for each file in allPages</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> buildGraphView <span class="op">$</span> <span class="fu">zip</span> allRefs allPages  <span class="co">-- return Html view for [([PageName], PageName)] graph</span></span></code></pre></div>
<p>Please note that this implementation has <span class="math inline">\(O(n^2)\)</span>. This is caused by relying on <code>computeBackrefs</code> this function traverses all files and is called once for each file by <code>mapM</code>. Improving this is left as an exercise for the interested reader (all pull requests are welcome!</p>
<p>The actual Html rendering is a bit more involved as I have to integrate the JS code for d3-graphviz and also to render the GraphViz DOT graph representation:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="co">-- | build view for GraphViz representation of wiki page structure</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="ot">buildGraphView ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>buildGraphView graph <span class="ot">=</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>  toHtml</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>    [ pageHeader <span class="dt">False</span>,</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a>      menuBar <span class="st">&quot;&quot;</span>,</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true"></a>      renderMdToHtml <span class="st">&quot;# Site Map \n&quot;</span>,</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true"></a>      renderMdToHtml <span class="st">&quot;[View as List](/actions/toc) \n&quot;</span>,</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true"></a>      preGraph,                                         <span class="co">-- load wasm scripts, begin JS script</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true"></a>      preEscapedToHtml <span class="op">$</span> renderNodes <span class="op">$</span> allNodes graph,  <span class="co">-- build list of all PageName nodes</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true"></a>      preEscapedToHtml <span class="op">$</span> renderGraph graph,             <span class="co">-- build link structure as directed graph</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true"></a>      postGraph,                                        <span class="co">-- render DOT digraph</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true"></a>      pageFooter</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true"></a>    ]</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true"></a><span class="co">-- | render graph in DOT syntax (from -&gt; to;)</span></span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true"></a><span class="ot">renderGraph ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true"></a>renderGraph graph <span class="ot">=</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true"></a>  <span class="fu">foldr</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true"></a>    (\str <span class="ot">-&gt;</span> ((str <span class="op">++</span> <span class="st">&quot;,\n&quot;</span>) <span class="op">++</span>))</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true"></a>    <span class="st">&quot;&quot;</span></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true"></a>    (<span class="fu">concatMap</span> (\(sources, target) <span class="ot">-&gt;</span> </span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true"></a>      <span class="fu">map</span> </span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true"></a>        (\s <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\&quot;&quot;</span> <span class="op">++</span> asString s <span class="op">++</span> <span class="st">&quot;\&quot; -&gt; \&quot;&quot;</span> <span class="op">++</span> asString target <span class="op">++</span> <span class="st">&quot;\&quot;;&#39;&quot;</span>) </span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true"></a>        sources) </span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true"></a>      graph)</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true"></a></span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true"></a><span class="co">-- | extract list of unique PageNames from graph</span></span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true"></a><span class="ot">allNodes ::</span> [([<span class="dt">PageName</span>], <span class="dt">PageName</span>)] <span class="ot">-&gt;</span> [<span class="dt">PageName</span>]</span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true"></a>allNodes <span class="ot">=</span> nub <span class="op">.</span> (<span class="fu">uncurry</span> (<span class="fu">flip</span> (<span class="op">:</span>)) <span class="op">=&lt;&lt;</span>)</span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true"></a></span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true"></a><span class="co">-- | render list of PageNames as DOT list of nodes with some nice formatting</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true"></a><span class="ot">renderNodes ::</span> [<span class="dt">PageName</span> ] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true"></a>renderNodes <span class="ot">=</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true"></a>  <span class="fu">concatMap</span></span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true"></a>    ( \n <span class="ot">-&gt;</span></span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true"></a>        <span class="st">&quot;&#39;\&quot;&quot;</span> <span class="op">++</span> asString n</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true"></a>          <span class="op">++</span> <span class="st">&quot;\&quot; [shape=\&quot;rect\&quot;, style=\&quot;rounded,filled\&quot;, fillcolor=\&quot;#f4f5f6\&quot;, fontcolor=\&quot;#9b4dca\&quot;, fontname=\&quot;Roboto\&quot;,  URL=\&quot;/&quot;</span></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true"></a>          <span class="op">++</span> asString n</span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true"></a>          <span class="op">++</span> <span class="st">&quot;\&quot;];&#39;, \n&quot;</span></span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true"></a>    )</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true"></a></span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true"></a><span class="co">-- | Html with script code for loading d3-graphviz and opening the DOT digraph</span></span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true"></a><span class="ot">preGraph ::</span> <span class="dt">Html</span></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true"></a>preGraph <span class="ot">=</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true"></a>    <span class="st">&quot;&lt;script src=\&quot;//d3js.org/d3.v5.min.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script src=\&quot;https://unpkg.com/@hpcc-js/wasm@0.3.11/dist/index.min.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script src=\&quot;https://unpkg.com/d3-graphviz@3.0.5/build/d3-graphviz.js\&quot;&gt;&lt;/script&gt;&quot;</span></span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;div id=\&quot;graph\&quot; &gt;&lt;/div&gt;&quot;</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;&lt;script&gt;&quot;</span></span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;var dot =\n&quot;</span></span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;    [\n&quot;</span></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;        &#39;digraph  {&#39;,\n&quot;</span></span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true"></a></span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true"></a><span class="co">-- | Html with script code for rendering the DOT digraph</span></span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true"></a><span class="ot">postGraph ::</span> <span class="dt">Html</span></span>
<span id="cb20-58"><a href="#cb20-58" aria-hidden="true"></a>postGraph <span class="ot">=</span></span>
<span id="cb20-59"><a href="#cb20-59" aria-hidden="true"></a>  preEscapedToHtml <span class="op">$</span></span>
<span id="cb20-60"><a href="#cb20-60" aria-hidden="true"></a>    <span class="st">&quot;        &#39;}&#39;\n&quot;</span></span>
<span id="cb20-61"><a href="#cb20-61" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;     ];\n&quot;</span></span>
<span id="cb20-62"><a href="#cb20-62" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot; \n&quot;</span></span>
<span id="cb20-63"><a href="#cb20-63" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot; d3.select(\&quot;#graph\&quot;).graphviz()\n&quot;</span></span>
<span id="cb20-64"><a href="#cb20-64" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot;     .renderDot(dot.join(&#39;&#39;));\n&quot;</span></span>
<span id="cb20-65"><a href="#cb20-65" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot; \n&quot;</span></span>
<span id="cb20-66"><a href="#cb20-66" aria-hidden="true"></a>      <span class="op">++</span> <span class="st">&quot; &lt;/script&gt;\n&quot;</span></span></code></pre></div>
<p>You can see this in action in the following screen shot:</p>
<figure>
<img src="../img/SiteMap.png" alt="" /><figcaption>The SiteMap with a graph rendering of pages and their links</figcaption>
</figure>
<h2 id="appendix">Appendix</h2>
<h3 id="how-to-build">How to build</h3>
<pre><code>stack init
stack install
HsWiki</code></pre>
<h3 id="installation-under-windows">Installation under Windows</h3>
<p>Under Windows you will have to install the ICU library. I used the latest win64 version from https://github.com/unicode-org/icu/releases/tag/release-70-1. You’ll have to manually copy <em>.ddl and </em>.h files to the following locations:</p>
<ul>
<li>The actual lib files go to <code>C:\Users\&lt;username&gt;\AppData\Local\Programs\stack\x86_64-windows\msys2-&lt;installdate&gt;\mingw64\lib</code> Don’t forget to strip version number from the .dll files (so icuuc70.dll becomes icuuc.dll)</li>
<li>The include files go to <code>C:\Users\&lt;username&gt;\AppData\Local\Programs\stack\x86_64-windows\msys2-&lt;installdate&gt;\mingw64\include\unicode</code></li>
</ul>
]]></summary>
</entry>
<entry>
    <title>Implementing a Functional Language with Graph Reduction</title>
    <link href="https://thma.github.io//posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html" />
    <id>https://thma.github.io//posts/2021-12-27-Implementing-a-functional-language-with-Graph-Reduction.html</id>
    <published>2021-12-27T00:00:00Z</published>
    <updated>2021-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on December 27, 2021
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/lambda-ski/actions"><img src="https://github.com/thma/lambda-ski/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a> <a href="https://github.com/thma/lambda-ski"><img src="/img/forkme.png" height="20" ></a></p>
<h2 id="abstract">Abstract</h2>
<p>Implementing a small functional language with a classic combinator based graph-reduction machine in Haskell.</p>
<p>The implementation is structured into three parts:</p>
<ol type="1">
<li><p>A λ-calculus parser from <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">A Combinatory Compiler</a> which was extended to cover a tiny functional language based on the untyped λ-calculus.</p></li>
<li><p>A compiler from λ-calculus to combinatory logic combinators (S,K,I,B,C and Y) which is based on bracket-abstraction and some optimization rules.</p></li>
<li><p>A graph-reducer. Combinator terms are allocated into a graph data-structure. Which is then reduced by applying combinator graph-reduction. The destructive inplace reduction of the graph is made possible by using <code>STRef</code> mutable references.</p></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>In my <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">last blog post</a> I presented two ways of transforming λ-terms into variable free representations: - bracket abstraction to combinatory logic terms (SKI) and - bracket abstraction to terms of closed cartesian categories (CCC).</p>
<p>I demonstrated that both representations are equivalent as they imply the same reduction rules.</p>
<p>My original intention was to extend an existing Haskell CCC implementation to a proof-of-concept implementation of a small functional language. I even promised to cover this in my next blog post.</p>
<p>I invested a lot of time in this idea but I failed to get it off the ground. <a href="https://github.com/thma/lambda-cat">At least the code of these experiments has been preserved</a>.</p>
<p>So I came back to writing a SKI graph-reduction as the backend of my language implementation. This is a well-worn path. I took the basic ideas from the classic <a href="https://www.goodreads.com/book/show/3468677-compiling-functional-languages">compiling functional languages</a> which dates back to 1988.</p>
<p>Fortunately, I did not fail this time! In the following I’m explaining my implementation approach. I’ll also share some of my insights and talk about possible future extensions.</p>
<h2 id="representing-λ-expressions">representing λ-expressions</h2>
<p>I’m aiming at a very rudimentary language that is basically just pure λ-calculus plus integers. Here is an example:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dt">Y</span>    <span class="ot">=</span> λf <span class="op">.</span> (λx <span class="op">.</span> x x)(λx <span class="op">.</span> f(x x))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>fact <span class="ot">=</span> <span class="dt">Y</span>(\f n <span class="ot">-&gt;</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="op">*</span> n (f (sub1 n))))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>main <span class="ot">=</span> fact <span class="dv">10</span></span></code></pre></div>
<p>As you can see it’s possible to use classical λ-calculus notation <code>λx . x x</code> as well as Haskell syntax: <code>\x -&gt; x x</code>. It’s also possible to freely mix both styles.</p>
<p>λ-expressions can be assigned to names in a top-level environment by using the <code>=</code> sign. those names may be referred to in other λ-expressions. As of now recursive (also mutually recursive) references are not supported.</p>
<p>The <code>main</code> expression has a special meaning; it is interpreted as the entry point to a program.</p>
<p>With this knowledge at hand you will immediately recognize that the above program will compute the factorial of 10. Where <code>fact</code> is defined in a non-recursive way by means of the fixed-point combinator <code>Y</code>.</p>
<p>Expressions of this language are represented by the data type <code>Expr</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">:@</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Expr</span> <span class="op">:@</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Integer</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">String</span> <span class="dt">Expr</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>The top-level environment which maps names to λ-Expressions is represented by the following type:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Environment</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Expr</span>)]</span></code></pre></div>
<h2 id="the-parser">The Parser</h2>
<p>There is not much to see in <a href="https://github.com/thma/lambda-ski/blob/main/src/Parser.hs">this area</a>. It’s just a simple Parsec based parser. Most of the code was taken from <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">A Combinatory Compiler</a>. I just added the parsing of Integers.</p>
<p>The parser module exports to function <code>parseEnvironmentEither</code> and <code>parseEnvironment</code>. The former is a total function returning an Either: <code>parseEnvironmentEither :: String -&gt; Either ParseError Environment</code>, whereas the latter simply returns an <code>Environment</code> but may throw run-time errors.</p>
<p>The following <a href="https://github.com/thma/lambda-ski/blob/main/app/Main.hs">snippet</a> demonstrates how a program is parsed into an Environment:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">testSource ::</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>testSource <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>       <span class="st">&quot;Y    = λf -&gt; (λx -&gt; x x)(λx -&gt; f(x x)) \n&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;fact = Y(λf n -&gt; if (is0 n) 1 (* n (f (sub1 n)))) \n&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>    <span class="op">++</span> <span class="st">&quot;main = fact 10 \n&quot;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  <span class="kw">let</span> env <span class="ot">=</span> parseEnvironment testSource</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="fu">mapM_</span> <span class="fu">print</span> env</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>This code results in the following output, which shows all <code>(String, Expr)</code> tuples in the environment:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="st">&quot;Y&quot;</span>,   <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="op">:@</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(<span class="st">&quot;fact&quot;</span>,<span class="dt">Var</span> <span class="st">&quot;Y&quot;</span> <span class="op">:@</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;n&quot;</span> (((<span class="dt">Var</span> <span class="st">&quot;if&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;is0&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>)) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">1</span>) <span class="op">:@</span> </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>        ((<span class="dt">Var</span> <span class="st">&quot;*&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;sub1&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;n&quot;</span>))))))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>(<span class="st">&quot;main&quot;</span>,<span class="dt">Var</span> <span class="st">&quot;fact&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">10</span>)</span></code></pre></div>
<h2 id="bracket-abstraction">Bracket abstraction</h2>
<h3 id="motivation">Motivation</h3>
<p>Of course it is possible to write interpreters that evaluate these λ-expression to normalform. This is what any Lisp or Scheme eval/apply interpreter does at its core <a href="http://www.sicpdistilled.com/section/4.1/">(See a tiny example here)</a>.</p>
<p>One of the most problematic areas of these interpreters is the handling of variables. In order to provide static binding you will need closures that captures the current environment of variable bindings and thread them through the whole interpreter execution.</p>
<p>Language implemetors have thus experimented with many ways to tackle this issue. One of the most influential ideas was to completely get rid of variables by abstracting them.</p>
<p>The earliest version of this approach was <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">the SKI combinator calculus</a> invented by Haskell Curry and Moses Schönfinkel.</p>
<p>A λ-term that does not contain any free variables is said to be closed. Closed lambda terms are also called <em>combinators</em>.</p>
<p>Schönfinkel and Curry found out that any closed λ-term can be rewritten in terms of three basic combinators I, K and S (in fact only <em>K</em> and <em>S</em> are essential, as <em>I</em> can be expressed as SKK):</p>
<p><img style="align:center;" src="https://latex.codecogs.com/gif.latex?\begin{array}{rcl}&space;I&space;&&space;=&space;&&space;\lambda&space;x.x&space;\\&space;K&space;&&space;=&space;&&space;\lambda&space;x.&space;\lambda&space;y.x&space;\\&space;S&space;&&space;=&space;&&space;\lambda&space;f.(\lambda&space;g.(\lambda&space;x.fx(gx)))&space;\end{array}" title="\begin{array}{rcl} I & = & \lambda x.x \\ K & = & \lambda x. \lambda y.x \\ S & = & \lambda f.(\lambda g.(\lambda x.fx(gx))) \end{array}" /></p>
<p>In Haskell these combinators can simply be defined as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>i x <span class="ot">=</span> x</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>k x y <span class="ot">=</span> x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>s f g x <span class="ot">=</span> f x (g x)</span></code></pre></div>
<h2 id="the-basic-abstraction-rules">The basic abstraction rules</h2>
<p>The idea of bracket abstraction is to rewrite any closed λ-term in terms of I, K and S. This recursive transformation is defined by the following equations:</p>
<p><img src="https://latex.codecogs.com/gif.latex?\begin{array}{rcl}&space;\left&space;\lceil&space;\lambda&space;x.x&space;\right&space;\rceil&space;&&space;=&space;&&space;I&space;\\&space;\left&space;\lceil&space;\lambda&space;x.y&space;\right&space;\rceil&space;&&space;=&space;&&space;K&space;y&space;\\&space;\left&space;\lceil&space;\lambda&space;x.M&space;N&space;\right&space;\rceil&space;&&space;=&space;&&space;S&space;\left&space;\lceil&space;\lambda&space;x.M&space;\right&space;\rceil&space;\left&space;\lceil&space;\lambda&space;x.N&space;\right&space;\rceil&space;\end{array}" title="\begin{array}{rcl} \left \lceil \lambda x.x \right \rceil & = & I \\ \left \lceil \lambda x.y \right \rceil & = & K y \\ \left \lceil \lambda x.M N \right \rceil & = & S \left \lceil \lambda x.M \right \rceil \left \lceil \lambda x.N \right \rceil \end{array}" /></p>
<p>This can be implemented in Haskell as follows:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="co">-- | most basic bracket abstraction (plus resolution of free variables in the environment).</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">babs0 ::</span> <span class="dt">Environment</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>babs0 env (<span class="dt">Lam</span> x e) <span class="co">-- this clause implements the three basic equations for bracket abstraction</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Var</span> y <span class="ot">&lt;-</span> t, x <span class="op">==</span> y     <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="op">|</span> x <span class="ot">`notElem`</span> fv [] t    <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> t</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>  <span class="op">|</span> m <span class="op">:@</span> n <span class="ot">&lt;-</span> t            <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> babs0 env (<span class="dt">Lam</span> x m) <span class="op">:@</span> babs0 env (<span class="dt">Lam</span> x n)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>  <span class="kw">where</span> t <span class="ot">=</span> babs0 env e</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>babs0 env (<span class="dt">Var</span> s) <span class="co">-- this clause resolves free variables by looking them up in the environment env</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Just</span> t <span class="ot">&lt;-</span> <span class="fu">lookup</span> s env <span class="ot">=</span> babs0 env t</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>              <span class="ot">=</span> <span class="dt">Var</span> s</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>babs0 env  (m <span class="op">:@</span> n)        <span class="ot">=</span> babs0 env m <span class="op">:@</span> babs0 env n  <span class="co">-- this clause recurses into applications</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a>babs0 _env x               <span class="ot">=</span> x                           <span class="co">-- returns anything else unchanged</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a><span class="co">-- | compute the list of free variables of a lambda expression</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a><span class="ot">fv ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>fv vs (<span class="dt">Var</span> s) <span class="op">|</span> s <span class="ot">`elem`</span> vs <span class="ot">=</span> []</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>              <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">=</span> [s]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true"></a>fv vs (x <span class="op">:@</span> y)              <span class="ot">=</span> fv vs x <span class="ot">`union`</span> fv vs y</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true"></a>fv vs (<span class="dt">Lam</span> s f)             <span class="ot">=</span> fv (s<span class="op">:</span>vs) f</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true"></a>fv vs _                     <span class="ot">=</span> vs</span></code></pre></div>
<p>Let’s have a look at a simple example. first we parse a simple expression into a lambda-term:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> env <span class="ot">=</span> parseEnvironment <span class="st">&quot;main = (λx -&gt; + 4 x) 5\n&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> env</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>[(<span class="st">&quot;main&quot;</span>,<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">5</span>)]</span></code></pre></div>
<p>Next we apply bracket abstraction:</p>
<pre><code>ghci&gt; skiExpr = babs env (snd . head $ env)
ghci&gt; skiExpr
((Var &quot;s&quot; :@ (Var &quot;k&quot; :@ (Var &quot;+&quot; :@ Int 4))) :@ Var &quot;i&quot;) :@ Int 5</code></pre>
<p>The result of bracket abstraction is still a lambda-term, but one where all <code>Lam</code>-expression have been eliminated.</p>
<h3 id="optimization">Optimization</h3>
<p>Even from this simple example it is obvious that the SKI-combinator terms become larger than the original expressions. This will be an impediment to efficient implementation. So many different approaches have been conceived to mitigate this issue.</p>
<p>The earliest solution, already suggested by Schönfinkel, is to introduce additional combinators B and C that cover specific patterns in the source code. Here are the reduction rules for B and C.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="dt">C</span> f g x <span class="ot">=</span> ((f x) g)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="dt">B</span> f g x <span class="ot">=</span> (f (g x))</span></code></pre></div>
<p>We could extend <code>babs</code> to cover B and C. But the most common way is to run a second optimization pass over the SKI-expression.</p>
<p>Here is is a simple example of such an optimization:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">opt ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>opt (<span class="dt">Var</span> <span class="st">&quot;i&quot;</span> <span class="op">:@</span> n<span class="op">@</span>(<span class="dt">Int</span> _n))                           <span class="ot">=</span> n</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e1)) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e2)) <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> (e1 <span class="op">:@</span> e2)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e2))              <span class="ot">=</span> (<span class="dt">Var</span> <span class="st">&quot;c&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> e2</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>opt ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;k&quot;</span> <span class="op">:@</span> e1)) <span class="op">:@</span> e2)              <span class="ot">=</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span> <span class="op">:@</span> e1) <span class="op">:@</span> e2</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>opt (x <span class="op">:@</span> y)                                          <span class="ot">=</span> opt x <span class="op">:@</span> opt y</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>opt x                                                 <span class="ot">=</span> x</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a><span class="ot">ropt ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true"></a>ropt expr <span class="ot">=</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true"></a>  <span class="kw">let</span> expr&#39; <span class="ot">=</span> opt expr</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true"></a>  <span class="kw">in</span>  <span class="kw">if</span> expr&#39; <span class="op">==</span> expr</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true"></a>        <span class="kw">then</span> expr</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true"></a>        <span class="kw">else</span> <span class="kw">case</span> expr&#39; <span class="kw">of</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true"></a>          (x <span class="op">:@</span> y) <span class="ot">-&gt;</span> ropt <span class="op">$</span> ropt x <span class="op">:@</span> ropt y</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true"></a>          _        <span class="ot">-&gt;</span> ropt expr&#39;</span></code></pre></div>
<p>Let’s try this out:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optExpr <span class="ot">=</span> ropt skiExpr</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optEpr</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>((<span class="dt">Var</span> <span class="st">&quot;b&quot;</span> <span class="op">:@</span> (<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">4</span>)) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">5</span></span></code></pre></div>
<p>This looks much better than before. See <a href="https://crypto.stanford.edu/~blynn/lambda/logski.html">this project for a more in depth coverage of optimization techniques</a>. I’m also planning to write a separate blog post on this subtopic.</p>
<p>The <a href="https://github.com/thma/lambda-ski/blob/main/src/LambdaToSKI.hs">sourcecode for this section can be found here</a></p>
<h2 id="graph-reduction-in-a-nutshell">Graph-reduction in a nutshell</h2>
<p>So now that we have eliminated lambda abstractions from our lambda terms it should be straight forward to evaluate these expressions with a simple interpreter.</p>
<p>Let’s have a look at a simple example:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>sqr  <span class="ot">=</span> λx <span class="ot">-&gt;</span> <span class="op">*</span> x x</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>main <span class="ot">=</span> sqr (<span class="op">+</span> <span class="dv">3</span> <span class="dv">2</span>)</span></code></pre></div>
<p>When we implement a strict interpreter with applicative-order semantics, <code>(+ 3 2)</code> will be computed first and the result bound to the variable <code>x</code> in the local environment and then the body of <code>sqr</code> will be evaluated in this environment. That’s fine. but it’s not normal-order reduction.</p>
<p>When implementing a lazy interpreter with normal-order semantics, we can not compute <code>(+ 3 2)</code> before binding it to <code>x</code>. Thus we will have to bind an un-evaluated <em>thunk</em> to <code>x</code>. We will also have to make sure that <code>x</code> is only evaluated when needed and only once, even when it is used at several places in the body of <code>sqr</code>. (See <a href="https://academic.udayton.edu/saverioperugini/courses/cps343/lecture_notes/lazyevaluation.html">these lecture notes for all the intricacies of this approach</a>)</p>
<p>Graph-reduction on the other hand, has some very interesting features: - It maintains normal-order reduction (that is lazy evaluation) - double evaluations of terms is avoided - dealing with local environments, variable scope, etc. at run-time is avoided - copying of argument data is significantly reduced as compared to eval/apply interpreters</p>
<p>Let’s see this in action with our toy example. The above program can be transformed into the following SKI combinator term:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">2</span>)</span></code></pre></div>
<p>This term can be represented as a binary graph, where each application <code>:@</code> is represented as an <code>@</code> node, all combinators like <code>(Var "s")</code> are represented with Constructors like <code>S</code>, <code>I</code>, <code>MUL</code>, <code>ADD</code> and integer values like <code>Int 2</code> are just shown as numeric values like <code>2</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>          <span class="op">@</span>                   </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>         <span class="op">/</span> \              </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>        <span class="op">/</span>   \               </span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>       <span class="op">/</span>     <span class="op">@</span>          </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>      <span class="op">/</span>     <span class="op">/</span> \          </span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>     <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         </span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>    <span class="op">@</span>     <span class="op">/</span> \     </span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>   <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>    </span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>  <span class="op">@</span>   <span class="dt">I</span>            </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a> <span class="op">/</span> \             </span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a><span class="dt">S</span>  <span class="dt">MUL</span>   </span></code></pre></div>
<p>In the following diagram we follow the reduction of this graph:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>          <span class="op">@</span>                   <span class="op">@</span>                   <span class="op">@</span>                  <span class="op">@</span>           <span class="dv">25</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>         <span class="op">/</span> \                 <span class="op">/</span> \                 <span class="op">/</span> \                <span class="op">/</span> \</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        <span class="op">/</span>   \               <span class="op">/</span>   \               <span class="op">/</span>   \              <span class="op">/</span>   <span class="op">|</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>       <span class="op">/</span>     <span class="op">@</span>             <span class="op">/</span>     <span class="op">@</span>             <span class="op">/</span>     <span class="op">@</span>            <span class="op">/</span>   <span class="op">/</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>      <span class="op">/</span>     <span class="op">/</span> \           <span class="op">@</span>     <span class="op">/</span> \           <span class="op">@</span>     <span class="op">/</span> \          <span class="op">@</span>   <span class="op">/</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>     <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         <span class="op">/</span> \   <span class="dt">I</span>   <span class="op">|</span>         <span class="op">/</span> \   <span class="dt">I</span>   <span class="op">|</span>        <span class="op">/</span> \ <span class="op">/</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>    <span class="op">@</span>     <span class="op">/</span> \           <span class="op">/</span>   <span class="op">@</span> ––––<span class="op">/</span>         <span class="op">/</span>   <span class="dv">5</span> ––––<span class="op">/</span>        <span class="op">/</span>   <span class="dv">5</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>   <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>         <span class="op">/</span>   <span class="op">/</span> \             <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>  <span class="op">@</span>   <span class="dt">I</span>               <span class="op">/</span>   <span class="op">@</span>   <span class="dv">2</span>           <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true"></a> <span class="op">/</span> \                 <span class="op">/</span>   <span class="op">/</span> \             <span class="op">/</span>                  <span class="op">/</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true"></a><span class="dt">S</span>  <span class="dt">MUL</span>             <span class="dt">MUL</span>  <span class="dt">ADD</span> <span class="dv">3</span>           <span class="dt">MUL</span>                <span class="dt">MUL</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true"></a></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true"></a><span class="dt">Step</span> <span class="dv">0</span>             <span class="dt">Step</span> <span class="dv">1</span>               <span class="dt">Step</span> <span class="dv">2</span>             <span class="dt">Step</span> <span class="dv">3</span>                <span class="dt">Step</span> <span class="dv">4</span></span></code></pre></div>
<ul>
<li><p><strong>Step 0</strong>: This is just the initial state of the graph as explained above. Please note that in this state the <code>S</code> is our <em>redex</em> (i.e. the left-most ancestor of the root node) and <em>saturated</em> (i.e all three arguments of the combinator) are populated, so according to the reduction rule <code>s f g x = f x (g x)</code> we expect to see a reduction <code>S MUL I (ADD 3 2) = MUL (ADD 3 2) (I (ADD 3 2))</code> in step 1.</p></li>
<li><p><strong>Step 1</strong>: As expected the first reduction step mutates the graph to represent <code>MUL (ADD 3 2) (I (ADD 3 2))</code>. Please note that both occurrences of <code>(ADD 3 2)</code> are represented by references to one and the same node.</p></li>
<li><p><strong>Step 2</strong>: Now <code>MUL</code> has become the <em>redex</em> (short for reducible expression). But this time both arguments <code>(ADD 3 2)</code> and <code>I (ADD 3 2)</code> are not in normal-form and thus have to be reduced first before <code>MUL</code> can be executed. So first <code>(ADD 3 2)</code> is reduced to <code>5</code>. Please note that both references to the former <code>(ADD 3 2)</code> node now point to <code>5</code>. So in effect the <code>I (ADD 3 2)</code> node has changed to <code>I 5</code> as <code>(ADD 3 2)</code> was a shared node.</p></li>
<li><p><strong>Step 3</strong>: next the <code>I 5</code> node is reduced according to the equation <code>i x = x</code>. That is, the reference to the application node <code>I @ 5</code> is modified to directly point to <code>5</code> instead. Please note that both arguments point to one and the same numeric value <code>5</code>.</p></li>
<li><p><strong>Step 4</strong>: As a result of the transformation in step 3 both arguments of <code>MUL</code> are in normal-form. So now <code>MUL 5 5</code> can be performed: Accordingly the root node is now changed to <code>25</code>.</p></li>
</ul>
<p>Now that we have a basic understanding of the ideas behind graph-reduction we will have a closer look at the actual implementation in the following sections.</p>
<h2 id="allocating-a-graph-with-mutable-references">Allocating a Graph with mutable references</h2>
<p>As we have seen in the last section we will have to deal with mutable references in order to implement things like node sharing and in-place mutation of nodes.</p>
<p>I will use the Haskell datatype <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/Data-STRef.html"><code>Data.STRef</code></a> which provides mutable references in the <code>ST</code> monad.</p>
<p>Here comes a basic example that demonstrates the basic functionality of <code>STRef</code>. A list of numbers is summed up by adding each of them to an accumulator. The accumulator is implemented by a reference <code>acc</code> pointing to an initial value of <code>0</code>. Then we iterate over the list of numbers and update the value of the accumulator by adding each number <code>x</code> to it. Finally the result is read out from the accumulator and extracted from the ST Monad by runST. From this example we can see that <code>STRef</code>s work much like pointers in imperative languages:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Data.STRef</span>       (<span class="dt">STRef</span>, modifySTRef, newSTRef, readSTRef writeSTRef)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span> (runST)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a><span class="co">-- | sum up a list of numerical values </span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ot">sumST ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>sumST numbers <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span> <span class="co">-- runST takes stateful ST code and makes it pure.</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  acc <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span>        <span class="co">-- Create an STRef (a mutable variable) to an accumulator</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  forM_ numbers <span class="op">$</span> \x <span class="ot">-&gt;</span>    <span class="co">-- iterate over all numbers</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>    modifySTRef acc (<span class="op">+</span> x)  <span class="co">-- add each number to what we have in acc.</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  readSTRef acc            <span class="co">-- read the value of acc, which will be returned by the runST above.</span></span></code></pre></div>
<p>This looks promising. So now lets implement a binary graph for our compiled combinator terms with it:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">infixl</span> <span class="dv">5</span> <span class="op">:@:</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Graph</span> s</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="ot">=</span> (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="op">:@:</span> (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Comb</span> <span class="dt">Combinator</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">Num</span> <span class="dt">Integer</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Combinator</span> <span class="ot">=</span> <span class="dt">I</span> <span class="op">|</span> <span class="dt">K</span> <span class="op">|</span> <span class="dt">S</span> <span class="op">|</span> <span class="dt">B</span> <span class="op">|</span> <span class="dt">C</span> <span class="op">|</span> <span class="dt">Y</span> <span class="op">|</span> <span class="dt">P</span> <span class="op">|</span> <span class="dt">ADD</span> <span class="op">|</span> <span class="dt">SUB</span> <span class="op">|</span> <span class="dt">MUL</span> <span class="op">|</span> <span class="dt">DIV</span> <span class="op">|</span> <span class="dt">REM</span> <span class="op">|</span> <span class="dt">SUB1</span> <span class="op">|</span> <span class="dt">EQL</span> <span class="op">|</span> <span class="dt">ZEROP</span> <span class="op">|</span> <span class="dt">IF</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>So we basically mimic the <code>Expr</code> data type used to encode λ-expression but without variables and lambda-abstractions. The data type <code>Combinator</code> contains constructors for combinators that we intend to implement in the graph-reduction engine.</p>
<p>Next we define a function <code>allocate</code> that allows to allocate a ‘lambda-abstracted’ λ-expression (of type <code>Expr</code>) into a reference to a <code>Graph</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="co">-- | allocate a &#39;lambda-abstracted&#39; Expr into a referenced Graph</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="ot">allocate ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>allocate (<span class="dt">Var</span> name) <span class="ot">=</span> newSTRef <span class="op">$</span> <span class="dt">Comb</span> <span class="op">$</span> fromString name</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>allocate (<span class="dt">Int</span> val)  <span class="ot">=</span> newSTRef <span class="op">$</span> <span class="dt">Num</span> val</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>allocate (l <span class="op">:@</span> r)   <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  lg <span class="ot">&lt;-</span> allocate l</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  rg <span class="ot">&lt;-</span> allocate r</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  newSTRef <span class="op">$</span> lg <span class="op">:@:</span> rg</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true"></a>allocate (<span class="dt">Lam</span> _ _)  <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;lambdas must already be abstracted away!&quot;</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true"></a></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true"></a><span class="co">-- | lookup Combinator constructors by their names</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true"></a><span class="ot">fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Combinator</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true"></a>fromString <span class="st">&quot;i&quot;</span>    <span class="ot">=</span> <span class="dt">I</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true"></a>fromString <span class="st">&quot;k&quot;</span>    <span class="ot">=</span> <span class="dt">K</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true"></a>fromString <span class="st">&quot;s&quot;</span>    <span class="ot">=</span> <span class="dt">S</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true"></a>fromString <span class="st">&quot;b&quot;</span>    <span class="ot">=</span> <span class="dt">B</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true"></a>fromString <span class="st">&quot;c&quot;</span>    <span class="ot">=</span> <span class="dt">C</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true"></a>fromString <span class="st">&quot;y&quot;</span>    <span class="ot">=</span> <span class="dt">Y</span></span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true"></a>fromString <span class="st">&quot;p&quot;</span>    <span class="ot">=</span> <span class="dt">P</span></span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true"></a>fromString <span class="st">&quot;+&quot;</span>    <span class="ot">=</span> <span class="dt">ADD</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true"></a>fromString <span class="st">&quot;sub&quot;</span>  <span class="ot">=</span> <span class="dt">SUB</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true"></a>fromString <span class="st">&quot;div&quot;</span>  <span class="ot">=</span> <span class="dt">DIV</span></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true"></a>fromString <span class="st">&quot;rem&quot;</span>  <span class="ot">=</span> <span class="dt">REM</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true"></a>fromString <span class="st">&quot;*&quot;</span>    <span class="ot">=</span> <span class="dt">MUL</span></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true"></a>fromString <span class="st">&quot;sub1&quot;</span> <span class="ot">=</span> <span class="dt">SUB1</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true"></a>fromString <span class="st">&quot;eq&quot;</span>   <span class="ot">=</span> <span class="dt">EQL</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true"></a>fromString <span class="st">&quot;is0&quot;</span>  <span class="ot">=</span> <span class="dt">ZEROP</span></span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true"></a>fromString <span class="st">&quot;if&quot;</span>   <span class="ot">=</span> <span class="dt">IF</span></span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true"></a>fromString _c     <span class="ot">=</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;unknown combinator &quot;</span> <span class="op">++</span> _c</span></code></pre></div>
<p>So let’s see this in action:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>ghci<span class="op">&gt;</span> optExpr <span class="ot">=</span> ((<span class="dt">Var</span> <span class="st">&quot;s&quot;</span> <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;*&quot;</span>) <span class="op">:@</span> <span class="dt">Var</span> <span class="st">&quot;i&quot;</span>) <span class="op">:@</span> ((<span class="dt">Var</span> <span class="st">&quot;+&quot;</span> <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">3</span>) <span class="op">:@</span> <span class="dt">Int</span> <span class="dv">2</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>ghci<span class="op">&gt;</span> graph <span class="ot">=</span> allocate optExpr</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString graph </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="st">&quot;(((S :@: MUL) :@: I) :@: ((ADD :@: 3) :@: 2))&quot;</span></span></code></pre></div>
<p>I’m using the <code>mToString</code> helper function to render <code>ST s (STRef s (Graph s))</code> instances:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">mToString ::</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">String</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>mToString g <span class="ot">=</span> toString <span class="op">=&lt;&lt;</span> g     </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">toString ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">String</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>toString graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a> g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a> toString&#39; g <span class="kw">where</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>   toString&#39; (<span class="dt">Comb</span> c) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> c</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>   toString&#39; (<span class="dt">Num</span> i) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> i</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>   toString&#39; (lP <span class="op">:@:</span> rP) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>     lG <span class="ot">&lt;-</span> readSTRef lP</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>     rG <span class="ot">&lt;-</span> readSTRef rP</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a>     lStr <span class="ot">&lt;-</span> toString&#39; lG</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a>     rStr <span class="ot">&lt;-</span> toString&#39; rG</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a>     <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> lStr <span class="op">++</span> <span class="st">&quot; :@: &quot;</span> <span class="op">++</span> rStr <span class="op">++</span> <span class="st">&quot;)&quot;</span> </span></code></pre></div>
<p>Now that we have allocated our expression as an <code>ST s (STRef s (Graph s))</code> the next step will be to perform graph reduction on it.</p>
<h2 id="performing-graph-reduction">Performing graph-reduction</h2>
<p>First we have to compute the stack of left ancestors - or <em>spine</em> - of a graph for an efficient reduction.</p>
<p>In the following diagram I have marked the members of this stack with <code>-&gt;</code> arrows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">-&gt;</span>           <span class="op">@</span>                   </span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>            <span class="op">/</span> \              </span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>           <span class="op">/</span>   \               </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>          <span class="op">/</span>     <span class="op">@</span>          </span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>         <span class="op">/</span>     <span class="op">/</span> \          </span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>        <span class="op">/</span>     <span class="op">@</span>   <span class="dv">2</span>         </span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a><span class="ot">-&gt;</span>     <span class="op">@</span>     <span class="op">/</span> \     </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>      <span class="op">/</span> \  <span class="dt">ADD</span>  <span class="dv">3</span>    </span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a><span class="ot">-&gt;</span>   <span class="op">@</span>   <span class="dt">I</span>            </span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    <span class="op">/</span> \             </span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">S</span>  <span class="dt">MUL</span>   </span></code></pre></div>
<p>The following function <code>spine</code> computes this left ancestors’ stack by traversing all application nodes to the left:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="co">-- we simply represent the stack as a list of references to graph nodes</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">=</span> [<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">spine ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">LeftAncestorsStack</span> s)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>spine graph <span class="ot">=</span> spine&#39; graph [] </span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a><span class="ot">    spine&#39; ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">LeftAncestorsStack</span> s)</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true"></a>    spine&#39; graph stack <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true"></a>      g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true"></a>      <span class="kw">case</span> g <span class="kw">of</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true"></a>        (l <span class="op">:@:</span> _r) <span class="ot">-&gt;</span> spine&#39; l (graph <span class="op">:</span> stack)</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true"></a>        _          <span class="ot">-&gt;</span> <span class="fu">return</span> (graph <span class="op">:</span> stack)</span></code></pre></div>
<p>Using this <code>spine</code> function we can implement a function <code>step</code> that performs a single reduction step on a <code>Graph</code> node:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="ot">step ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>step graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>  (top<span class="op">:</span>stack) <span class="ot">&lt;-</span> spine graph</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  node <span class="ot">&lt;-</span> readSTRef top</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  <span class="kw">case</span> node <span class="kw">of</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>    (<span class="dt">Comb</span> k) <span class="ot">-&gt;</span> reduce k stack</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>    _        <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span></code></pre></div>
<p>If a combinator is found in redex position, <code>reduce</code> is called to perform the actual reduction work according to the combinator specific reduction rules.</p>
<p>Let’s study this for some of the combinators, starting with the most simple one, <code>I x = x</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>        <span class="op">|</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>p  <span class="ot">-&gt;</span>   <span class="op">@</span>   </span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>       <span class="op">/</span> \</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">I</span>   x</span></code></pre></div>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">reduce ::</span> <span class="dt">Combinator</span> <span class="ot">-&gt;</span> <span class="dt">LeftAncestorsStack</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>reduce <span class="dt">I</span> (p <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a>  (_I <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>  xVal <span class="ot">&lt;-</span> readSTRef xP</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>  writeSTRef p xVal</span></code></pre></div>
<p>In this case a reference <code>p</code> to <code>(I :@: xP )</code> is on top of the stack. The actual value of x is read from <code>xP</code> with <code>readSTRef</code> and than <code>p</code> is made to point to this value by using <code>writeSTRef</code>.</p>
<p>The reduction of <code>S f g x = f x (g x)</code> is already a bit more involved:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>            <span class="op">|</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>p3 <span class="ot">-&gt;</span>       <span class="op">@</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>           <span class="op">/</span> \</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a>p2 <span class="ot">-&gt;</span>     <span class="op">@</span>   x</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a>         <span class="op">/</span> \</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>p1 <span class="ot">-&gt;</span>   <span class="op">@</span>   g</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>       <span class="op">/</span> \</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>   <span class="ot">-&gt;</span> <span class="dt">S</span>   f</span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>reduce <span class="dt">S</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> p3 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  (_S <span class="op">:@:</span> fP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  (_  <span class="op">:@:</span> gP) <span class="ot">&lt;-</span> readSTRef p2</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  (_  <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p3</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>  node1 <span class="ot">&lt;-</span> newSTRef <span class="op">$</span> fP <span class="op">:@:</span> xP</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>  node2 <span class="ot">&lt;-</span> newSTRef <span class="op">$</span> gP <span class="op">:@:</span> xP</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>  writeSTRef p3 (node1 <span class="op">:@:</span> node2)</span></code></pre></div>
<p>In this case reference to f (<code>fP</code>), g (<code>gP</code>) and x (<code>xP</code>) are obtained. Then a new application node is created that represents <code>((f @ x) @ (g @ x))</code>. Then <code>p3</code> is made to point to this new node.</p>
<p>Binary arithmentic combinators like <code>ADD</code> and <code>MUL</code> are implemented as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>reduce <span class="dt">ADD</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> binaryMathOp (<span class="op">+</span>) p1 p2</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>reduce <span class="dt">MUL</span> (p1 <span class="op">:</span> p2 <span class="op">:</span> _) <span class="ot">=</span> binaryMathOp (<span class="op">*</span>) p1 p2</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="ot">binaryMathOp ::</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>  (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="co">-- ^ a binary arithmetic function on Integers like (+)</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>  <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span>               <span class="co">-- ^ first node on the spine stack</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span>               <span class="co">-- ^ second node on spine stack</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>  <span class="dt">ST</span> s ()                            </span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>binaryMathOp op p1 p2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>  (_ <span class="op">:@:</span> xP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a>  (_ <span class="op">:@:</span> yP) <span class="ot">&lt;-</span> readSTRef p2</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>  (<span class="dt">Num</span> xVal) <span class="ot">&lt;-</span> (readSTRef <span class="op">&lt;=&lt;</span> normalForm) xP  <span class="co">-- reduce xP to normal form and obtain its value as xVal</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>  (<span class="dt">Num</span> yVal) <span class="ot">&lt;-</span> (readSTRef <span class="op">&lt;=&lt;</span> normalForm) yP  <span class="co">-- reduce yP to normal form and obtain its value as yVal</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>  writeSTRef p2 (<span class="dt">Num</span> <span class="op">$</span> xVal <span class="ot">`op`</span> yVal)         <span class="co">-- apply op on xVal and yVal, modify p2 to point to the resulting value</span></span></code></pre></div>
<p>The interesting bit here is that the arithmetic combinators are <em>strict</em>, that is they require their arguments to be in normalform. (Please note that <code>S</code>, <code>I</code>, <code>K</code>, etc. don’t have this requirement. They are <em>non-strict</em> or <em>lazy</em>).</p>
<p><code>normalForm</code> just applies <code>step</code> in a loop while the graph has not been reduced to a combinator or an integer:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">normalForm ::</span> <span class="dt">STRef</span> s (<span class="dt">Graph</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>normalForm graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  step graph</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>  g <span class="ot">&lt;-</span> readSTRef graph</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>  <span class="kw">case</span> g <span class="kw">of</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>    _lP <span class="op">:@:</span> _rP <span class="ot">-&gt;</span> normalForm graph</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>    <span class="dt">Comb</span> _com   <span class="ot">-&gt;</span> <span class="fu">return</span> graph</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>    <span class="dt">Num</span> _n      <span class="ot">-&gt;</span> <span class="fu">return</span> graph</span></code></pre></div>
<p>Using a helper function <code>reduceGraph</code> that computes the normal-form of a graph while staying entirely in the <code>ST</code>-Monad, we can finally reduce our tiny toy graph:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="ot">reduceGraph ::</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s)) <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s (<span class="dt">Graph</span> s))</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>reduceGraph graph <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>  gP <span class="ot">&lt;-</span> graph</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>  normalForm gP</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString graph</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a><span class="st">&quot;(((S :@: MUL) :@: I) :@: ((ADD :@: 3) :@: 2))&quot;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>ghci<span class="op">&gt;</span> runST <span class="op">$</span> mToString <span class="op">$</span> reduceGraph graph</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true"></a><span class="st">&quot;25&quot;</span></span></code></pre></div>
<h2 id="recursion">Recursion</h2>
<p>λ-calculus does not directly support recursion using self-referential functions <a href="https://sookocheff.com/post/fp/recursive-lambda-functions/">(see this nice exposition)</a>. That’s why we need a fixed-point combinator to realize recursive operation. Here once again the definition of the factorial function that makes use of the <code>Y</code>-Combinator to implement recursive behaviour:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="dt">Y</span>    <span class="ot">=</span> λf <span class="op">.</span> (λx <span class="op">.</span> x x)(λx <span class="op">.</span> f(x x))</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>fact <span class="ot">=</span> <span class="dt">Y</span>(\f n <span class="ot">-&gt;</span> <span class="kw">if</span> (is0 n) <span class="dv">1</span> (<span class="op">*</span> n (f (sub1 n))))</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>main <span class="ot">=</span> fact <span class="dv">10</span></span></code></pre></div>
<p>With only a few lines of equational reasoning we can demonstrate the special property of the <code>Y</code>-combinator when applied to any function <code>g</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="dt">Y</span> g <span class="ot">=</span> (λf<span class="op">.</span>(λx<span class="op">.</span>x x)(λx<span class="op">.</span>f(x x))) g  <span class="co">-- (1) by definition of Y</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="ot">=</span> (λx<span class="op">.</span>g (x x))(λx<span class="op">.</span>g (x x))    <span class="co">-- (2) by function application of λf</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>    <span class="ot">=</span> g((λx<span class="op">.</span>g (x x))(λx<span class="op">.</span>g (x x))) <span class="co">-- (3) by function application of λx.g(x x) to λx.g(x x)</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>    <span class="ot">=</span> g(<span class="dt">Y</span> g)                      <span class="co">-- (4) by equation (2)</span></span></code></pre></div>
<p>Applying equation <code>(4)</code> repeatedly will lead to:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="dt">Y</span> g <span class="ot">=</span> g(g(<span class="dt">Y</span> g))                    <span class="co">-- (5) by equation (4)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="ot">=</span> g(<span class="op">...</span>g(<span class="dt">Y</span> g) <span class="op">...</span>)             <span class="co">-- (6) by repeatedly applying (4)</span></span></code></pre></div>
<p>In this way the <code>Y</code>-combinator achieves recursion by reproducing a (self-reproducing) copy of the function’s self-application with each application of <code>(4)</code>.</p>
<p>This self-reproducing pattern becomes even more visible when looking at the graph-structure of the reduction of <code>(Y g)</code>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>                                            __</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  <span class="op">@</span>    <span class="op">==&gt;</span>    <span class="op">@</span>     <span class="op">==&gt;</span>   <span class="op">@</span>    <span class="op">==&gt;</span>  <span class="op">...</span>   <span class="op">@</span>   \</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a> <span class="op">/</span> \         <span class="op">/</span> \         <span class="op">/</span> \             <span class="op">/</span> \__<span class="op">/</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a><span class="dt">Y</span>   g       g   <span class="op">@</span>       g   <span class="op">@</span>           g</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>               <span class="op">/</span> \         <span class="op">/</span> \</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>              <span class="dt">Y</span>   g       g   <span class="op">@</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true"></a>                             <span class="op">/</span> \</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true"></a>                            <span class="dt">Y</span>   g</span></code></pre></div>
<p>One can see how at each application of <code>(4)</code> another copy of (Y g) is generated and incorporated into the graph as an argument of g.</p>
<p>The last step of the diagram shows that - in the graph - self-reproduction can be achieved by simply bending the argument pointer back to the application node.</p>
<p>This realization leads us to the following implementation of the Y-combinator:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>reduce <span class="dt">Y</span> (p1 <span class="op">:</span> _) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  (_YP <span class="op">:@:</span> gP) <span class="ot">&lt;-</span> readSTRef p1</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  writeSTRef p1 (gP <span class="op">:@:</span> p1)</span></code></pre></div>
<p>Using this implementation of the Y-combinator instead of the source level defined version <code>Y = λf.(λx.x x)(λx.f(x x))</code> reduces the execution time for <code>fact 10000</code> by a factor of about 250.</p>
<p>The <a href="https://github.com/thma/lambda-ski/blob/main/src/LambdaToSKI.hs">sourcecode for this section can be found here</a>.</p>
<h2 id="next-steps">Next steps</h2>
<p>Here are some ideas for possible future extensions and improvements.</p>
<ul>
<li>Extending this very basic setup to a fully working pogramming environment with a REPL</li>
<li>Implement direct and mutual recursion (i.e. <code>letrec</code>) for global function definitions</li>
<li>experimemnt with different bracket abstraction algorithms to improve object code size and execution time.</li>
<li>Implement bracket abstraction from λ-expressions to <a href="https://thma.github.io/posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html">closed cartesian categories</a> and extend the graph-reduction to also cover the resulting combinators <code>apply</code> and <code>(△)</code>.</li>
<li>extend the language to include lists, maybe even provide it with a LISPKIT frontend.</li>
<li>Add support for implicit and explicit parallelism of the graph-reduction engine. (implicit parallelism for strict operations, and an explicit <code>P</code>-combinator)</li>
</ul>
]]></summary>
</entry>
<entry>
    <title>λ-Calculus, Combinatory Logic and Cartesian Closed Categories</title>
    <link href="https://thma.github.io//posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html" />
    <id>https://thma.github.io//posts/2021-04-04-Lambda-Calculus-Combinatory-Logic-and-Cartesian-Closed-Categories.html</id>
    <published>2021-04-04T00:00:00Z</published>
    <updated>2021-04-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on April  4, 2021
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<h2 id="introduction">Introduction</h2>
<p>Recently I read the very interesting <a href="http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf">Compiling to Categories</a> paper by Conal Elliot.</p>
<p>He presents the idea to compile haskell programs into expressions of cartesian closed categories by λ-elimination. These expressions can then be used for different purposes like alternative program evaluation, graphic representation of program graphs, designing hardware layouts for algorithms, etc.</p>
<p>The λ-elimination process applied reminded me a lot of the <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">bracket abstraction</a> used when compiling λ-terms to SKI-Combinators.</p>
<p>In the following I’m having a closer look at the parallels between compiling lambda to CCC and compiling lambda to SKI-combinators</p>
<h2 id="lambda-calculus">Lambda Calculus</h2>
<p>I assume at least a rough familiarity with the λ-calculus. If you need a refresher I recommend <a href="http://dev.stephendiehl.com/fun/003_lambda_calculus.html">the chapter on λ-calculus in Stephen Diels excellent Write You a Haskell</a>.</p>
<p>Instead of the classical notation of lambda terms I’ll use the equivalent Haskell notation throughout this post. So instead of writing <code>λx.x a</code> I’ll write <code>\x -&gt; x a</code>.</p>
<h2 id="bracket-abstraction-in-combinatory-logic">Bracket Abstraction in Combinatory Logic</h2>
<blockquote>
<p>The SKI combinator calculus is a combinatory logic, a computational system that may be perceived as a reduced version of the untyped lambda calculus. It can be thought of as a computer programming language […] because it is an extremely simple Turing complete language. It was introduced by Moses Schönfinkel and Haskell Curry.</p>
<p>Quoted from <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">Wikipedia</a></p>
</blockquote>
<p>λ-terms can be converted to variable free SKI combinator terms with a process called <a href="https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis">bracket abstraction</a>. Bracket abstraction <code>absCL</code> is defined by the following equations (given in pseudo Haskell notation, as pattern matching on functions is not possible in Haskell):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>absCL (\x <span class="ot">-&gt;</span> x)   <span class="ot">=</span> i</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>absCL (\x <span class="ot">-&gt;</span> y)   <span class="ot">=</span> k y</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>absCL (\x <span class="ot">-&gt;</span> p q) <span class="ot">=</span> s (\x <span class="ot">-&gt;</span> p) (\x <span class="ot">-&gt;</span> q)</span></code></pre></div>
<p>where the combinators <code>i</code>, <code>k</code> and <code>s</code> are defined as follows (these are valid haskell definitions):</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">i ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>i x <span class="ot">=</span> x</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ot">k ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>k x y <span class="ot">=</span> x</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="ot">s ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>s p q x <span class="ot">=</span> p x (q x)  </span></code></pre></div>
<p>Please note that <code>i</code> is identical to <code>id</code> and <code>k</code> is identical to <code>const</code> from the Haskell Prelude.</p>
<p>Once the λ-terms are compiled to combinator terms, these terms can be interpreted quite efficiently as they don’t contain any variables and so no environment-handling is needed.</p>
<p>Combinator terms also allow to apply several more advanced interpretation techniques like graph-reduction, node-sharing, parallel reduction, etc.</p>
<p>For a very cool demo have a look at the <a href="https://crypto.stanford.edu/~blynn/lambda/sk.html">web assembly based graph reduction engine by Ben Lynn</a>.</p>
<h2 id="cartesian-closed-categories-ccc">Cartesian Closed Categories (CCC)</h2>
<p>In his famous paper <a href="http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf">Compiling to Categories</a> Conal Elliot describes a way to compile from simply typed lambda-calculus terms to cartesian closed categories(CCC).</p>
<p>At the core of his approach sits a transformation from lambda-terms to CCC expressions that are done by eliminating variables by an abstraction function <code>absCCC</code> (again in pseudo-Haskell):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>absCCC (\x <span class="ot">-&gt;</span> x)   <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>absCCC (\x <span class="ot">-&gt;</span> y)   <span class="ot">=</span> <span class="fu">const</span> y</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>absCCC (\x <span class="ot">-&gt;</span> p q) <span class="ot">=</span> apply <span class="op">.</span> ((\x <span class="ot">-&gt;</span> p) △ (\x <span class="ot">-&gt;</span> q))</span></code></pre></div>
<p>Where <code>(△)</code> is introduced by the <code>Cartesian</code> category:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">Cartesian</span> k <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  (△)<span class="ot"> ::</span> (a <span class="ot">`k`</span> c) <span class="ot">-&gt;</span> (a <span class="ot">`k`</span> d) <span class="ot">-&gt;</span> (a <span class="ot">`k`</span> (c, d))</span></code></pre></div>
<p>In the <code>(-&gt;)</code> instance of <code>Cartesian</code> <code>(△)</code> is defined as:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(△)<span class="ot">::</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> (a, b)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>(f △ g) x <span class="ot">=</span> (f x, g x)</span></code></pre></div>
<p>And where <code>apply</code> is introduced by the <code>Closed</code> category:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Cartesian</span> k <span class="ot">=&gt;</span> <span class="dt">Closed</span> k <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">  apply ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">`k`</span> b</span></code></pre></div>
<p>In the <code>(-&gt;)</code> instance of <code>Closed</code> <code>apply</code> is defined as</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">apply ::</span> (a <span class="ot">-&gt;</span> b, a) <span class="ot">-&gt;</span> b</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>apply (f, x) <span class="ot">=</span> f x</span></code></pre></div>
<p>The function <code>absCCC</code> looks surprisingly similar to the <code>absCL</code> function defined above. The first two pattern matches are obviously equivalent as <code>i</code> and <code>id</code> are identical as well as <code>k y</code> and <code>const y</code>.</p>
<p>But what about the third clause? We have:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- on the one hand: abstracting lambda-terms to combinator expresssions:</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>absCL (\x <span class="ot">-&gt;</span> p q) <span class="ot">=</span> s (\x <span class="ot">-&gt;</span> p) (\x <span class="ot">-&gt;</span> q)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="co">-- and on the other: abstracting lambda-terms to CCC expressions:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>absCCC (\x <span class="ot">-&gt;</span> p q) <span class="ot">=</span> apply <span class="op">.</span> ((\x <span class="ot">-&gt;</span> p) △ (\x <span class="ot">-&gt;</span> q))</span></code></pre></div>
<p>Are these two definitions equal?</p>
<p>By eliminating all variables from the term <code>apply . ((\x -&gt; p) △ (\x -&gt; q))</code> we can write it as a combinator <code>s'</code> with variables <code>p, q, x</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>s&#39; p q x <span class="ot">=</span> (apply <span class="op">.</span> (p △ q)) x</span></code></pre></div>
<p>Now we can apply equational reasoning:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>s&#39; p q x <span class="ot">=</span> (apply <span class="op">.</span> (p △ q)) x   </span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>         <span class="ot">=</span> apply ((p △ q) x)     <span class="co">-- by definition of (.)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>         <span class="ot">=</span> apply (p x, q x)      <span class="co">-- by definition of (△)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>         <span class="ot">=</span> (p x) (q x)           <span class="co">-- by definition of apply        </span></span></code></pre></div>
<p>This equals the definition of the <code>s</code> combinator:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>s p q x <span class="ot">=</span> (p x) (q x)</span></code></pre></div>
<p>So we can conclude that the transformations from λ-calculus to SKI-combinators and CCC are equivalent.</p>
<p>For me this was a new insight. But it seems that I was not the first to discover this: P.-L. Curien presents a much more elaborate proof of this correspondence in his classic paper <a href="https://core.ac.uk/download/pdf/82017242.pdf">Categorical Combinators</a>. See also <a href="http://pauillac.inria.fr/~huet/PUBLIC/cat.pdf">Cartesian Closed Categories and Lambda-Calculus</a>.</p>
<h2 id="nexts-steps">Nexts steps</h2>
<p>In my next blog post I will have a closer look at a CCC based execution model for a subset of Haskell.</p>
]]></summary>
</entry>
<entry>
    <title>Fuzzing me wrong — How QuickCheck destroyed my favourite theory</title>
    <link href="https://thma.github.io//posts/2021-01-30-How-QuickCheck-destroyed-my-favourite-theory.html" />
    <id>https://thma.github.io//posts/2021-01-30-How-QuickCheck-destroyed-my-favourite-theory.html</id>
    <published>2021-01-30T00:00:00Z</published>
    <updated>2021-01-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on January 30, 2021
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<h2 id="introduction">Introduction</h2>
<p>Quite a while back I wrote a larger article on the algebraic foundation of software patterns which also covered the <a href="https://thma.github.io/posts/2018-11-24-lambda-the-ultimate-pattern-factory.html#map-reduce">MapReduce algorithm</a>.</p>
<p>During the research digged out a paper on <a href="https://pdfs.semanticscholar.org/0498/3a1c0d6343e21129aaffca2a1b3eec419523.pdf">algebraic properties of distributed big data analytics</a>, which explained that a MapReduce will always work correctly when the intermediate data structure resulting from the <code>map</code>-phase is a Monoid under the <code>reduce</code>-operation.</p>
<p>For some reason, I was not convinced that this Monoid-condition was enough, because all the typical examples like word-frequency maps are even <strong>commutative</strong> Monoids under the respective reduce operation.</p>
<p>So I came up with the following personal theory:</p>
<blockquote>
<p>Only if the intermediate data structure resulting from the <code>map</code>-phase is a <strong>commutative Monoid</strong> under the <code>reduce</code>-operation, then a parallel MapReduce will produce correct results.</p>
</blockquote>
<p>I tried to validate this property using the <a href="https://wiki.haskell.org/Introduction_to_QuickCheck2">QuickCheck test framework</a>.</p>
<p>Interestingly the QuickCheck tests failed! This finally convinced me that my theory was wrong, and after a little deeper thought, I could understand why.</p>
<p>I was impressed with the power of QuickCheck, so I thought it would be a good idea to share this lesson in falsification.</p>
<p>The code shown in this blog <a href="https://github.com/thma/CommutativeMonoid">is also available on GitHub</a></p>
<h2 id="commutative-monoids">Commutative Monoids</h2>
<p>In abstract algebra, a monoid is a <em>set</em> equipped with an <em>associative binary operation</em> and an <em>identity element</em>.</p>
<p>The simplest example for a <em>commutative Monoid</em> is <span class="math inline">\((\mathbb{N}_0, +, 0)\)</span>: the natural numbers under addition with <span class="math inline">\(0\)</span> as the identity (or neutral) element. We can use QuickCheck to verify that indeed the Monoid laws plus commutativity are maintained.</p>
<p>If we want to use <code>GHC.Natural</code> type to represent natural numbers, we first have to make <code>Natural</code> instantiate the <code>Arbitrary</code> type class which is used by QuickCheck to automatically generate test data:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Test.QuickCheck</span> (<span class="dt">Arbitrary</span>, arbitrary, <span class="dt">NonNegative</span> (..))</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">GHC.Natural</span>     (<span class="dt">Natural</span>, naturalFromInteger)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Natural</span> <span class="kw">where</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    <span class="dt">NonNegative</span> nonNegative <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    <span class="fu">return</span> <span class="op">$</span> naturalFromInteger nonNegative</span></code></pre></div>
<p>Now we can start to write our property based tests. For algebraic structures it is straightforward to come up with properties: we just write the required laws (associativity, 0 is identity element and commutativity) as properties.</p>
<p>I am using Hspec as a wrapper around QuickCheck as it provides a very nice testing DSL which makes it easy to read the code and the output of the test suite:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Test.Hspec</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>spec <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  describe <span class="st">&quot;The Monoid &#39;Natural Numbers under Addition&#39;&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    it <span class="st">&quot;is associative&quot;</span> <span class="op">$</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>      property <span class="op">$</span> \x y z <span class="ot">-&gt;</span> ((x <span class="op">+</span> y) <span class="op">+</span> z) <span class="ot">`shouldBe`</span> ((x <span class="op">+</span> (y <span class="op">+</span> z))<span class="ot"> ::</span> <span class="dt">Natural</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>      </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>    it <span class="st">&quot;has 0 as left and right identity element&quot;</span> <span class="op">$</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>      property <span class="op">$</span> \x <span class="ot">-&gt;</span> (x <span class="op">+</span> <span class="dv">0</span> <span class="ot">`shouldBe`</span> (<span class="ot">x ::</span> <span class="dt">Natural</span>)) <span class="op">.&amp;&amp;.</span> (<span class="dv">0</span> <span class="op">+</span> x <span class="ot">`shouldBe`</span> x)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>      </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    it <span class="st">&quot;is commutative&quot;</span> <span class="op">$</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>      property <span class="op">$</span> \x y <span class="ot">-&gt;</span> x <span class="op">+</span> y <span class="ot">`shouldBe`</span> (y <span class="op">+</span><span class="ot"> x ::</span> <span class="dt">Natural</span>)</span></code></pre></div>
<p>The output of these tests will be as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ex">Monoid</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="ex">The</span> Monoid <span class="st">&#39;Natural Numbers under Addition&#39;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="ex">is</span> associative</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>    <span class="ex">has</span> 0 as identity (or neutral) <span class="ex">element</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="ex">is</span> commutative</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>So behind the scenes, QuickCheck has generated test data for 100 tests for each property under test. For all these data the test cases passed.</p>
<p>This is definitely not a proof. But it gives us some confidence that our math text-books are correct when giving Natural Numbers under addition as an example for a commutative Monoid.</p>
<p>OK, that was easy! Now let’s move to non-commutative Monoids.</p>
<h2 id="non-commutative-monoids">Non-commutative Monoids</h2>
<p>Strings (or any other Lists) under concatenation are a typical example. It’s easy to see that <code>"hello" ++ ("dear" ++ "people")</code> equals <code>"(hello" ++ "dear") ++ "people"</code>, but that <code>"hello" ++ "world"</code> differs from <code>"world" ++ "hello"</code>.</p>
<p>Now let’s try to formalize these intuitions as QuickCheck property based tests again.</p>
<p>First I’m introducing an alias for <code>(++)</code>, as it is defined on any list type, it would be required to have type signatures in all properties (as we had all those <code>:: Natural</code> signatures in the examples above). So I define an operation <code>(⊕)</code> which is only defined on <code>String</code> instances:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>(⊕)<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>(⊕) a b <span class="ot">=</span> a <span class="op">++</span> b</span></code></pre></div>
<p>Now we can extend our test suite with the following test cases:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>  describe <span class="st">&quot;The Monoid &#39;Strings under concatenation&#39;&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>    </span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>    it <span class="st">&quot;is associative&quot;</span> <span class="op">$</span> </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>      property <span class="op">$</span> \x y z <span class="ot">-&gt;</span> ((x ⊕ y) ⊕ z) <span class="ot">`shouldBe`</span> (x ⊕ (y ⊕ z))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>      </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    it <span class="st">&quot;has \&quot;\&quot; as left and right identity element&quot;</span> <span class="op">$</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>      property <span class="op">$</span> \x <span class="ot">-&gt;</span> (x ⊕ <span class="st">&quot;&quot;</span> <span class="ot">`shouldBe`</span> x) <span class="op">.&amp;&amp;.</span> (<span class="st">&quot;&quot;</span> ⊕ x <span class="ot">`shouldBe`</span> x)</span></code></pre></div>
<p>The output looks promising:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>  <span class="ex">The</span> Monoid <span class="st">&#39;Strings under concatenation&#39;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    <span class="ex">is</span> associative</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    <span class="ex">has</span> <span class="st">&quot;&quot;</span> as left and right identity element</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span></code></pre></div>
<p>Now let’s try to test the non-commutativity:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>    it <span class="st">&quot;is NOT commutative&quot;</span> <span class="op">$</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>      property <span class="op">$</span> \x y <span class="ot">-&gt;</span> x ⊕ y <span class="ot">`shouldNotBe`</span> y ⊕ x</span></code></pre></div>
<p>But unfortunately the output tells us that this is not true:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>    <span class="ex">is</span> NOT commutative FAILED [1]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="ex">1</span>) <span class="ex">Monoid</span>, The Monoid <span class="st">&#39;Strings under concatenation&#39;</span>, is NOT commutative</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>       <span class="ex">Falsifiable</span> (after 1 test)<span class="bu">:</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>         <span class="st">&quot;&quot;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>         <span class="st">&quot;&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>       <span class="ex">not</span> expected: <span class="st">&quot;&quot;</span></span></code></pre></div>
<p>We formulated the property in the wrong way. The <code>(⊕)</code> <em>may be commutative for some</em> edge cases, e.g. when one or both of the arguments are <code>""</code>. But it is not commutative <em>in general</em> – that is for all possible arguments.</p>
<p>We could rephrase this property as <em>“There exists at least one pair of arguments <span class="math inline">\((x, y)\)</span> for which <span class="math inline">\(\oplus\)</span> is not commutative”</em>:</p>
<p><span class="math display">\[\exists (x,y) \left [  x \oplus y \neq y \oplus x \right ]\]</span></p>
<p>QuickCheck does not come with a mechanism for <em>existential quantification</em>. But as is has <code>forAll</code>, that is <em>universal quantification</em>. So we can try to make use of the following equivalence:</p>
<p><span class="math display">\[\exists (x,y) \left [  x \oplus y \neq y \oplus x \right ] 
  \equiv 
  \neg \forall (x,y) \left [ x \oplus y = y \oplus x \right ]\]</span></p>
<p>Unfortunately we can not write this simply as <code>not forAll</code>, as <code>forAll</code> returns a <code>Property</code> but <code>not</code> expects a <code>Bool</code>. But as explained in <a href="https://stackoverflow.com/questions/42764847/is-there-a-there-exists-quantifier-in-quickcheck">this discussion on Stackoverflow</a> it is still posible to implement our own <code>exists</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">exists ::</span> (<span class="dt">Show</span> a, <span class="dt">Arbitrary</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>exists <span class="ot">=</span> forSome <span class="op">$</span> resize <span class="dv">1000</span> arbitrary</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="ot">forSome ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> prop) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> prop) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>forSome gen prop <span class="ot">=</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>  mapResult (\r <span class="ot">-&gt;</span> r {P.reason <span class="ot">=</span> <span class="st">&quot;No witness found.&quot;</span>, P.callbacks <span class="ot">=</span> []}) <span class="op">$</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>    once <span class="op">$</span> disjoin <span class="op">$</span> <span class="fu">replicate</span> <span class="dv">1000</span> <span class="op">$</span> forAll gen prop</span></code></pre></div>
<p>Now we can rewrite the property <span class="math inline">\(\exists (x,y) \left [ x \oplus y \neq y \oplus x \right ]\)</span> as follows:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>    it <span class="st">&quot;is not commutative (via exists)&quot;</span> <span class="op">$</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>      exists <span class="op">$</span> \(x,y) <span class="ot">-&gt;</span> x ⊕ y <span class="op">/=</span> y ⊕ x</span></code></pre></div>
<p>I like how close the Haskell code stays to the concise mathematical formulation! The output of this test fits much better into our intuitive understanding:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>    <span class="ex">is</span> not commutative (via exists)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>      <span class="ex">+++</span> OK, passed 1 test.</span></code></pre></div>
<h2 id="sequential-mapreduce">Sequential MapReduce</h2>
<blockquote>
<p>MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify <strong>a map function</strong> that processes a key/value pair to generate a set of intermediate key/value pairs, <strong>and a reduce function</strong> that merges all intermediate values associated with the same intermediate key.</p>
<p>[This] abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages. <a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/16cb30b4b92fd4989b8619a61752a2387c6dd474.pdf">Quoted from Google Research</a></p>
</blockquote>
<p>I’m not going into more details here, as You’ll find detailed information on this approach and a working example <a href="https://thma.github.io/posts/2018-11-24-lambda-the-ultimate-pattern-factory.html#map-reduce">in my original article</a>.</p>
<p>Here is the definition of a sequential MapReduce:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>simpleMapReduce </span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b)   <span class="co">-- map function</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> c) <span class="co">-- reduce function</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [a]        <span class="co">-- list to map over</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="ot">-&gt;</span> c          <span class="co">-- result</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>simpleMapReduce mapFunc reduceFunc <span class="ot">=</span> reduceFunc <span class="op">.</span> <span class="fu">map</span> mapFunc</span></code></pre></div>
<p>We can test the sequential MapReduce algorithm with the following property based test:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>    it <span class="st">&quot;works correctly with a sequential map-reduce&quot;</span> <span class="op">$</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>      property <span class="op">$</span> \a b c d <span class="ot">-&gt;</span> (simpleMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) [a,b,c,d]) </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>                     <span class="ot">`shouldBe`</span> (<span class="fu">reverse</span> a) ⊕ (<span class="fu">reverse</span> b) ⊕ (<span class="fu">reverse</span> c) ⊕ (<span class="fu">reverse</span> d)</span></code></pre></div>
<h3 id="excurs-foldmap">Excurs: foldMap</h3>
<p>What I have shown so far just demonstrates the general mechanism of chaining <code>map</code> and <code>reduce</code> functions without implying any parallel execution. Essentially we are chaining a <code>map</code> with a <code>fold</code> (i.e. reduction) function. In the Haskell base library there is a higher order function <code>foldMap</code> that covers exactly this pattern of chaining. Please note that <code>foldMap</code>does only a single traversal of the foldable data structure. It fuses the <code>map</code> and <code>reduce</code> phase into a single one by function composition of <code>mappend</code> and the mapping function <code>f</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">-- | Map each element of the structure to a monoid,</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="co">-- and combine the results.</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="fu">foldMap</span><span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monoid</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="fu">foldMap</span> f <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">mappend</span> <span class="op">.</span> f) <span class="fu">mempty</span></span></code></pre></div>
<h2 id="parallel-mapreduce">Parallel MapReduce</h2>
<p>Now we come to the tricky part that kicked off this whole discussion: parallelism.</p>
<p>As an example we consider a simple sequential MapReduce, taking an input list of <code>Int</code>s, computing their squares and computing the sum of these squares:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> simpleMapReduce (<span class="op">^</span><span class="dv">2</span>) (<span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a><span class="dv">30</span></span></code></pre></div>
<p>Let’s try to design this as a massively parallelized algorithm:</p>
<ol type="1">
<li><p>Mapping of <code>(^2)</code> over the input-list <code>[1,2,3,4]</code> would be started in parallel to the reduction of the intermediary list of squares by <code>(foldr (+) 0)</code>.</p></li>
<li><p>The mapping phase will be executed as a set of parallel computations (one for each element of the input list).</p></li>
<li><p>The reduction phase will also be executed as a set of parallel computations (one for each addition).</p></li>
</ol>
<p>Of course the reduction phase can begin only when at least one list element is squared. So in effect the mapping process would have to start first. The parallel computation of squares will result in a non-deterministic sequence of computations. In particular it is not guaranteed that all elements of the input list are processed in the original list order. So it might for example happen that <code>3</code> is squared first. Now the reduction phase would receive it’s first input <code>9</code>, and would start reduction, that is compute <code>9 + 0</code>.</p>
<p>Let’s assume the following random sequence of mapping steps: Next the first element of the input <code>1</code>, then the fourth <code>4</code> and finally the second element <code>2</code> would be squared, resulting in a reduction sequence of <code>4 + 16 + 1 + 9 + 0</code>. As this sums up to <code>30</code> everything is fine. Addition is commutative, so changing the sequence of reduction steps does not affect the overall result.</p>
<p>But now imagine we would parallelize:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>λ<span class="op">&gt;</span> simpleMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) [<span class="st">&quot; olleh&quot;</span>,<span class="st">&quot; ym&quot;</span>,<span class="st">&quot; raed&quot;</span>,<span class="st">&quot; sklof&quot;</span>]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="st">&quot;hello my dear folks &quot;</span></span></code></pre></div>
<p>If we assume the same sequence as above, the third element of the input list would be reversed first, resulting in a first reduction step <code>"dear " ⊕ ""</code>. Next the first, the fourth and finally the second element would be reversed, resulting in a reduction sequence of <code>"my " ⊕ "folks " ⊕ "hello " ⊕ "dear " ⊕ "" = "my folks hello dear "</code>. As string concatenation is not commutative it does not really come as a surprise that random changes to the reduction sequence will eventually result in wrong computations.</p>
<p>So our conclusion is:</p>
<blockquote>
<p>If the MapReduce algorithm is parallelized in the way that I outlined above — which may result in random changes of the order of list elements in the reduction phase — it will only work correct if the intermediary data structure is a <em>commutative</em> Monoid under the reduce operation.</p>
</blockquote>
<p>In the following section we will implement a parallel MapReduce in Haskell in order to validate our theory with property based testing.</p>
<h2 id="parallel-mapreduce-in-haskell">Parallel MapReduce in Haskell</h2>
<p>We can define a parallel MapReduce implementation as follows (for more details see <a href="http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html">Real World Haskell, Chapter 24</a>):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Parallel</span> (par)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Parallel.Strategies</span> (using, parMap, rpar)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>parMapReduce </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b)   <span class="co">-- map function</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> c) <span class="co">-- reduce function</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [a]        <span class="co">-- list to map over</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="ot">-&gt;</span> c          <span class="co">-- result</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>parMapReduce mapFunc reduceFunc input <span class="ot">=</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>    mapResult <span class="ot">`par`</span> reduceResult</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true"></a>    <span class="kw">where</span> mapResult    <span class="ot">=</span> parMap rpar mapFunc input</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true"></a>          reduceResult <span class="ot">=</span> reduceFunc mapResult <span class="ot">`using`</span> rpar</span></code></pre></div>
<p>This implementation will start computing <code>mapResult</code> and <code>reduceResult</code> in parallel and finally return <code>reduceResult</code>. The <code>mapResult</code> is computed with a parallelized <code>map</code> function <code>parMap</code>. The <code>reduceResult</code> is computed by applying a parallel reduction strategy <code>rpar</code>.</p>
<p>Next we will write a property based test to valdate our theory:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>    it <span class="st">&quot;has some cases where parallel reduction deviates from sequential reduction&quot;</span> <span class="op">$</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>      exists <span class="op">$</span> \text <span class="ot">-&gt;</span> parMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) text</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>                <span class="op">/=</span> simpleMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) text</span></code></pre></div>
<p>But it turns out that QuickCheck does not find any evidence for this assumption:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>    <span class="ex">has</span> some cases where parallel reduction deviates from sequential reduction FAILED [1]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="ex">Failures</span>:</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  <span class="bu">test</span>\MonoidSpec.hs:69:5: </span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  <span class="ex">1</span>) <span class="ex">Monoid</span>, The Monoid <span class="st">&#39;Strings under concatenation&#39;</span>, has some cases where parallel reduction deviates from sequential reduction</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>       <span class="ex">***</span> Failed! No witness found. (after 1 test)<span class="bu">:</span></span></code></pre></div>
<p>After seeing this result I had to deal with some growing cognitive dissonance, much like <a href="https://www.youtube.com/watch?v=EBtx1MDi5tY">a flat earther confronted with experimental evidence…</a></p>
<p>I began verifying my setup. I made sure that the <code>package.yaml</code> contains the right GHC options to provide parallel execution of the test suite:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="at">    </span><span class="fu">ghc-options</span><span class="kw">:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> -O2</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> -threaded</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> -rtsopts</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> -eventlog</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true"></a><span class="at">    </span><span class="kw">-</span><span class="at"> -with-rtsopts=-N</span></span></code></pre></div>
<p>I also made sure that all cores of my CPU were actually running at 100% utilization during the parallel tests.</p>
<p>I also inspected the runtime behaviour with the amazing <a href="https://wiki.haskell.org/ThreadScope">ThreadScope tool</a> (A ThreadScope eventlog can be produced by adding the runtime flags <code>+RTS -ls -N</code> when executing an application).</p>
<p>I also increased the number of test executions to give better chances to hit any rare cases.</p>
<p>But to no avail.</p>
<p>Since QuickCheck kept telling me, “You’re wrong,” I finally started to admit, “Well, maybe I am <em>indeed</em> wrong and should take a closer look at the problem.”</p>
<h2 id="rethinking-parallel-evaluation-in-haskell">Rethinking parallel evaluation in Haskell</h2>
<p>Taking a closer look at the definition of the parallel MapReduce will allow us to better understand what’s actually going on:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Parallel</span> (par)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Control.Parallel.Strategies</span> (using, parMap, rpar)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>parMapReduce </span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b)   <span class="co">-- map function</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> c) <span class="co">-- reduce function</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="ot">-&gt;</span> [a]        <span class="co">-- list to map over</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>  <span class="ot">-&gt;</span> c          <span class="co">-- result</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>parMapReduce mapFunc reduceFunc input <span class="ot">=</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a>    mapResult <span class="ot">`par`</span> reduceResult</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>    <span class="kw">where</span> mapResult    <span class="ot">=</span> parMap rpar mapFunc input</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>          reduceResult <span class="ot">=</span> reduceFunc mapResult <span class="ot">`using`</span> rpar</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true"></a></span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true"></a><span class="co">-- and now an actual example usage:</span></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true"></a>x <span class="ot">=</span> parMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) [<span class="st">&quot; olleh&quot;</span>,<span class="st">&quot; ym&quot;</span>,<span class="st">&quot; raed&quot;</span>,<span class="st">&quot; sklof&quot;</span>]     </span></code></pre></div>
<p>In this concrete example <code>mapResult</code> will be:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>mapResult    <span class="ot">=</span> parMap rpar <span class="fu">reverse</span> [<span class="st">&quot; olleh&quot;</span>,<span class="st">&quot; ym&quot;</span>,<span class="st">&quot; raed&quot;</span>,<span class="st">&quot; sklof&quot;</span>]</span></code></pre></div>
<p>parMap is defined as follows:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="ot">parMap ::</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>parMap strat f <span class="ot">=</span> (<span class="ot">`using`</span> parList strat) <span class="op">.</span> <span class="fu">map</span> f</span></code></pre></div>
<p>The <code>parMap</code> evaluation strategy will spark a parallel evaluation for each element of the <code>input</code> list. Nevertheless the actual order of elements will not be changed as internally the classical sequential <code>map</code> function is used which will not change the order of elements. So the reduce phase will never receive a changed order of elements from the map phase, even if <code>map</code>-computations for the individual list elements might be executed in random order!</p>
<p><code>mapResult</code> will always be <code>["hello", "my ", "dear ", "folks"]</code>.</p>
<p>Thus <code>reduceResult</code> will be:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>reduceResult <span class="ot">=</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) [<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;my &quot;</span>, <span class="st">&quot;dear &quot;</span>, <span class="st">&quot;folks&quot;</span>] <span class="ot">`using`</span> rpar</span></code></pre></div>
<p>Again the traditional semantics of <code>foldr</code> is maintained — in particular the order of arguments of all <code>(⊕)</code> operations, only we allow for parallel evaluation of those <code>(⊕)</code> operations during the reduction phase.</p>
<p>So the final output will always be <code>"hello my dear folks"</code>. The parallelism introduced by the <code>Control.Parallel</code> package does not in any way change the semantics of pure functional programs as our example. This is exactly what the failed test cased kept telling me:</p>
<blockquote>
<p>There do not exist any cases where sequential and parallel MapReduce result in deviating results!</p>
</blockquote>
<p>We can again evaluate our improved theory with a QuickCheck test:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>    it <span class="st">&quot;parallel reduction always equals sequential reduction&quot;</span> <span class="op">$</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>      property <span class="op">$</span> \l <span class="ot">-&gt;</span> simpleMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) l</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a>                     <span class="ot">`shouldBe`</span> parMapReduce <span class="fu">reverse</span> (<span class="fu">foldr</span> (⊕) <span class="st">&quot;&quot;</span>) l</span></code></pre></div>
<p>And — not so surprisingly — this test succeeds!</p>
<p>If you want to know more about parallel evaluation in Haskell I highly recommend the exellent <a href="https://www.oreilly.com/library/view/parallel-and-concurrent/9781449335939/ch02.html">Parallel and Concurrent Programming in Haskell by Simon Marlow</a>.</p>
<h2 id="conclusions">Conclusions</h2>
<ol type="1">
<li><p>The parallelism as provided by the Haskell <code>Control.Parallel</code> package maintains the semantics of pure functional code and thus a parallel MapReduce maintains the same properties as its sequential counterpart. So a parallel MapReduce will still work correctly if the intermediate data structure resulting from the <code>map</code>-phase is just a <strong>Monoid</strong> — not necessarily a <em>commutative</em> Monoid.</p></li>
<li><p>Nevertheless there may be implementations that do not strictly maintain the original order of the input data during the <code>map</code>- and <code>reduce</code>-phases. With such implementations the intermediate data structure resulting from the <code>map</code>-phase must be a <strong>commutative Monoid</strong> under the <code>reduce</code>-operation to produce correct results.</p></li>
<li><p>Property based testing with QuickCheck is a powerful tool to verify assumptions about a given code-base. I really like using it as intended by <a href="https://en.wikipedia.org/wiki/Falsifiability">Karl Poppers Theory of Falsifiability</a>:</p>
<ul>
<li>Derive hypotheses from your theory which can be experimentally tested.</li>
<li>Perform experiments (property based tests) that test your hypotheses</li>
<li>If the experimental results contradict the hypotheses, the theory must be false.</li>
</ul></li>
</ol>
]]></summary>
</entry>
<entry>
    <title>What's awesome about functional programming</title>
    <link href="https://thma.github.io//posts/2021-01-17-Whats-awesome-about-functional-programming.html" />
    <id>https://thma.github.io//posts/2021-01-17-Whats-awesome-about-functional-programming.html</id>
    <published>2021-01-17T00:00:00Z</published>
    <updated>2021-01-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on January 17, 2021
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p>Some weeks ago I gave an introductory talk on functional programming at an in-house mini-conference where I tried to explain basic concepts of functional programming to a crowd of developers with their backgrounds mostly in imperative and OO languages.</p>
<p>Initially I had planned to present the contents of my <a href="https://thma.github.io/posts/2020-04-01-why-haskell-matters.html">Why Haskell Matters article</a> but that turned out impractical because of the time constraints of my talk.</p>
<p>So I prepared a condensed slide deck focussing on the more elementary sections, which worked quite well.</p>
<p>Recently I stumbled across <a href="https://github.com/gibiansky/IHaskell">IHaskell</a>, a Haskell kernel for the Jupyter Notebook platform. As I like the interactive approach of Jupyter notebooks quite a lot I transferred my presentation into the Jupyter notebook format.</p>
<p>As I’m quite happy with the result I’d like to make it available to a wider audience. I have prepared three different versions:</p>
<ol type="1">
<li><p>The notebook as rendered by <a href="https://nbviewer.jupyter.org/github/thma/IHaskellExperiments/blob/main/WhatsAwesomeAboutFunctionalProgramming.ipynb">nbviewer.jupyter.org</a>. Unfortunately it’s not interactive. But you won’t need a local Jupyter installation.</p></li>
<li><p>A <a href="/static/WhatsAwesomeAboutFunctionalProgramming.slides.html">reveal.js presentation</a> which I generated from the notebook. This version just needs a web-browser.</p></li>
<li><p>An Interactive version of the reveal.js slides hosted on Binder: <a href="https://mybinder.org/v2/gh/thma/IHaskellExperiments/HEAD?filepath=ihaskell_examples/WhatsAwesomeAboutFunctionalProgramming.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt="Binder" /></a> (Press ALT-r to start the presentation.) This version uses <a href="https://rise.readthedocs.io/en/stable/">RISE</a> to allow interactive notebook cells while still being in presentation mode. This version is based on a <a href="https://github.com/thma/IHaskellExperiments/blob/main/Dockerfile">Dockerfile</a> that adds the RISE extension to an <a href="https://hub.docker.com/r/crosscompass/ihaskell-notebook">ihaskell-notebook</a> docker image. This Dockerfile is then built and served by <a href="https://mybinder.org/">Binder</a>.</p></li>
</ol>
<p>If you intend to use IHaskell notebooks locally <a href="https://github.com/gibiansky/IHaskell#installation">Please follow this installation guide</a>.</p>
<p>Sourcecode of my IHaskell notebook and the dockerfile are hosted in <a href="https://github.com/thma/IHaskellExperiments">this github repo</a>.</p>
]]></summary>
</entry>
<entry>
    <title>Reconciling concepts from FP and OOP</title>
    <link href="https://thma.github.io//posts/2020-12-20-reconciling-fp-and-oop-concepts.html" />
    <id>https://thma.github.io//posts/2020-12-20-reconciling-fp-and-oop-concepts.html</id>
    <published>2020-12-20T00:00:00Z</published>
    <updated>2020-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on December 20, 2020
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p>This post is part of the <a href="https://adventofhaskell.com/">Advent of Haskell 2020 series</a>. Hence, I tried to keep the content easy and enjoyable but still present some food for thought!</p>
<p>Some time ago I came across an interesting post on the Clean-Coder-Blog, which kept me busy for weeks until I finally decided to write this article.</p>
<p>In his blog-post Uncle Bob tries to reconcile concepts from both Functional Programming and Object Oriented Programming by explaining that both approaches are not mutually exclusive but both provide useful principles that go very well together and in fact are complementary:</p>
<blockquote>
<p>In this blog I will make the case that while OO and FP are orthogonal, they are not mutually exclusive. That a good functional program can (and should) be object oriented. And that a good object oriented program can (and should) be functional.</p>
<p><a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">quoted from Uncle Bob’s Clean Coder Blog</a></p>
</blockquote>
<p>He begins his argument by reducing FP and OOP each to a single central guiding principle in order to contrast the essential features of these two approaches as clearly as possible:</p>
<h2 id="oop-condensed">OOP condensed</h2>
<p>He gives the following characterisation of OOP:</p>
<blockquote>
<p>The technique of using dynamic polymorphism to call functions without the source code of the caller depending upon the source code of the callee.</p>
</blockquote>
<p>With this short statement Uncle Bob points to the core of object orientation since its first incarnation in the Smalltalk language:</p>
<p>In an OO language a call of methods on a target object is dispatched based on the target object’s type, its <code>class</code>. So a method call <code>shape.draw()</code> may invoke different code based on the <code>class</code> of the actual shape object:</p>
<p>The code of the <code>draw</code> method of class <code>Rectangle</code> may be different from the code in <code>Circle.draw()</code>.</p>
<p>Client code will just call <code>shape.draw()</code>, not even knowing which actual <code>Shape</code> sub-class it’s working on. This kind of polymorphism provides a very useful decoupling of clients from the target objects by using the methods of the baseclass <code>Shape</code> as the API for all Objects inheriting <code>Shape</code>.</p>
<p>This mechanism allows to build elegant design like the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-View-Controller (MVC)</a> pattern which is at the core of Smalltalks GUI and which influenced many similar designs in other OO-languages.</p>
<blockquote>
<p>MVC is the seminal insight of the whole field of graphical user interfaces. I believe the MVC work was the first to <strong>describe</strong> and implement <strong>software constructs in terms of their responsibilities.</strong> I also believe that MVC was the first significant <strong>use of protocols to define components</strong> instead of using concrete implementations — each controller class had a certain set of messages it had to respond to, as did each view class, but otherwise there were no constraints on what they did and how they did it.</p>
<p><a href="http://wiki.c2.com/?ModelViewControllerHistory">quoted from the C2 Wiki</a></p>
</blockquote>
<p>This quote conveys two major achievements of OOP:</p>
<ol type="1">
<li>Decomposing software into separate components with distinct responsibilities</li>
<li>Using protocols - APIs or interfaces in todays lingo - to decouple those components and allow for varying implementations.</li>
</ol>
<p>It’s interesting to note that Uncle Bob does not consider Inheritance or Encapsulation to be the most important and central concepts in OOP.</p>
<h2 id="fp-boiled-down">FP boiled down</h2>
<p>Next he gives a very brief characterization of functional programming:</p>
<blockquote>
<p>Referential Transparency – no reassignment of values.</p>
<p><a href="https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html">quoted from Uncle Bob’s Clean Coder Blog</a></p>
</blockquote>
<p>Referential transparency is implying <strong>purity</strong> as explained in the following definition from Wikipedia:</p>
<blockquote>
<p>An expression is called <strong>referentially transparent if it can be replaced with its corresponding value</strong> (and vice-versa) without changing the program’s behavior. This <strong>requires that the expression be pure</strong>, that is to say <strong>the expression value must be the same for the same inputs</strong> and its <strong>evaluation must have no side effects</strong>.</p>
<p><a href="https://en.wikipedia.org/wiki/Referential_transparency">quoted from Wikipedia</a></p>
</blockquote>
<p>The second part of Uncle Bob’s statement may be implied by this definition, but I prefer to see it as separate yet closely related principle, namely <strong>immutability</strong>:</p>
<blockquote>
<p>In object-oriented and functional programming, an immutable object (unchangeable object) is an object whose <strong>state cannot be modified after it is created</strong>. […]</p>
<p><a href="https://en.wikipedia.org/wiki/Immutable_object">Quoted from Wikipedia</a></p>
</blockquote>
<h2 id="there-is-no-fp-vs-oop">There is no FP vs OOP</h2>
<p>After this dense characterization of the two programming paradigms Uncle Bob continues his arguments like follows:</p>
<p>The concepts of Polymorphism and Referential Transparency are orthogonal. You can have Polymorphism without Referential Transparency – and vice versa.</p>
<p>But orthogonality does not imply that both concepts are mutually exclusive. It is possible to have languages that support both Dynamic Polymorphism and Referential Transparency. It is not only possible, but even desirable to combine both concepts:</p>
<ol type="1">
<li><p>Dynamic Polymorphism is desirable as it allows building strongly decoupled designs:</p>
<blockquote>
<p>Dependencies can be inverted across architectural boundaries. They are testable using Mocks and Fakes and other kinds of Test Doubles. Modules can be modified without forcing changes to other modules. This makes such systems much easier to change and improve.</p>
<p>Uncle Bob</p>
</blockquote></li>
<li><p>Referential Transparency is desirable as it allows designs that are much easier to understand, to reason about, to change and to improve. It also allows designs that are much better suited for scalability and concurrency as the chances of race conditions etc. are drastically reduced.</p></li>
</ol>
<p>Uncle Bob concludes that Dynamic Polymorphism and Referential Transparency are both desirable as part of software systems:</p>
<blockquote>
<p>A system that is built on both OO and FP principles will <strong>maximize flexibility, maintainability, testability, simplicity, and robustness</strong>.</p>
<p>Uncle Bob</p>
</blockquote>
<p>In the following sections I will have a look at the Haskell language to see how the principles of Ad-hoc Polymorphism and Referential Transparency are covered in our favourite language.</p>
<h2 id="ad-hoc-polymorphism-and-referential-transparency-in-haskell">Ad-hoc Polymorphism and Referential Transparency in Haskell</h2>
<ol type="1">
<li><p><strong>Referential Transparency</strong></p>
<p>Haskell is one of the rare incarnations of a purely functional language. So it goes without saying that Referential Transparency, Purity and Immutability are a given in Haskell. Yes, there are things like <code>unsafePerformIO</code> or <code>IORef</code> but overall it’s very easy to write clean code in Haskell due to the strict separation of pure and impure code by making side effects directly visibly in functions type signatures.</p>
<p>Referential Transparency in Haskell is so much a given that it’s quite possible to apply equational reasoning to proof certain properties of Haskell programs. See for example the following <a href="https://thma.github.io/LambdaBlog/posts/2020-04-17-maybe-functor-law-proof.html">Proof of Functor laws for the Maybe type</a>. What’s remarkable here is that you can use the same language to write your code and to reason about it. This is not possible in languages that do not provide Referential Transparency and Immutability. To reason about programs in such languages you have to use external models like an abstract stack + register machine.</p></li>
<li><p><strong>Ad-hoc Polymorphism</strong></p>
<p>Being able to overload functions and operators with different implementations depending on the type of its arguments is called Ad-hoc Polymorphism. For example, the <code>+</code> operator does something entirely different when applied to floating-point values as compared to when applied to integers. In Haskell, this kind of polymorphism is achieved with type classes and class instances.</p>
<p>Haskell’s type classes are quite different from the classes in OOP languages. They have more in common with interfaces in that they specify a set of functions with their respective type signatures to be implemented by instance declarations.</p></li>
</ol>
<h2 id="a-short-case-study">A short case study</h2>
<p>In this section I’m showcasing how these two concepts are supported in Haskell and how they can be combined without sacrificing FP principles.</p>
<p>Let’s have a look at a simple example that is frequently used in introductions to OOP: a class hierarchy representing geometrical shapes. In a typical OO language, we would have an abstract base class <code>Shape</code> which specifies a set of methods, and concrete classes <code>Rect</code>, <code>Circle</code>, <code>Triangle</code>, etc. which would implement specific behaviour.</p>
<p>This simple class hierarchy is shown in the following UML diagram:</p>
<figure>
<img src="/img/classes.png" alt="" /><figcaption>Shape class hierarchy</figcaption>
</figure>
<p>In Haskell there is no inheritance between types. But with type classes we can specify an <em>interface</em> which must be implemented by concrete types that wish to instantiate the type class. So we start with a <code>Shape</code> type class:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- | The Shape type class. It defines four functions that all concrete Shape types must implement.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Shape</span> a <span class="kw">where</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="co">-- | render a Shape</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  draw   ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="co">-- | move a Shape by an x and y amount</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="ot">  move   ::</span> (<span class="dt">Double</span>,<span class="dt">Double</span>) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="co">-- | compute the area of a Shape</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="ot">  area   ::</span> a <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="co">-- | compute the circumference of a Shape</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a><span class="ot">  circum ::</span> a <span class="ot">-&gt;</span> <span class="dt">Double</span></span></code></pre></div>
<p>Any concrete type <code>a</code> instantiating <code>Shape</code> must implement the four functions <code>draw</code>, <code>move</code>, <code>area</code> and <code>circum</code>.</p>
<p>We start with a <code>Circle</code> type:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="co">-- | a circle defined by the centre point and a radius</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Circle</span> <span class="ot">=</span> <span class="dt">Circle</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="co">-- | a point in the two-dimensional plane</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Double</span> <span class="dt">Double</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="co">-- | making Circle an instance of Shape</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Shape</span> <span class="dt">Circle</span> <span class="kw">where</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  draw       (<span class="dt">Circle</span> centre radius) <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Circle [&quot;</span> <span class="op">++</span> <span class="fu">show</span> centre <span class="op">++</span> <span class="st">&quot;, &quot;</span> <span class="op">++</span> <span class="fu">show</span> radius <span class="op">++</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>  move (x,y) (<span class="dt">Circle</span> centre radius) <span class="ot">=</span> <span class="dt">Circle</span> (movePoint x y centre) radius</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>  area   (<span class="dt">Circle</span> _ r) <span class="ot">=</span> r <span class="op">^</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>  circum (<span class="dt">Circle</span> _ r) <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> r <span class="op">*</span> <span class="fu">pi</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a><span class="co">-- | move a Point by an x and y amount</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a><span class="ot">movePoint ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>movePoint x y (<span class="dt">Point</span> x_a y_a) <span class="ot">=</span> <span class="dt">Point</span> (x_a <span class="op">+</span> x) (y_a <span class="op">+</span> y)</span></code></pre></div>
<p>As you can see, I’m not going to implement any real graphical rendering in <code>draw</code> but simply printing out the coordinates of the centre point and the radius. But at least <code>area</code> and <code>circum</code> implement the well-known geometrical properties of a circle.</p>
<p>Following this approach it’s straightforward to implement data types <code>Rect</code> and <code>Triangle</code>. Let’s start with <code>Rect</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">-- | a rectangle defined by to points (bottom left and top right corners) </span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Rect</span> <span class="ot">=</span> <span class="dt">Rect</span> <span class="dt">Point</span> <span class="dt">Point</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co">-- | making Rect an instance of Shape</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Shape</span> <span class="dt">Rect</span> <span class="kw">where</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  draw       (<span class="dt">Rect</span> a b) <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Rectangle [&quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;, &quot;</span> <span class="op">++</span> <span class="fu">show</span> b <span class="op">++</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>  move (x,y) (<span class="dt">Rect</span> a b) <span class="ot">=</span> <span class="dt">Rect</span> a&#39; b&#39;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>      a&#39; <span class="ot">=</span> movePoint x y a</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>      b&#39; <span class="ot">=</span> movePoint x y b</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>  area rect   <span class="ot">=</span> width <span class="op">*</span> height</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>      (width, height) <span class="ot">=</span> widthAndHeight rect</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>  circum rect <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> (width <span class="op">+</span> height)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>      (width, height) <span class="ot">=</span> widthAndHeight rect</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a><span class="co">-- | computes the width and height of a rectangle, returns them as a tuple</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a><span class="ot">widthAndHeight ::</span> <span class="dt">Rect</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>widthAndHeight (<span class="dt">Rect</span> (<span class="dt">Point</span> x_a y_a) (<span class="dt">Point</span> x_b y_b)) <span class="ot">=</span> (<span class="fu">abs</span> (x_b <span class="op">-</span> x_a), <span class="fu">abs</span> (y_b <span class="op">-</span> y_a))</span></code></pre></div>
<p>There is nothing special here, we are just implementing the functions specified by the <code>Shape</code> type class in a most simple way.</p>
<p>On to <code>Triangle</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="co">-- | a triangle defined by three points</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Triangle</span> <span class="ot">=</span> <span class="dt">Triangle</span> <span class="dt">Point</span> <span class="dt">Point</span> <span class="dt">Point</span> <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="co">-- | making Triangle an instance of Shape</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Shape</span> <span class="dt">Triangle</span> <span class="kw">where</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>  draw       (<span class="dt">Triangle</span> a b c) <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Triangle [&quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;, &quot;</span> <span class="op">++</span> <span class="fu">show</span> b <span class="op">++</span> <span class="st">&quot;, &quot;</span> <span class="op">++</span> <span class="fu">show</span> c <span class="op">++</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  move (x,y) (<span class="dt">Triangle</span> a b c) <span class="ot">=</span> <span class="dt">Triangle</span> a&#39; b&#39; c&#39;</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>      a&#39; <span class="ot">=</span> movePoint x y a</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      b&#39; <span class="ot">=</span> movePoint x y b</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>      c&#39; <span class="ot">=</span> movePoint x y c</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>  area   triangle <span class="ot">=</span> <span class="fu">sqrt</span> (s <span class="op">*</span> (s <span class="op">-</span> a) <span class="op">*</span> (s <span class="op">-</span> b) <span class="op">*</span> (s <span class="op">-</span> c)) <span class="co">-- using Heron&#39;s formula</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true"></a>      s <span class="ot">=</span> <span class="fl">0.5</span> <span class="op">*</span> (a <span class="op">+</span> b <span class="op">+</span> c)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true"></a>      (a, b, c) <span class="ot">=</span> sides triangle</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true"></a>  circum triangle <span class="ot">=</span> a <span class="op">+</span> b <span class="op">+</span> c</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true"></a>      (a, b, c) <span class="ot">=</span> sides triangle</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true"></a><span class="co">-- | computing the length of all sides of a triangle, returns them as a triple</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true"></a><span class="ot">sides ::</span> <span class="dt">Triangle</span> <span class="ot">-&gt;</span> (<span class="dt">Double</span>, <span class="dt">Double</span>, <span class="dt">Double</span>)</span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true"></a>sides (<span class="dt">Triangle</span> x y z) <span class="ot">=</span> (distance x y, distance y z, distance x z)</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true"></a><span class="co">-- | compute the distance between two points</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true"></a><span class="ot">distance ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true"></a>distance (<span class="dt">Point</span> x_a y_a) (<span class="dt">Point</span> x_b y_b) <span class="ot">=</span> <span class="fu">sqrt</span> ((x_b <span class="op">-</span> x_a) <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> (y_b <span class="op">-</span> y_a) <span class="op">^</span> <span class="dv">2</span>)</span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true"></a><span class="co">-- | provide a more dense representation of a point</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Point</span> <span class="kw">where</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">Point</span> x y) <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot;,&quot;</span> <span class="op">++</span> <span class="fu">show</span> y <span class="op">++</span> <span class="st">&quot;)&quot;</span></span></code></pre></div>
<p>Let’s create three sample instances:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">rect ::</span> <span class="dt">Rect</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>rect <span class="ot">=</span> <span class="dt">Rect</span> (<span class="dt">Point</span> <span class="dv">0</span> <span class="dv">0</span>) (<span class="dt">Point</span> <span class="dv">5</span> <span class="dv">4</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="ot">circle ::</span> <span class="dt">Circle</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>circle <span class="ot">=</span> <span class="dt">Circle</span> (<span class="dt">Point</span> <span class="dv">4</span> <span class="dv">5</span>) <span class="dv">4</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a><span class="ot">triangle ::</span> <span class="dt">Triangle</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>triangle <span class="ot">=</span> <span class="dt">Triangle</span> (<span class="dt">Point</span> <span class="dv">0</span> <span class="dv">0</span>) (<span class="dt">Point</span> <span class="dv">4</span> <span class="dv">0</span>) (<span class="dt">Point</span> <span class="dv">4</span> <span class="dv">3</span>)</span></code></pre></div>
<p>Now we have all ingredients at hand for a little demo.</p>
<p>The type class <code>Shape</code> specifies a function <code>draw :: Shape a =&gt; a -&gt; IO ()</code>. This function is polymorphic in its argument: it will take an argument of any type <code>a</code> instantiating <code>Shape</code> and will perform an <code>IO ()</code> action, rendering the shape to the console in our case.</p>
<p>Let’s try it in GHCi:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="op">&gt;</span> draw circle</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="dt">Circle</span> [(<span class="fl">4.0</span>,<span class="fl">5.0</span>), <span class="fl">4.0</span>]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a><span class="op">&gt;</span> draw rect</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a><span class="dt">Rectangle</span> [(<span class="fl">0.0</span>,<span class="fl">0.0</span>), (<span class="fl">5.0</span>,<span class="fl">4.0</span>)]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="op">&gt;</span> draw triangle</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a><span class="dt">Triangle</span> [(<span class="fl">0.0</span>,<span class="fl">0.0</span>), (<span class="fl">4.0</span>,<span class="fl">0.0</span>), (<span class="fl">4.0</span>,<span class="fl">3.0</span>)]</span></code></pre></div>
<p>This code makes use of Haskell’s Ad-hoc polymorphism and elegantly fulfils the requirements given for Dynamic Polymorphism in Uncle Bob’s blog post: <em>“call functions without the source code of the caller depending upon the source code of the callee”</em>. On the call site, we just rely on the function <code>draw :: (Shape a) =&gt; a -&gt; IO ()</code>. This type signature assures us that it will work on any concrete type <code>a</code> that instantiates the <code>Shape</code> type class.</p>
<p>By making use of the reversed application operator <code>(&amp;)</code> we can create a more OOP look-and-feel to our code. Depending on the context it may be more convenient to write and read code using <code>(&amp;)</code> even when you are not after an OOP look-and-feel.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="op">&gt;</span> circle <span class="op">&amp;</span> draw</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="dt">Circle</span> [(<span class="fl">4.0</span>,<span class="fl">5.0</span>), <span class="fl">4.0</span>]</span></code></pre></div>
<p>We can use the <code>(&amp;)</code> operator to even work in a <strong>fluent api</strong> style:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  rect</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="op">&amp;</span> move (<span class="dv">4</span>,<span class="dv">2</span>)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="op">&amp;</span> draw</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  rect</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>    <span class="op">&amp;</span> draw</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a>  circle</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>    <span class="op">&amp;</span> move (<span class="dv">4</span>,<span class="dv">2</span>)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>    <span class="op">&amp;</span> draw</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  circle</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a>    <span class="op">&amp;</span> draw</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="co">-- and then in GHCi:</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a><span class="op">&gt;</span> main</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true"></a><span class="dt">Rectangle</span> [(<span class="fl">4.0</span>,<span class="fl">2.0</span>), (<span class="fl">9.0</span>,<span class="fl">6.0</span>)]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true"></a><span class="dt">Rectangle</span> [(<span class="fl">0.0</span>,<span class="fl">0.0</span>), (<span class="fl">5.0</span>,<span class="fl">4.0</span>)]</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true"></a><span class="dt">Circle</span> [(<span class="fl">8.0</span>,<span class="fl">7.0</span>), <span class="fl">4.0</span>]</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true"></a><span class="dt">Circle</span> [(<span class="fl">4.0</span>,<span class="fl">5.0</span>), <span class="fl">4.0</span>]</span></code></pre></div>
<p>In Haskell all values are immutable: printing the original shapes a second time demonstrates that operations like <code>move</code> are not destructive.</p>
<p>With this little setup we have shown that Haskell allows us to have both: Referential Transparency plus ad-hoc polymorphism. That is, we can use the essential elements of OOP and FP in one language. And: we are doing it all the time, as it’s quite <a href="https://www.haskell.org/tutorial/classes.html">common to use class types in this way.</a></p>
<h2 id="heterogeneous-collections">Heterogeneous collections</h2>
<p>In Haskell, container types like lists are polymorphic, but it is <strong>not</strong> possible to define a list like this:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">shapes ::</span> [<span class="dt">Shape</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>shapes <span class="ot">=</span> [circle,rect,triangle]</span></code></pre></div>
<p>because <strong>type classes are</strong> not types, but <strong>constraints on types</strong>.</p>
<p>So in haskell a list like <code>[circle,rect,triangle]</code> is considered to be heterogeneous, as the concrete types of all the elements differ.</p>
<p>There are <a href="https://wiki.haskell.org/Heterogenous_collections">several ways to have heterogeneous collections in Haskell</a>. I will demonstrate just one of them, which is based on <em>existential types</em>. (I have chosen this approach as it keeps the code easier to read and allows to add more <code>Shape</code> types whenever needed.</p>
<p>There is also a recent blog post on <a href="https://blog.sumtypeofway.com/posts/existential-haskell.html">Existential Haskell</a> which demonstrates some interesting use cases for existential types.</p>
<p>However, the <a href="https://github.com/thma/FPvsOO/blob/master/src/Lib.hs">sourcecode for this example</a> also demonstrates a solution based on a simple sum type.)</p>
<p>Once we activate the <code>ExistentialQuantification</code> language extension, we can define a data type <code>ShapeType</code> with a single constructor <code>MkShape</code> that will take any instance of a concrete type instantiating the <code>Shape</code> type class:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ShapeType</span> <span class="ot">=</span> <span class="kw">forall</span> a <span class="op">.</span> (<span class="dt">Show</span> a, <span class="dt">Shape</span> a) <span class="ot">=&gt;</span> <span class="dt">MkShape</span> a</span></code></pre></div>
<p>Now we can make <code>ShapeType</code> an instance of <code>Shape</code> which will delegate all function calls to the wrapped types:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Shape</span> <span class="dt">ShapeType</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  area     (<span class="dt">MkShape</span> s) <span class="ot">=</span> area s</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  circum   (<span class="dt">MkShape</span> s) <span class="ot">=</span> circum s</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  draw     (<span class="dt">MkShape</span> s) <span class="ot">=</span> draw s</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  move vec (<span class="dt">MkShape</span> s) <span class="ot">=</span> <span class="dt">MkShape</span> (move vec s)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a><span class="co">-- we also have to manually derive a Show instance as auto deriving is not possible on the existential type</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ShapeType</span> <span class="kw">where</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  <span class="fu">show</span> (<span class="dt">MkShape</span> s) <span class="ot">=</span> <span class="fu">show</span> s</span></code></pre></div>
<p>With this setup we can define a list of shapes as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="ot">shapes ::</span> [<span class="dt">ShapeType</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>shapes <span class="ot">=</span> [<span class="dt">MkShape</span> rect, <span class="dt">MkShape</span> circle, <span class="dt">MkShape</span> triangle]</span></code></pre></div>
<p>Finally, we are able to use this list just as any other:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> area shapes</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> circum shapes</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> (move (<span class="dv">4</span>,<span class="dv">10</span>)) shapes</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;&quot;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>  <span class="fu">mapM_</span> draw shapes</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a><span class="co">-- and then in GHCi:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true"></a><span class="op">&gt;</span> main</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true"></a>[<span class="fl">20.0</span>,<span class="fl">50.26548245743669</span>,<span class="fl">6.0</span>]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true"></a>[<span class="fl">18.0</span>,<span class="fl">25.132741228718345</span>,<span class="fl">12.0</span>]</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true"></a>[<span class="dt">Rect</span> (<span class="fl">4.0</span>,<span class="fl">10.0</span>) (<span class="fl">9.0</span>,<span class="fl">14.0</span>),<span class="dt">Circle</span> (<span class="fl">8.0</span>,<span class="fl">15.0</span>) <span class="fl">4.0</span>,<span class="dt">Triangle</span> (<span class="fl">4.0</span>,<span class="fl">10.0</span>) (<span class="fl">8.0</span>,<span class="fl">10.0</span>) (<span class="fl">8.0</span>,<span class="fl">13.0</span>)]</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true"></a><span class="dt">Rectangle</span> [(<span class="fl">0.0</span>,<span class="fl">0.0</span>), (<span class="fl">5.0</span>,<span class="fl">4.0</span>)]</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true"></a><span class="dt">Circle</span> [(<span class="fl">4.0</span>,<span class="fl">5.0</span>), <span class="fl">4.0</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true"></a><span class="dt">Triangle</span> [(<span class="fl">0.0</span>,<span class="fl">0.0</span>), (<span class="fl">4.0</span>,<span class="fl">0.0</span>), (<span class="fl">4.0</span>,<span class="fl">3.0</span>)]</span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>In our short Demo we have seen that Haskell supports both Referential Transparency and Polymorphism. We have also seen that the reversed application operator <code>(&amp;)</code> allows us to structure code in a way that even has some kind of OOP look-and-feel while remaining purely functional.</p>
<p>If we follow Uncle Bob’s argumentation to view Polymorphism to be the central concept of OOP (and in consequence regard other important OO features like Inheritance or Encapsulation as not so distinctive), we can conclude that Haskell is already well prepared to implement programs in the hybrid way proposed by him.</p>
<p>In fact, the benefits associated with this approach (flexibility, maintainability, testability, simplicity, and robustness) are typical key features of systems implemented in Haskell.</p>
<hr />
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to <a href="https://github.com/treeowl">David Feuer</a> for helping me with a stupid error in the existential type code!</p>
<p>Thanks to the <a href="https://adventofhaskell.com/">Advent Of Haskell 2020 team</a> for having this blog post in their advents calendar!</p>
]]></summary>
</entry>
<entry>
    <title>Using Hakyll with GitHub Pages has become even easier!</title>
    <link href="https://thma.github.io//posts/2020-11-15-using-hakyll-with-github-pages.html" />
    <id>https://thma.github.io//posts/2020-11-15-using-hakyll-with-github-pages.html</id>
    <published>2020-11-15T00:00:00Z</published>
    <updated>2020-11-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on November 15, 2020
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p>Over the weekend I’ve set up a <a href="https://jaspervdj.be/hakyll/">hakyll</a> powered blog on github pages (actually the one you are reading right now).</p>
<p>I’d like to share my findings, as I found an easier way to integrate Hakyll with GitHub Pages.</p>
<h2 id="the-documented-way">The documented way</h2>
<p>I followed the tutorial <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">Using Hakyll with GitHub Pages</a>. This tutorial assumes that the GitHub pages must always be served from the root folder of a github repository.</p>
<p>It then describes a way to achieve this by using a <code>develop</code> branch to do all the Hakyll work and finally writing the contents to the default <code>_site</code> folder. This folder is excluded from version control by entries in the <code>.gitignore</code> file both in the <code>develop</code> and <code>master</code> branches.</p>
<p>So to finally publish the generated site you’ll have to switch to the <code>master</code> branch and copy the contents of the <code>_site</code> folder to the root folder of your project.</p>
<p>I tried this approach and it works nicely.</p>
<p>But then I found out that GitHub pages also allows to use a <code>docs</code> folder as the document root of your GitHub Pages site.</p>
<p>This makes things significantly easier, as you can do all the necessary hakyll tasks and the final publishing on the same <code>master</code> branch.</p>
<h2 id="the-easier-way">The easier way</h2>
<h3 id="github-setup">GitHub setup</h3>
<ol type="1">
<li>If required, create a new GitHub repository for your blog.</li>
<li>If required, create a master branch.</li>
<li>in the Settings of your GitHub project define that the <code>/docs</code> folder from the <code>master</code> branch should be used as document-root of your site. Please refer to the <a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site#choosing-a-publishing-source">documentation</a> in case of problems.</li>
<li>Create a .gitignore file with at a minimum, the following entries:</li>
</ol>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ex">_cache/</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ex">.stack-work/</span></span></code></pre></div>
<h3 id="local-setup">Local setup</h3>
<p>If required, create a new Hakyll project. If you’re a stack user, there is a Hakyll template available that makes this step easy:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ex">stack</span> new myblog hakyll-template</span></code></pre></div>
<p>Create a .gitignore file in your blog’s directory with at a minimum, the same directories listed as in the GitHub repository. Use the following git commands to setup your local repository:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">git</span> init</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="co"># track all the source files for our blog.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="fu">git</span> add .</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="co"># make our first commit</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a><span class="fu">git</span> commit -m <span class="st">&quot;initial commit.&quot;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a><span class="co"># and add the GitHub repository as a remote.</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a><span class="fu">git</span> remote add origin <span class="op">&lt;</span>URL to your GitHub pages repository<span class="op">&gt;</span></span></code></pre></div>
<h3 id="modify-site.hs">Modify site.hs</h3>
<p>In order to make Hakyll generate the site into the <code>docs</code> folder we have to edit the Hakyll Main module (<code>site.hs</code> if you use the stack template) slightly:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">config ::</span> <span class="dt">Configuration</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>config <span class="ot">=</span> defaultConfiguration</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  { destinationDirectory <span class="ot">=</span> <span class="st">&quot;docs&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>  }</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>  hakyllWith config <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="op">...</span></span></code></pre></div>
<h3 id="deployment">Deployment</h3>
<p>So everything’s all setup, and we’re ready to deploy.</p>
<p>We need to be able to run the executable that generates the website, so we need to compile it first. If you are using stack, this can be done using:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ex">stack</span> build</span></code></pre></div>
<p>Next we get a clean build of our site:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ex">stack</span> exec myblog clean</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ex">stack</span> exec myblog build</span></code></pre></div>
<p>After this step you should see a folder <code>docs</code> under your projects root folder, which contains the generated Hakyll site.</p>
<p>Now we commit our changes:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">git</span> add -A</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">git</span> commit -m <span class="st">&quot;Publish.&quot;</span></span></code></pre></div>
<p>And send them to GitHub:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="fu">git</span> push origin master:master</span></code></pre></div>
<p>That’s all.</p>
<p>Now your Hakyll site should be visible under your GitHub Pages URL!</p>
<h2 id="view-the-source">View the source</h2>
<p>The source code for this blog post lies under my <a href="https://github.com/thma/thma.github.io">thma.github.io</a> GitHub project. I’ve adopted the composeconference css from <a href="http://katychuang.com/hakyll-cssgarden/gallery/">Katy Chuangs great Hakyll CSS Garden</a> and tweaked it a little bit to look more like GitHub markdown style and to provide some basic responsive design.</p>
<h2 id="update-nov.-24th-2020">Update Nov. 24th 2020</h2>
<p>The Hakyll project has just accepted my pull request for the Using Hakyll with GitHub Pages tutorial, which updates the text according to the findings presented in this post.</p>
<p>The amended version will thus be online shortly, rendering this blog entry kind of obsolete…</p>
]]></summary>
</entry>
<entry>
    <title>Implementing Clean Architecture with Haskell and Polysemy</title>
    <link href="https://thma.github.io//posts/2020-05-29-polysemy-clean-architecture.html" />
    <id>https://thma.github.io//posts/2020-05-29-polysemy-clean-architecture.html</id>
    <published>2020-05-29T00:00:00Z</published>
    <updated>2020-05-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on May 29, 2020
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p><a href="https://github.com/thma/PolysemyCleanArchitecture/actions"><img src="https://github.com/thma/PolysemyCleanArchitecture/workflows/Haskell%20CI/badge.svg" alt="Actions Status" /></a></p>
<h2 id="tldr">tl;dr</h2>
<p>This article shows how algebraic effect systems can be used to maintain a clear separation of concerns between different parts of software systems. From a practical programming perspective this improves composability and testability of software components.</p>
<p>I’m demonstrating this idea by using the Polysemy library to implement a multi-layered REST application conforming to the guidelines of the Clean Architecture model.</p>
<h2 id="motivation">Motivation</h2>
<p>While writing <a href="https://github.com/thma/WhyHaskellMatters#readme">Why Haskell Matters</a> I prepared a little demo application that was meant to showcase a cleanly designed REST application in Haskell. In particular, I wanted to demonstrate how the clear separation of <em>pure</em> and <em>impure</em> code helps to provide strict separation of concerns and state-of-the-art testability of all application layers.</p>
<p><strong>I failed!</strong></p>
<p>I was able to write the domain logic in <em>pure</em> code consisting only of <em>total</em> functions. It was a great pleasure to write unit tests for them!</p>
<p>However, as soon as I started writing controllers that coordinate access to the domain logic as well as to a persistence layer to retrieve and store data, I was stuck in the IO Monad. That is, in test cases I was not able to test the controllers independently of the concrete backend.</p>
<p>Then I tried to apply the <em>final tagless</em> pattern for the persistence layer. This allowed abstracting out the concrete persistence layer and writing controller tests with a mocked persistence backend. But when it came to testing the REST API handlers (written with Servant) I was again stuck in the IO Monad as the Handler type is defined as <code>newtype Handler a = Handler { runHandler' :: ExceptT ServerError IO a }</code>. Maybe it’s not a principle issue but just my brain being too small…</p>
<p>I was desperately looking for something that allowed me to combine different types of effects (like persistence, logging, configuration, http handlers, error handling, etc.) in controllers and handlers but still to be able to write tests that allow using mocks or stubs to test components in isolation.</p>
<p>As I reached a dead end, I had a look at some of the <em>algebraic effect systems</em> available in Haskell, like eff, extensible-effects, fused-effects, freer-simple and Polysemy.</p>
<p>In algebraic effect systems, effectful programs are split into two separate parts: the specification of the effects to be performed, and the interpretation (or semantics) given to them.</p>
<p>So my idea was to provide special effect interpretations that would allow building mocked effects for my test suite.</p>
<p>After seeing a <a href="https://youtu.be/kIwd1D9m1gE">presentation on maintainable software architecture with Polysemy</a> which answered many of my questions I rewrote my application based on Polysemy powered algebraic effects.</p>
<p>I’m pretty satisfied with the result, and of course I’m eager to share my approach with you!</p>
<h2 id="the-challenge">The Challenge</h2>
<p>A very small boutique restaurant (serving excellent vietnamese food) is looking for a reservation system that allows managing reservations. The restaurant has only twenty seats, they also take only a maximum of twenty reservations per day. (So guests can stay the whole evening and don’t have to leave after some time.) (I adopted this scenario from a inspiring <a href="https://youtu.be/US8QG9I1XW0">talk by Mark Seemann</a>)</p>
<p>They have asked us to write the REST backend for their reservation system.</p>
<p>The chef insists on a scrupulously clean kitchen and is also a lover of clean code. He has read about clean architecture and wants his new software to be a perfect example!</p>
<p>So we cannot just hack away but first have to understand what is expected from us when we are to deliver a clean architecture.</p>
<h2 id="what-makes-a-clean-architecture">What makes a Clean Architecture ?</h2>
<p>I’m following the introduction to clean architecture by Robert C. Martin on his <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Code blog</a>. He states that his concept builds up on several earlier approaches like <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">hexagonal architecture</a>, <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)">ports and adapters</a> or <a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/">Onion Architecture</a>.</p>
<p>According to him all these approaches share a similar objective: achieve separation of concerns by dividing a software system into different layers. All approaches result in system designs that share a common set of features:</p>
<ol type="1">
<li><p>The architecture does not depend on any specific software libraries or frameworks. This allows to freely choose such tools according to the actual needs. This avoids “vendor lock in”.</p></li>
<li><p>High testability. The business logic can be tested without any external element like UI, DB, Web Server, etc.</p></li>
<li><p>The UI is loosely coupled to the core system. So it can be easily changed or replaced without affecting the rest of the system.</p></li>
<li><p>The Database is also “external” to the core system. It can be easily changed (even from an RDBMS to NonSQL DB) without affecting the business logic.</p></li>
<li><p>The Business logic is agnostic of the outside world. It has no dependencies to any external systems like DB, ESB, etc.</p></li>
</ol>
<h3 id="layers-with-clearly-separated-responsibilities">Layers with clearly separated responsibilities</h3>
<p>The architecture consists of four layers, each of which contains components with a specific scope and a limited set of responsibilities.</p>
<ol type="1">
<li><p>At the centre sits the <strong>Domain</strong> layer consisting of entities and core business logic.</p></li>
<li><p>Next comes the <strong>Use Cases</strong> layer where all resources are coordinated that are required to fulfill a given use case. In particular, it uses entities and logic from the domain layer to implement use cases. But typically it must also interface to a persistent storage to retrieve and store entities.</p></li>
<li><p>The <strong>Interface Adapters</strong> layer holds code for UI controllers and presenters as well as adapters to external resources like databases, message queues, configuration, Logging, etc.</p></li>
<li><p>The <strong>External Interfaces</strong> layer contains the technical implementation of external interfaces. For example, a concrete REST service assembly, Web and UI infrastructure, databases, etc.</p></li>
</ol>
<h3 id="the-dependency-rule">The Dependency Rule</h3>
<blockquote>
<p>The overriding rule that makes this architecture work is The Dependency Rule. This rule says that source code dependencies can only point inwards. Nothing in an inner circle can know anything at all about something in an outer circle. In particular, the name of something declared in an outer circle must not be mentioned by the code in the an inner circle. That includes, functions, classes. variables, or any other named software entity.</p>
<p>Quoted from <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>This dependency rule leads to a very interesting consequence: If a use case interactor needs to access a component from an outer circle, e.g. retrieve data from a database, this must be done in a specific way in order to avoid breaking the dependency rule: In the use case layer we don’t have any knowledge about the components of the outer circles. <strong>If we require access to a database (or any other external resources), the call interface, as well as the data transfer protocol must be specified in the use case layer.</strong></p>
<p>The components in the outer circles will then implement this interface. Using this kind of interfaces, it is possible to communicate accross the layer boundaries, but still maintain a strict separation of concerns.</p>
<p>If you want to dive deeper into clean architecture I recommend the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a> as an entry point. Robert C. Martin later also published a whole book <a href="https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</a> on this concept.</p>
<p>In the following sections I’ll explain how the clean architecture guidelines can be implemented in a Haskell REST API application by making use of the algebraic effect library <a href="https://github.com/polysemy-research/polysemy#readme">Polysemy</a>.</p>
<h2 id="the-domain-layer">The Domain layer</h2>
<p>The <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/Domain/ReservationDomain.hs">ReservationDomain</a> module implements the business logic for seat reservations in a very small boutique restaurant. The restaurant has only one big table with 20 seats. Each day the restaurants accepts only 20 reservations. (There is no limited time-slot for each guest.)</p>
<p>Please note: - all functions in this module are <strong>pure</strong> (they don’t do any IO) and <strong>total</strong> (they produce defined results for all possible input values).</p>
<ul>
<li>The definitions in this module do not have dependencies to anything from the outer circles.</li>
</ul>
<p>At the core of our Domain lies the <code>Reservation</code> data type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">-- | a data type representing a reservation</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Reservation</span> <span class="ot">=</span> <span class="dt">Reservation</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    {<span class="ot"> date     ::</span> <span class="dt">Day</span>     <span class="co">-- ^ the date of the reservation</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    ,<span class="ot"> name     ::</span> <span class="dt">String</span>  <span class="co">-- ^ the name of the guest placing the reservation</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    ,<span class="ot"> email    ::</span> <span class="dt">String</span>  <span class="co">-- ^ the email address of the guest</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    ,<span class="ot"> quantity ::</span> <span class="dt">Natural</span> <span class="co">-- ^ how many seats are requested</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>    }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Generic</span>, <span class="dt">Read</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>This type can be used to express facts like <em>Mr. Miller reserved two seats on 2020-06-01, he can be reached via his email address: manfred@miller.com</em>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>reservation <span class="ot">=</span> <span class="dt">Reservation</span> {name <span class="ot">=</span> <span class="st">&quot;Mr. Miller&quot;</span>, quantity <span class="ot">=</span> <span class="dv">2</span>, date <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;2020-06-01&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;manfred@miller.com&quot;</span>}</span></code></pre></div>
<p>All reservations of a specific day are represented as a list of reservations: <code>[Reservation]</code>.</p>
<p>A <code>ReservationMap</code> is a map from <code>Day</code> to <code>[Reservation]</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">-- | a key value map holding a list of reservations for any given day</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ReservationMap</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Day</span> [<span class="dt">Reservation</span>]</span></code></pre></div>
<p>That is, we can keep track of all reservations by maintaining them in such a map:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>fromList </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  [</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    (</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>      <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>,</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>        [</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>          <span class="dt">Reservation</span> {date <span class="ot">=</span> <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>, name <span class="ot">=</span> <span class="st">&quot;Mr. Miller&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;manfred@miller.com&quot;</span>, quantity <span class="ot">=</span> <span class="dv">2</span>}, </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>          <span class="dt">Reservation</span> {date <span class="ot">=</span> <span class="dv">2020</span><span class="op">-</span><span class="dv">06</span><span class="op">-</span><span class="dv">01</span>, name <span class="ot">=</span> <span class="st">&quot;Andrew M. Jones&quot;</span>, email <span class="ot">=</span> <span class="st">&quot;amjones@example.com&quot;</span>, quantity <span class="ot">=</span> <span class="dv">4</span>}</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>        ]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>    )</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>Based on these data types we can define domain logic like computing the used capacity of a list of reservations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="co">-- | computes the number of reserved seats for a list of reservations</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">usedCapacity ::</span> [<span class="dt">Reservation</span>] <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>usedCapacity [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>usedCapacity (<span class="dt">Reservation</span> _ _ _ quantity <span class="op">:</span> rest) <span class="ot">=</span> quantity <span class="op">+</span> usedCapacity rest</span></code></pre></div>
<p>Based on this we can compute the number of available seats (given a maximum capacity and a list of reservations):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="co">-- | computes the number of available seats from a maximum capacity and a list of reservations.</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">availableSeats ::</span> <span class="dt">Natural</span><span class="ot">-&gt;</span> [<span class="dt">Reservation</span>] <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>availableSeats maxCapacity reservations <span class="ot">=</span> maxCapacity <span class="op">-</span> usedCapacity reservations</span></code></pre></div>
<p>The <code>Reservation</code> data type and some of the domain logic functions are depicted in the in the following diagram:</p>
<figure>
<img src="/img/domain.png" alt="" /><figcaption>The Domain layer</figcaption>
</figure>
<h3 id="testing">Testing</h3>
<p>As already mentioned: this layer has no knowledge of the world and it’s all pure code. Testing domain logic in isolation therefore is straight forward, as you can see from the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/DomainSpec.hs">DomainSpec</a> code.</p>
<p>The data types and functions of the domain layer can be used directly, without any mocking of components:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>day <span class="ot">=</span> fromGregorian <span class="dv">2020</span> <span class="dv">1</span> <span class="dv">29</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>res1 <span class="ot">=</span> <span class="dt">Reservation</span> day <span class="st">&quot;Andrew M. Jones&quot;</span> <span class="st">&quot;amjones@example.com&quot;</span> <span class="dv">4</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>res2 <span class="ot">=</span> <span class="dt">Reservation</span> day <span class="st">&quot;Thomas Miller&quot;</span> <span class="st">&quot;tm@example.com&quot;</span> <span class="dv">3</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>reservations <span class="ot">=</span> [res1, res2]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>totalCapacity <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>  describe <span class="st">&quot;Domain Logic&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true"></a>    it <span class="st">&quot;computes the used capacity for an empty list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true"></a>      usedCapacity [] <span class="ot">`shouldBe`</span> <span class="dv">0</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true"></a>    it <span class="st">&quot;computes the used capacity for a list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true"></a>      usedCapacity [res1, res2] <span class="ot">`shouldBe`</span> <span class="dv">7</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true"></a>      </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true"></a>    it <span class="st">&quot;computes the available seats for a list of reservations&quot;</span> <span class="op">$</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true"></a>      availableSeats totalCapacity [res1, res2] <span class="ot">`shouldBe`</span> <span class="dv">13</span></span></code></pre></div>
<h2 id="the-use-case-layer">The Use Case layer</h2>
<blockquote>
<p>The software in this layer contains application specific business rules. It encapsulates and implements all of the use cases of the system. These <strong>use cases orchestrate the flow of data to and from the entities, and direct those entities to use their enterprise wide business rules to achieve the goals of the use case.</strong></p>
<p>Quoted from the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>The module <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/UseCases/ReservationUseCase.hs">ReservationUseCase</a> specifies the available use cases for the reservation system. It coordinates access to Effects and the actual domain logic. The module exposes service functions that will be used by the REST API in the ExternalInterfaces layer.</p>
<p>Implemented Use Cases:</p>
<ol type="1">
<li><p>Display the number of available seats for a given day</p></li>
<li><p>Enter a reservation for a given day and keep it persistent. If the reservation can not be served as all seats are occupies provide a functional error message stating the issue.</p></li>
<li><p>Display the list of reservations for a given day.</p></li>
<li><p>Delete a given reservation from the system in case of a cancellation. NO functional error is required if the reservation is not present in the system.</p></li>
<li><p>Display a List of all reservation in the system.</p></li>
</ol>
<p>In the Use Case layer we have left the garden Eden of <em>world agnostic</em> code:</p>
<p>In order to compute the number of available seats for a given day, we will have to first look up the actual reservations for that day from a persistent storage, and only then can we call the domain function <code>availableSeats</code>. In addition we also will have to write a Log message when calling the functions to provide an audit trail.</p>
<p><strong>However, the dependency rule of clean architecture bans all direct access to a database or a logging-infrastructure from the use case layer!</strong></p>
<h3 id="how-can-we-define-such-a-use-case-without-violating-the-dependency-rule">How can we define such a use case without violating the dependency rule?</h3>
<p>Algebraic Effect systems offer a consistent answer: 1. We <strong>declare effects</strong> in the use case layer by defining them as an abstract interface.</p>
<ol start="2" type="1">
<li><p>We also specify the actual <strong>usage of effects</strong> in the use case layer by having calls against the abstract interface.</p></li>
<li><p>We provide an <strong>interpretation</strong> of these effects only in the outer layers. This also allows us to provide different implementations. So we can easily swap backends, e.g. migrating from MySQL to PostgreSQL, and it can be used to provide mock implementations for testing purposes.</p></li>
</ol>
<p>Let’s see how all this looks like when using Polysemy.</p>
<h3 id="usage-of-effects">Usage of effects</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="co">-- | compute the number of available seats for a given day. the result must be a natural number, incl. 0</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="ot">availableSeats ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">Natural</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>availableSeats day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;compute available seats for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  todaysReservations <span class="ot">&lt;-</span> fetch day</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> Dom.availableSeats maxCapacity todaysReservations</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a><span class="co">-- | fetch the list of reservations for a given day from the key value store.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a><span class="co">--   If no match is found, an empty list is returned.</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true"></a><span class="co">-- | the maximum capacity of the restaurant.</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true"></a><span class="ot">maxCapacity ::</span> <span class="dt">Natural</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true"></a>maxCapacity <span class="ot">=</span> <span class="dv">20</span></span></code></pre></div>
<p>The type signature of <code>availableSeats</code> contains two constraints on the <em>effect stack</em> type <code>r</code>: <code>(Member Persistence r, Member Trace r)</code> This means that the function may perform two different effects: persistence via the <code>Persistence</code> effect and Logging via the <code>Trace</code> effect.</p>
<p>The type signature also specifies that we need an input of type <code>Day</code> and will return the <code>Natural</code> result wrapped in the <code>Sem r</code> monad.</p>
<p>The <code>Sem</code> monad handles computations of arbitrary extensible effects. A value of type <code>Sem r</code> describes a program with the capabilities of the effect stack <code>r</code>.</p>
<p>The first step of the function body of <code>availableSeats</code> specifies a Log action based on the (Polysemy built-in) <code>Trace</code> effect:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;compute available seats for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span></code></pre></div>
<p>I repeat: <code>trace</code> does not directly do any logging. The actual logging action - the effect interpretation - will be defined in the application assembly or in a test setup.</p>
<p>The next line specifies a lookup of the reservation list for <code>day</code> from the persistence layer:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>  todaysReservations <span class="ot">&lt;-</span> fetch day</span></code></pre></div>
<p>where fetch is defined as:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span></code></pre></div>
<h3 id="declaration-of-effects">Declaration of effects</h3>
<p>To understand the <code>fetch</code> function, in particular the expression <code>maybeList &lt;- getKvs day</code> we first have to know the definition of the <code>Persistence</code> effect:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Persistence</span> <span class="ot">=</span> <span class="dt">KVS</span> <span class="dt">Day</span> [<span class="dt">Dom.Reservation</span>]</span></code></pre></div>
<p>Where KVS (standing for Key/Value Store) is a type that is also defined in the use case layer (<a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/UseCases/KVS.hs">KVS.hs</a>):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="co">-- | a key value store specified as a GADT</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">KVS</span> k v m a <span class="kw">where</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span><span class="ot"> ::</span> <span class="dt">KVS</span> k v m [(k, v)]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">GetKvs</span><span class="ot">     ::</span> k <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m (<span class="dt">Maybe</span> v)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>  <span class="dt">InsertKvs</span><span class="ot">  ::</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m ()</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span><span class="ot">  ::</span> k <span class="ot">-&gt;</span> <span class="dt">KVS</span> k v m ()</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;KVS</span></span></code></pre></div>
<p>The four operations of the key value store are defined in the GADT as type constructors. <code>makeSem ''KVS</code> then uses TemplateHaskell to generate effect functions (or smart Constructors) from the GADT definition. This call results in the definition of the following four functions that represent the specific operations of the key value store:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="ot">listAllKvs ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r [(k, v)]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="ot">getKvs     ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> v)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a><span class="ot">insertKvs  ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">deleteKvs  ::</span> <span class="dt">Member</span> (<span class="dt">KVS</span> k v) r <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span></code></pre></div>
<p>These functions can be used in the <code>Sem</code> Monad. So now we understand much better what is going on in <code>fetch</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">fetch ::</span> (<span class="dt">Member</span> <span class="dt">Persistence</span> r, <span class="dt">Member</span> <span class="dt">Trace</span> r) <span class="ot">=&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r [<span class="dt">Dom.Reservation</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>fetch day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;fetch reservations for &quot;</span> <span class="op">++</span> <span class="fu">show</span> day</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>  maybeList <span class="ot">&lt;-</span> getKvs day</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>  <span class="fu">return</span> <span class="op">$</span> fromMaybe [] maybeList</span></code></pre></div>
<p>As <code>fetch</code> operates in the <code>Sem</code> monad, <code>maybeList</code> is bound to a <code>Maybe [Dom.Reservation]</code> value, which results from the <code>getKVs day</code> action. The function finally uses <code>fromMaybe</code> to return a list of reservations that were retrieved (or <code>[]</code> in case <code>Nothing</code> was found for <code>day</code>).</p>
<p>Then, back in <code>availableSeats</code> we call the domain logic function <code>Dom.availableSeats</code> to compute the number of available seats. The resulting <code>Natural</code> value is lifted into the <code>Sem r</code> monad, thus matching the signature of the return type <code>Sem r Natural</code>.</p>
<p>In the next diagram I’m depicting the layers Use Cases and Domain. The arrow from Use Cases to Domain represents the dependency rule: use case code may only reference domain logic but the domain logic may not reference anything from the use case layer.</p>
<p>On the left side of the diagram we see the use case controllers (aka <em>use case interactors</em>) like <code>availableSeats</code> that coordinate all activities and resources to fulfill a specific use case.</p>
<p>On the right we see the gateway (or interface) code like the <code>KVS</code> abstraction of a key-value store or the <code>fetch</code> operation that wraps the access to the key-value store.</p>
<figure>
<img src="/img/use-cases.png" alt="" /><figcaption>Use Cases layer</figcaption>
</figure>
<h3 id="interpretation-of-effects-testing">Interpretation of effects / Testing</h3>
<p>The key value store functions like <code>getKvs</code> don’t perform any concrete operation. They just <code>declare</code> access to an abstract key-value store interface.</p>
<p>The concrete interpretation of these calls will be specified in the application assembly (typically in <code>Main.hs</code>) or in the setup code of test cases. If we provide a <em>pure</em> interpretation then the resulting code will also be pure. This allows writing tests in the same pure way as for the domain logic.</p>
<p>As an example, in <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/UseCasePureSpec.hs">UseCasePureSpec</a> I’m providing pure interpretations for all effects.</p>
<p>The <code>runPure</code> function takes a program with effects and handles each effect till it gets reduced to <code>Either ReservationError (ReservationMap‚ a)</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">runPure ::</span> <span class="dt">ReservationMap</span> </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>        <span class="ot">-&gt;</span> <span class="dt">Sem</span> &#39;[<span class="dt">UC.Persistence</span>, <span class="dt">State</span> <span class="dt">ReservationMap</span>, <span class="dt">Error</span> <span class="dt">UC.ReservationError</span>, <span class="dt">Trace</span>] a </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>        <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UC.ReservationError</span> (<span class="dt">ReservationMap</span>, a)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>runPure kvsMap program <span class="ot">=</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  program</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>     <span class="op">&amp;</span> runKvsPure kvsMap              <span class="co">-- run the key-value store on a simple ReservationMap</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>     <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">UC.ReservationError</span>  <span class="co">-- run error handling to produce an Either UC.ReservationError (ReservationMap, a)</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true"></a>     <span class="op">&amp;</span> ignoreTrace                    <span class="co">-- run Trace by simply ignoring all messages </span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true"></a>     <span class="op">&amp;</span> run                            <span class="co">-- run a &#39;Sem&#39; containing no effects as a pure value</span></span></code></pre></div>
<p>In addition to that I’m providing wrapping functions like <code>runAvailableSeats</code> that use <code>runPure</code> to interprete the effects of the use case functions (eg. <code>UC.availableSeats</code>) and extract the actual result from the <code>[Either UC.ReservationError (ReservationMap, a)]</code> return value:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="ot">runAvailableSeats ::</span> <span class="dt">ReservationMap</span> <span class="ot">-&gt;</span> <span class="dt">Day</span> <span class="ot">-&gt;</span> <span class="dt">Natural</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>runAvailableSeats kvsMap day <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="kw">case</span> runPure kvsMap (UC.availableSeats day) <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>    <span class="dt">Right</span> (_, numSeats) <span class="ot">-&gt;</span> numSeats</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>    <span class="dt">Left</span> err            <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;availableSeats failed&quot;</span></span></code></pre></div>
<p>This is all that it takes to abstract away persistence layer, logging facility and exception handling. We can now write tests in pure code:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="co">-- setting up test fixtures</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="ot">initReservations ::</span> <span class="dt">ReservationMap</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>initReservations <span class="ot">=</span> M.singleton day res</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>day <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;2020-05-02&quot;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>res <span class="ot">=</span> [<span class="dt">Reservation</span> day <span class="st">&quot;Andrew M. Jones&quot;</span> <span class="st">&quot;amjones@example.com&quot;</span> <span class="dv">4</span>]</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>  describe <span class="st">&quot;Reservation Use Case (only pure code)&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a>  </span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>    it <span class="st">&quot;computes the number of available seats for a given day&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a>      (runAvailableSeats initReservations day) <span class="ot">`shouldBe`</span> <span class="dv">16</span></span></code></pre></div>
<h2 id="the-interface-adapters-layer">The Interface Adapters layer</h2>
<p>This layer holds code for adapters to external resources like databases, message queues, configuration, Logging, etc.</p>
<p>The Logging effect <code>Trace</code> ships with Polysemy, so we don’t have to implement anything here. (Of course we could overzealously implement our own Graylog adapter here, Hingegen hat unser <code>reservationServer</code> eine Typensignatur but I leave this as an exercise for the reader… )</p>
<p>However, as the <code>KVS</code> type is our own invention we’ll have to provide our own implementations. (We could have used the <code>KVStore</code> type from <a href="https://hackage.haskell.org/package/polysemy-zoo-0.7.0.0/docs/Polysemy-KVStore.html">polysemy-zoo</a>, but for didactic purposes we will roll our own.)</p>
<p>The following code is the in-memory implementation from the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSInMemory.hs">KVSInMemory</a> module. It defines a key-value store in terms of <code>State (Map k v)</code> that is a <code>Map k v</code> in a <code>State</code> effect context:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">runKvsOnMapState ::</span> ( <span class="dt">Member</span> (<span class="dt">State</span> (<span class="dt">M.Map</span> k v)) r, <span class="dt">Ord</span> k) </span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>                 <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>                 <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>runKvsOnMapState <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span>    <span class="ot">-&gt;</span> <span class="fu">fmap</span> M.toList get</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true"></a>  <span class="dt">GetKvs</span> k      <span class="ot">-&gt;</span> <span class="fu">fmap</span> (M.lookup k) get</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true"></a>  <span class="dt">InsertKvs</span> k v <span class="ot">-&gt;</span> modify <span class="op">$</span> M.insert k v</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span> k   <span class="ot">-&gt;</span> modify <span class="op">$</span> M.delete k</span></code></pre></div>
<p>So whenever the <code>interpret</code> functions detects a <code>GetKvs k</code> value, that was constructed by a call to <code>getKvs k</code> in the use case layer, it pattern-matches it to a <code>Map</code> lookup of <code>k</code> that is executed against state retrieved by <code>get</code>.</p>
<p>Interestingly <code>get</code> is a smart constructor of the <code>State</code> effect. This means that by interpreting the <code>KVS</code> we have created new effects that in turn have to be interpreted.</p>
<p>The <code>runKvsPure</code> functions (which we already have seen in the use case testing) chains interpretation of the effects <code>KVS</code> and <code>State</code> and thus allows us to work with pure Maps as mocks for a key-value store:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="ot">runKvsPure ::</span> <span class="dt">Ord</span> k </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>           <span class="ot">=&gt;</span> <span class="dt">M.Map</span> k v</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>           <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> <span class="dt">State</span> (<span class="dt">M.Map</span> k v) <span class="op">:</span> r) a </span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a>           <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">M.Map</span> k v, a)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true"></a>runKvsPure <span class="fu">map</span> <span class="ot">=</span> runState <span class="fu">map</span> <span class="op">.</span> runKvsOnMapState</span></code></pre></div>
<h3 id="a-key-value-store-with-a-sqlite-backend.">A key-value store with a SQLite backend.</h3>
<p>As we are in the interface adapters layer, we are allowed to get our hands dirty with <em>real world code</em>, like database access. As an example I have provided a SQLite based interpretation of the <code>KVS</code> effect in <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSSqlite.hs">KVSSqllite.hs</a>.</p>
<p>The effect interpreting function is <code>runKvsAsSQLite</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="co">-- | Run a KVStore effect against a SQLite backend. Requires a Config object as input.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="ot">runKvsAsSQLite ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a>                   <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>                   <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>runKvsAsSQLite <span class="ot">=</span> interpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a>  <span class="dt">GetKvs</span> k      <span class="ot">-&gt;</span> getAction k</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  <span class="dt">ListAllKvs</span>    <span class="ot">-&gt;</span> listAction</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a>  <span class="dt">InsertKvs</span> k v <span class="ot">-&gt;</span> insertAction k v</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>  <span class="dt">DeleteKvs</span> k   <span class="ot">-&gt;</span> deleteAction k</span></code></pre></div>
<p>The function’s type signature introduces a two more constraints on the effect stack type <code>r</code>: <code>Member (Embed IO) r</code> and <code>Member (Input Config) r</code>. <code>(Embed IO)</code> is needed as accessing SQLite will require IO, which can be lifted into the <code>Sem r</code> monad with <code>Embed IO</code>.</p>
<p>SQLite always needs a file name to create a database connection. As we want to be able to keep this name configurable, we use the <code>(Input Config)</code> effect. <code>Config</code> is a data type that I created to represent global application configuration, including the database file name. <code>Input</code> is a Polysemy built-in effect which can provide input to an application, quite similar to a <code>Reader</code> monad.</p>
<p>These effects are introduced by the actual implementations of the <code>KVS</code> constructors, like <code>getAction k</code>, which retrieves a value from the database by looking up the key <code>k</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="ot">getAction ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> v)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>getAction key <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>  conn <span class="ot">&lt;-</span> connectionFrom input</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>  rows <span class="ot">&lt;-</span> embed (SQL.queryNamed conn</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>                      <span class="st">&quot;SELECT key, value FROM store WHERE key = :key&quot;</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>                      [<span class="st">&quot;:key&quot;</span> <span class="op">:=</span> <span class="fu">show</span> key]<span class="ot"> ::</span> <span class="dt">IO</span> [<span class="dt">KeyValueRow</span>])</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>  trace <span class="op">$</span> <span class="st">&quot;get: &quot;</span> <span class="op">++</span> <span class="fu">show</span> rows</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>  <span class="kw">case</span> rows <span class="kw">of</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    []                          <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>    (<span class="dt">KeyValueRow</span> _key value)<span class="op">:</span>xs <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> (decode <span class="op">.</span> encodeUtf8) value</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true"></a><span class="co">-- | create a connection based on configuration data, make sure table &quot;store&quot; exists.</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true"></a><span class="ot">connectionFrom ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r <span class="dt">SQL.Connection</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true"></a>connectionFrom c <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> c</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true"></a>  embed (getConnection (dbPath config))</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true"></a><span class="ot">      getConnection ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SQL.Connection</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true"></a>      getConnection dbFile <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true"></a>        conn <span class="ot">&lt;-</span> SQL.open dbFile</span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true"></a>        SQL.execute_ conn <span class="st">&quot;CREATE TABLE IF NOT EXISTS store (key TEXT PRIMARY KEY, value TEXT)&quot;</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true"></a>        <span class="fu">return</span> conn</span></code></pre></div>
<p>Let’s have a closer look at what is going on in <code>getAction</code>:</p>
<p>First <code>connectionFrom input</code> is used to create a database connection based on the <code>Config</code> object obtained by <code>input</code> (the smart Constructor of the <code>Input</code> effect). The <code>Config</code> type contains a field <code>dbPath</code> which is read and used to create the connection with <code>getConnection</code>. As this is an IO operation we have to use <code>embed</code> to lift it into the <code>Sem r</code> monad.</p>
<p>In the second step <code>SQL.queryNamed</code> is used to perform the actual select statement against the db connection. Again <code>embed</code> must be used to lift this IO operation.</p>
<p>Finally the resulting <code>[KeyValueRow]</code> list is pattern matched: if the list is empty <code>Nothing</code> is returned. Otherwise <code>Aeson.decode</code> is called to unmarshal a result value from the JSON data retrieved from the database.</p>
<p>The JSON encoding and decoding to and from the DB is the reason for the <code>ToJSON v, FromJSON v</code> constraints on the value type <code>v</code>.</p>
<p>This implementation is inspired by key-value store of <a href="https://haskell-explained.gitlab.io/blog/posts/2019/07/31/polysemy-is-cool-part-2/index.html">a password manager in Polysemy</a>.</p>
<h3 id="declaring-the-rest-api">Declaring the REST API</h3>
<p>Our task was to build the backend for the reservation system. We will have to implement a REST API to allow access to the business logic that we defined in the use case layer.</p>
<p>The overall idea is to provide a REST route for all exposed functions of the <code>ReservationUseCase</code>. The following table shows the mapping of those functions to the REST routes that we want to achieve:</p>
<pre><code>listAll        GET    /reservations
fetch          GET    /reservations/YYYY-MM-DD
tryReservation POST   /reservations
cancel         DELETE /reservations
availableSeats GET    /seats/YYYY-MM-DD</code></pre>
<p>I’m using <a href="http://www.servant.dev/">Servant</a> to define our REST API. The great thing about Servant is that it allows us to define REST APIs in a typesafe manner by using a type level DSL.</p>
<p>Here comes the declaration of our API (please note that we declare our routes to accept and emit data in JSON format):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a><span class="co">-- | in order to allow JSON serialization for the Dom.Reservation type, it must instantiate FromJSON and ToJSON.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Dom.Reservation</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Dom.Reservation</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a><span class="co">-- | Declaring the routes of the REST API for Restaurant Reservations</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">ReservationAPI</span> <span class="ot">=</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>       <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve a map of all reservations (Day -&gt; [Reservation])&quot;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.ReservationMap</span> <span class="co">-- GET    /reservations</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve list of reservations for a given day&quot;</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;day&quot;</span> <span class="dt">Day</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] [<span class="dt">Dom.Reservation</span>]  <span class="co">-- GET    /reservations/YYYY-MM-DD</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;place a new reservation&quot;</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.Reservation</span></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Post</span>    &#39;[ <span class="dt">JSON</span>] ()                 <span class="co">-- POST   /reservations</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;reservations&quot;</span> <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;cancel a reservation&quot;</span></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[ <span class="dt">JSON</span>] <span class="dt">Dom.Reservation</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Delete</span>  &#39;[ <span class="dt">JSON</span>] ()                 <span class="co">-- DELETE /reservations</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true"></a>                      </span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span> <span class="st">&quot;seats&quot;</span>        <span class="op">:&gt;</span> <span class="dt">Summary</span> <span class="st">&quot;retrieve number of free seats for a given day&quot;</span></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;day&quot;</span> <span class="dt">Day</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true"></a>                      <span class="op">:&gt;</span> <span class="dt">Get</span>     &#39;[ <span class="dt">JSON</span>] <span class="dt">Natural</span>                <span class="co">-- GET    /seats/YYYY-MM-DD</span></span></code></pre></div>
<p>Next we have to create the connection between the declared routes and the actual business logic. This will be our REST service implementation. In our case we simply delegate to the use case controller functions. Off course, we might also implement additional functionality here like validation:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">UseCases.ReservationUseCase</span> <span class="kw">as</span> <span class="dt">UC</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="co">-- | implements the ReservationAPI</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">reservationServer ::</span> (<span class="dt">Member</span> <span class="dt">UC.Persistence</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">UC.ReservationError</span>) r, </span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a>                      <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r) <span class="ot">=&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> (<span class="dt">Sem</span> r)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true"></a>reservationServer <span class="ot">=</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true"></a>        UC.listAll        <span class="co">-- GET    /reservations</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.fetch          <span class="co">-- GET    /reservations/YYYY-MM-DD</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.tryReservation <span class="co">-- POST   /reservations</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.cancel         <span class="co">-- DELETE /reservations</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true"></a>  <span class="op">:&lt;|&gt;</span>  UC.availableSeats <span class="co">-- GET    /seats/YYYY-MM-DD</span></span></code></pre></div>
<p>I really love how <strong>declarative</strong> this code is. <strong>We don’t have to tell how</strong> to exchange data between the REST server and the use case controllers.</p>
<p>We <strong>just tell what we want</strong>: a mapping from the routes to the controller functions. That’s all!</p>
<p>In the following diagram, we now see the third layer. Again, the arrow symbolises the dependency rule, which prohibits access from domain or use case layer to the interface adapters layer. To the right we see the <code>ReservationAPI</code> and its <code>reservationServer</code> implementation, which we just explored. They interact with the use case controller functions like <code>availableSeats</code>, <code>listAll</code>, etc.</p>
<p>To the left we see the interpretations of the <code>KVS</code> effect (which was defined in the use case layer): <code>KVSInMemory</code>, <code>KVSSqlite</code> (and a third one <code>KVSFileServer</code>, a file based implementation which you could <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/InterfaceAdapters/KVSFileServer.hs">explore on your own</a>).</p>
<figure>
<img src="/img/interface-adapters.png" alt="" /><figcaption>Interface Adapters layer</figcaption>
</figure>
<h3 id="testing-the-kvs-implementations">Testing the KVS implementations</h3>
<p>We’ll have a closer look at the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/test/InterfaceAdaptersKVSSQLiteSpec.hs">test of the SQLite implementation</a> of the <code>KVS</code> effect.</p>
<p>As Polysemy effects are involded we will need to provide an interpretation to actually perform the SQLLite operation.</p>
<p>The test setup looks quite similar to the tests in the use case layer.</p>
<p>We want our test to evaluate the KVS implementation independently of the domain logic and the use case layer. Therefore, we first define an example use case, featuring a data type <code>Memo</code> and a set of typical CRUD operations. The CRUD operations are using the <code>KVS</code> smart constructors and thus exhibit the typical Polysemy effect signatures:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="co">-- | a key value table mapping Natural to a list of Strings</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">KeyValueTable</span> <span class="ot">=</span> <span class="dt">KVS</span> <span class="dt">Int</span> [<span class="dt">String</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Memo</span> <span class="ot">=</span> <span class="dt">Memo</span> <span class="dt">Int</span> [<span class="dt">String</span>]</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a><span class="ot">persistMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r)  <span class="ot">=&gt;</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>persistMemo (<span class="dt">Memo</span> <span class="fu">id</span> <span class="fu">lines</span> ) <span class="ot">=</span> insertKvs <span class="fu">id</span> <span class="fu">lines</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a><span class="ot">fetchMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Maybe</span> [<span class="dt">String</span>])</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>fetchMemo <span class="ot">=</span> getKvs</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a><span class="ot">fetchAll ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r) <span class="ot">=&gt;</span> <span class="dt">Sem</span> r (<span class="dt">M.Map</span> <span class="dt">Int</span> [<span class="dt">String</span>])</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>fetchAll <span class="ot">=</span> <span class="fu">fmap</span> M.fromList listAllKvs</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true"></a><span class="ot">deleteMemo ::</span> (<span class="dt">Member</span> <span class="dt">KeyValueTable</span> r)  <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true"></a>deleteMemo <span class="ot">=</span> deleteKvs</span></code></pre></div>
<p>Next we define a set of helper functions that allow us to execute the CRUD operations as ordinary <code>IO ()</code> actions, which we can use in our test code:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="co">-- Helper functions for interpreting all effects in IO</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="ot">runPersist ::</span> <span class="dt">Memo</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>runPersist memo <span class="ot">=</span> runAllEffects (persistMemo memo)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">runFetch ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> [<span class="dt">String</span>])</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>runFetch k <span class="ot">=</span> runAllEffects (fetchMemo k)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a><span class="ot">runFetchAll ::</span> <span class="dt">IO</span> (<span class="dt">M.Map</span> <span class="dt">Int</span> [<span class="dt">String</span>])</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>runFetchAll <span class="ot">=</span> runAllEffects fetchAll</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true"></a><span class="ot">runDelete ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true"></a>runDelete k <span class="ot">=</span> runAllEffects (deleteMemo k)</span></code></pre></div>
<p>These wrapper function make use of the <code>runAllEffects</code> function that takes a program with effects and handles each effect till it gets reduced to <code>IO a</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">runAllEffects ::</span> <span class="dt">Sem</span> &#39;[<span class="dt">KeyValueTable</span>, <span class="dt">Input</span> <span class="dt">Config</span>, <span class="dt">Trace</span>, <span class="dt">Embed</span> <span class="dt">IO</span>] a <span class="ot">-&gt;</span> <span class="dt">IO</span> a </span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>runAllEffects program <span class="ot">=</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  program</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>    <span class="op">&amp;</span> runKvsAsSQLite       <span class="co">-- use SQLite based interpretation of the (KVS Int [String]) effect</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    <span class="op">&amp;</span> runInputConst config <span class="co">-- use the variable config as source for (Input Config) effect</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    <span class="op">&amp;</span> ignoreTrace          <span class="co">-- ignore all traces</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>    <span class="op">&amp;</span> runM                 <span class="co">-- reduce Sem r (Embed IO a) to IO a</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>  <span class="kw">where</span> config <span class="ot">=</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs-test.db&quot;</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, verbose <span class="ot">=</span> <span class="dt">False</span>}</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a><span class="co">-- errors are rethrown as Runtime errors, which can be verified by HSpec.</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true"></a><span class="ot">handleErrors ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> err a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true"></a>handleErrors e <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true"></a>  <span class="fu">either</span> <span class="ot">&lt;-</span> e</span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true"></a>  <span class="kw">case</span> <span class="fu">either</span> <span class="kw">of</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true"></a>    <span class="dt">Right</span> v <span class="ot">-&gt;</span> <span class="fu">return</span> v</span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true"></a>    <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;something bad happend&quot;</span></span></code></pre></div>
<p>With these preliminaries at hand we can now write our test cases:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>key <span class="ot">=</span> <span class="dv">4711</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>text <span class="ot">=</span> [<span class="st">&quot;In the morning&quot;</span>, <span class="st">&quot;I don&#39;t drink coffee&quot;</span>, <span class="st">&quot;But lots of curcuma chai.&quot;</span>]</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>memo <span class="ot">=</span> <span class="dt">Memo</span> key text</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>  describe <span class="st">&quot;The KV Store SQLite Implementation&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>    it <span class="st">&quot;returns Nothing if nothing can be found for a given id&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Nothing</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true"></a>    it <span class="st">&quot;persists a key-value pair to the SQLite database&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true"></a>      runPersist memo</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Just</span> text</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true"></a></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true"></a>    it <span class="st">&quot;fetches a Map of all key-value entries from the KV store&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true"></a>      <span class="fu">map</span> <span class="ot">&lt;-</span> runFetchAll</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true"></a>      M.size <span class="fu">map</span> <span class="ot">`shouldBe`</span> <span class="dv">1</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true"></a></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true"></a>    it <span class="st">&quot;deletes an entry from the key value store&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true"></a>      runDelete key</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true"></a>      maybeMatch <span class="ot">&lt;-</span> runFetch key</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true"></a>      maybeMatch <span class="ot">`shouldBe`</span> <span class="dt">Nothing</span></span></code></pre></div>
<h3 id="testing-the-rest-api">Testing the REST API</h3>
<p>The actual code for testing the REST API looks pretty straightforward. We create a <a href="https://hackage.haskell.org/package/wai">WAI</a> <code>Application</code> instance with <code>createApp</code> and execute REST operations like <code>get</code> and <code>postJSON</code> against it:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">reservationData ::</span> <span class="dt">LB.ByteString</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>reservationData <span class="ot">=</span> <span class="st">&quot;{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:10,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Amelia Jones\&quot;}&quot;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>postJSON   path <span class="ot">=</span> request methodPost   path [(hContentType, <span class="st">&quot;application/json&quot;</span>)]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a>deleteJSON path <span class="ot">=</span> request methodDelete path [(hContentType, <span class="st">&quot;application/json&quot;</span>)]</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a>  with (createApp) <span class="op">$</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>    describe <span class="st">&quot;Rest Service&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a call GET /reservations &quot;</span> <span class="op">$</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>        get <span class="st">&quot;/reservations&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;{\&quot;2020-05-02\&quot;:[{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:4,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Andrew M. Jones\&quot;}]}&quot;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid POST /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>        postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>      it <span class="st">&quot;responds with 412 if a reservation can not be done on a given day&quot;</span> <span class="op">$</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a>        (postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="op">&gt;&gt;</span> postJSON <span class="st">&quot;/reservations&quot;</span> reservationData) <span class="ot">`shouldRespondWith`</span> <span class="dv">412</span></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid DELETE /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a>        deleteJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span></code></pre></div>
<p>Please note that these tests don’t need a deployment of the WAI application to a web server. ALl testing can be done within a single process. We stick to the dependency rule not to use anything from a more outward layer.</p>
<p>The interesting part is the creation of the <code>Application</code> instance.</p>
<p>If we had a simple implementation <code>myServer</code> of a REST API <code>myApi</code>, not using any Polysemy effects, we could create an <code>Application</code> instance like so:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="ot">createSimpleApp ::</span> <span class="dt">Application</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>createSimpleApp <span class="op">::=</span> serve myApi myServer</span></code></pre></div>
<p>In contrast, our <code>reservationServer</code> has a type signature that contains Polysemy effects:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="ot">reservationServer ::</span> (<span class="dt">Member</span> <span class="dt">UC.Persistence</span> r, <span class="dt">Member</span> (<span class="dt">Error</span> <span class="dt">UC.ReservationError</span>) r, </span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>                      <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r) <span class="ot">=&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> (<span class="dt">Sem</span> r)</span></code></pre></div>
<p>Instead of building the <code>Application</code> instance directly, as in the simple example, we use <code>liftServer</code> to lift <code>reservationServer</code> into the required <code>ServerT ReservationAPI Handler</code> type by running all effects and by lifting the business logic exception <code>ReservationNotPossible</code> into a Servant <code>ServerError</code>. This time we also use the SQLite based interpretation of the <code>KVS</code> effect:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Application</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>createApp config <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> serve reservationAPI (liftServer config)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a><span class="ot">liftServer ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">ReservationAPI</span> <span class="dt">Handler</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>liftServer config <span class="ot">=</span> hoistServer reservationAPI (interpretServer config) reservationServer</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a>    interpretServer config sem <span class="ot">=</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>      sem</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>        <span class="op">&amp;</span> runKvsAsSQLite</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>        <span class="op">&amp;</span> runInputConst config</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>        <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a>        <span class="op">&amp;</span> ignoreTrace</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>        <span class="op">&amp;</span> runM</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>        <span class="op">&amp;</span> liftToHandler</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> (<span class="fu">fmap</span> handleErrors)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 {errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span></code></pre></div>
<h2 id="the-external-interfaces-layer">The External Interfaces layer</h2>
<blockquote>
<p>The outermost layer is generally composed of frameworks and tools such as the Database, the Web Framework, etc. Generally you don’t write much code in this layer other than glue code that communicates to the next circle inwards.</p>
<p>This layer is where all the details go. The Web is a detail. The database is a detail. We keep these things on the outside where they can do little harm.</p>
<p>Quoted from <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>For the database we are already finished as the <a href="https://hackage.haskell.org/package/sqlite-simple">SQlite-Simple</a> library includes the SQLLite C runtime library and is thus self-contained.</p>
<p>We will use <a href="http://www.aosabook.org/en/posa/warp.html">WARP</a> as our Web Server, which can be used as a library within our <code>Main</code> program. What we still have to do though, is to assemble a Servant web <code>Application</code> so that it can be executed on the warp server.</p>
<p>We have done this step already for the testing of the REST service. The <code>createApp</code> function that we define in the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/src/ExternalInterfaces/ApplicationAssembly.hs">ApplicationAssembly module</a> will look quite familiar, it just provides some more bells and whistles to integrate all the features that we have developed so far.</p>
<ul>
<li><code>createApp</code> accepts a <code>Config</code> parameter which is used to configure application settings.</li>
<li><code>selectKvsBackend</code> selects the concrete <code>KVS</code> interpretation.</li>
<li><code>selectTraceVerbosity</code> selects the <code>Trace</code> interpretation:</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="co">-- | creates the WAI Application that can be executed by Warp.run.</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a><span class="ot">createApp ::</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Application</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>createApp config <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>  <span class="fu">return</span> (serve reservationAPI <span class="op">$</span> hoistServer reservationAPI (interpretServer config) reservationServer)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>    interpretServer config sem  <span class="ot">=</span>  sem</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>      <span class="op">&amp;</span> selectKvsBackend config</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>      <span class="op">&amp;</span> runInputConst config</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>      <span class="op">&amp;</span> runError <span class="op">@</span><span class="dt">ReservationError</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>      <span class="op">&amp;</span> selectTraceVerbosity config</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>      <span class="op">&amp;</span> runM</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>      <span class="op">&amp;</span> liftToHandler</span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>    liftToHandler <span class="ot">=</span> <span class="dt">Handler</span> <span class="op">.</span> <span class="dt">ExceptT</span> <span class="op">.</span> (<span class="fu">fmap</span> handleErrors)</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>    handleErrors (<span class="dt">Left</span> (<span class="dt">ReservationNotPossible</span> msg)) <span class="ot">=</span> <span class="dt">Left</span> err412 { errBody <span class="ot">=</span> <span class="fu">pack</span> msg}</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>    handleErrors (<span class="dt">Right</span> value) <span class="ot">=</span> <span class="dt">Right</span> value</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a><span class="co">-- | can select between SQLite or FileServer persistence backends.</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a><span class="ot">selectKvsBackend ::</span> (<span class="dt">Member</span> (<span class="dt">Input</span> <span class="dt">Config</span>) r, <span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r, <span class="dt">Member</span> <span class="dt">Trace</span> r, <span class="dt">Show</span> k, <span class="dt">Read</span> k, <span class="dt">ToJSON</span> v, <span class="dt">FromJSON</span> v)</span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true"></a>                 <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">KVS</span> k v <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true"></a>selectKvsBackend config <span class="ot">=</span> <span class="kw">case</span> backend config <span class="kw">of</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true"></a>  <span class="dt">SQLite</span>     <span class="ot">-&gt;</span> runKvsAsSQLite</span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true"></a>  <span class="dt">FileServer</span> <span class="ot">-&gt;</span> runKvsAsFileServer</span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true"></a>  <span class="dt">InMemory</span>   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;not supported&quot;</span></span>
<span id="cb34-24"><a href="#cb34-24" aria-hidden="true"></a></span>
<span id="cb34-25"><a href="#cb34-25" aria-hidden="true"></a><span class="co">-- | if the config flag verbose is set to True, trace to Console, else ignore all trace messages</span></span>
<span id="cb34-26"><a href="#cb34-26" aria-hidden="true"></a><span class="ot">selectTraceVerbosity ::</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> <span class="dt">IO</span>) r) <span class="ot">=&gt;</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> (<span class="dt">Sem</span> (<span class="dt">Trace</span> <span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a)</span>
<span id="cb34-27"><a href="#cb34-27" aria-hidden="true"></a>selectTraceVerbosity config <span class="ot">=</span></span>
<span id="cb34-28"><a href="#cb34-28" aria-hidden="true"></a>  <span class="kw">if</span> verbose config</span>
<span id="cb34-29"><a href="#cb34-29" aria-hidden="true"></a>    <span class="kw">then</span> traceToIO</span>
<span id="cb34-30"><a href="#cb34-30" aria-hidden="true"></a>    <span class="kw">else</span> ignoreTrace</span></code></pre></div>
<p>The application assembly also features a function to load a <code>Config</code> instance. Typically, this would involve loading a configuration file or reading command line arguments. We take a shortcut here and just provide a static instance:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="co">-- | load application config. In real life, this would load a config file or read commandline args.</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="ot">loadConfig ::</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>loadConfig <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs.db&quot;</span>, verbose <span class="ot">=</span> <span class="dt">True</span>}</span></code></pre></div>
<p>With the whole application assembly written as library code, there is not much left to do in the <code>Main</code> module:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">ExternalInterfaces.ApplicationAssembly</span> (createApp, loadConfig)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">InterfaceAdapters.Config</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a><span class="kw">import</span>           <span class="dt">Network.Wai.Handler.Warp</span>               (run)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true"></a>  config <span class="ot">&lt;-</span> loadConfig</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true"></a>  app    <span class="ot">&lt;-</span> createApp config</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Starting server on port &quot;</span> <span class="op">++</span> <span class="fu">show</span> (port config)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true"></a>  run (port config) app</span></code></pre></div>
<p>The following diagram shows the elements added by the External Interface layer: - On the left we have application assembly code like <code>createApp</code> used by the <code>Warp</code> server or some of the different <code>runPure</code> functions that we used in HSpec tests. - On the right we have the SQLite runtime library that provides access to the SQLite database and the Haskell runtime in general, which provides access to the filesystem and the OS in general.</p>
<figure>
<img src="/img/clean-architecture.png" alt="" /><figcaption>External Interfaces layer</figcaption>
</figure>
<h3 id="testing-1">Testing</h3>
<p>Testing the application assembly is quite straightforward and resembles the testing of the REST service:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="ot">loadConfig ::</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>loadConfig <span class="ot">=</span> <span class="fu">return</span> <span class="dt">Config</span> {port <span class="ot">=</span> <span class="dv">8080</span>, backend <span class="ot">=</span> <span class="dt">SQLite</span>, dbPath <span class="ot">=</span> <span class="st">&quot;kvs-assembly.db&quot;</span>, verbose <span class="ot">=</span> <span class="dt">False</span>}</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a>spec <span class="ot">=</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a>  with (loadConfig <span class="op">&gt;&gt;=</span> createApp) <span class="op">$</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a>    describe <span class="st">&quot;Rest Service&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a>      it <span class="st">&quot;responds with 20 for a first call to GET /seats/YYYY-MM-DD&quot;</span> <span class="op">$</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true"></a>        get <span class="st">&quot;/seats/2020-05-02&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;20&quot;</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true"></a></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid POST /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true"></a>        postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true"></a></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a call GET /reservations &quot;</span> <span class="op">$</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true"></a>        get <span class="st">&quot;/reservations&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;{\&quot;2020-05-02\&quot;:[{\&quot;email\&quot;:\&quot;amjones@example.com\&quot;,\&quot;quantity\&quot;:12,\&quot;date\&quot;:\&quot;2020-05-02\&quot;,\&quot;name\&quot;:\&quot;Amelia Jones\&quot;}]}&quot;</span></span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true"></a></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true"></a>      it <span class="st">&quot;responds with 412 if a reservation can not be done on a given day&quot;</span> <span class="op">$</span></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true"></a>        (postJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="op">&gt;&gt;</span> postJSON <span class="st">&quot;/reservations&quot;</span> reservationData) <span class="ot">`shouldRespondWith`</span> <span class="dv">412</span></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true"></a></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true"></a>      it <span class="st">&quot;responds with 20 for a first call to GET /seats/YYYY-MM-DD&quot;</span> <span class="op">$</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true"></a>        get <span class="st">&quot;/seats/2020-05-02&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;8&quot;</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true"></a>      it <span class="st">&quot;responds with 200 for a valid DELETE /reservations&quot;</span> <span class="op">$</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true"></a>        deleteJSON <span class="st">&quot;/reservations&quot;</span> reservationData <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span></span></code></pre></div>
<h2 id="swagger-documentation">Swagger Documentation</h2>
<p>For all those who have been patient enough to stay with me until here, I now have a little bonus.</p>
<p>There is a <a href="https://github.com/haskell-servant/servant-swagger-ui">servant-swagger-ui addon</a> available which allows to serve a <a href="https://swagger.io/tools/swagger-ui/">SwaggerDoc UI</a> for any Servant API. This UI renders an automatically generated documentation of our Reservation API and even allows to test all API operations directly.</p>
<p>You can launch it by executing <code>stack build --exec PolysemyCleanArchitecture</code> in the root folder of the project.</p>
<p>This will launch the REST service and open up the Swagger UI in your Web browser:</p>
<figure>
<img src="/img/swaggerUI.png" alt="" /><figcaption>Swagger UI</figcaption>
</figure>
<p>The code for this goody can be found in the <a href="https://github.com/thma/PolysemyCleanArchitecture/tree/master/app/SwaggerUI.hs">SwaggerUI</a> module.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Robert C. Martin concludes his blog post with a brief summary:</p>
<blockquote>
<p>Conforming to these simple rules is not hard, and will save you a lot of headaches going forward. By separating the software into layers, and conforming to The Dependency Rule, you will create a system that is <strong>intrinsically testable</strong>, with all the benefits that implies. When any of the external parts of the system become obsolete, like the database, or the web framework, you can <strong>replace those obsolete elements with a minimum of fuss</strong>.</p>
<p>Quoted from the <a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">Clean Architecture blog post</a></p>
</blockquote>
<p>I have emphasized the testability aspect quite a lot in this article. However, this approach allows switching freely between alternative backends in production environments as well.</p>
<p>As we have seen Polysemy — or algebraic effect systems in general — make this possible by the separation of effect <em>declaration</em>, effect <em>usage</em> and effect <em>interpretation</em>.</p>
<p>Furthermore, Polysemy also allows you to freely combine several effects. This is a huge gain in software composability.</p>
]]></summary>
</entry>
<entry>
    <title>Proof of functor laws for Maybe</title>
    <link href="https://thma.github.io//posts/2020-04-17-maybe-functor-law-proof.html" />
    <id>https://thma.github.io//posts/2020-04-17-maybe-functor-law-proof.html</id>
    <published>2020-04-17T00:00:00Z</published>
    <updated>2020-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<div class="info">
    <em>Posted on April 17, 2020
    
        by Thomas Mahler
    </em><br/><br/>
</div>

<p>In this post I want to give a short example of how equational reasoning can be used to proof certain properties of a given piece of code in Haskell.</p>
<p>So without further ado let’s begin:</p>
<h2 id="known-facts">Known facts</h2>
<p>The <code>Functor</code> instance declaration of the type <code>Maybe</code> is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">instance</span>  <span class="dt">Functor</span> <span class="dt">Maybe</span>  <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>    <span class="fu">fmap</span> _ <span class="dt">Nothing</span>       <span class="ot">=</span> <span class="dt">Nothing</span>       <span class="co">-- (1)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="fu">fmap</span> f (<span class="dt">Just</span> a)      <span class="ot">=</span> <span class="dt">Just</span> (f a)    <span class="co">-- (2)</span></span></code></pre></div>
<p>The composition operator <code>(.)</code> is defined as:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>f <span class="op">.</span> g x <span class="ot">=</span> f (g x)                        <span class="co">-- (3)</span></span></code></pre></div>
<p>The Identity function <code>id</code> is defined as:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">id</span> x <span class="ot">=</span>  x                                <span class="co">-- (4)</span></span></code></pre></div>
<h2 id="claim">Claim</h2>
<p>The claim is that <code>Maybe</code> fulfils the two functor laws:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dv">1</span><span class="op">.:</span> <span class="fu">fmap</span> <span class="fu">id</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="dv">2</span><span class="op">.:</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="ot">=</span> (<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g)</span></code></pre></div>
<h2 id="proof-of-the-first-law">Proof of the first law</h2>
<p><strong>Claim:</strong> <code>fmap id m = id m</code>, for any <code>m</code> of type <code>Maybe a</code>.</p>
<p><strong>Proof.</strong> On cases of <code>m</code>.</p>
<p><em>Case 1:</em> <code>m = Nothing</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="fu">id</span> m <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">id</span> <span class="dt">Nothing</span> <span class="co">-- by expansion of m</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Nothing</span>         <span class="co">-- by applying equation (1)</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>          <span class="ot">=</span> <span class="fu">id</span> m            <span class="co">-- by definition m, by applying equation (4)</span></span></code></pre></div>
<p><em>Case 2:</em> <code>m = Just a</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="fu">id</span> m <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">id</span> (<span class="dt">Just</span> a) <span class="co">-- by expansion of m</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Just</span> (<span class="fu">id</span> a)      <span class="co">-- by applying equation (2)</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>          <span class="ot">=</span> <span class="dt">Just</span> a           <span class="co">-- by expansion of id (equation (4))</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>          <span class="ot">=</span> m                <span class="co">-- by definition of m</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>          <span class="ot">=</span> <span class="fu">id</span> m             <span class="co">-- by applying equation (4)</span></span></code></pre></div>
<p>Therefore, <code>fmap id m = id m</code> in all cases.∎</p>
<h2 id="proof-of-the-second-law">Proof of the second law</h2>
<p><strong>Claim:</strong> <code>fmap (f . g) m = (fmap f . fmap g) m</code>, for any <code>m</code> of type <code>Maybe a</code>.</p>
<p><strong>Proof.</strong> On cases of <code>m</code>.</p>
<p><em>Case 1:</em> <code>m = Nothing</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) m      <span class="ot">=</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="dt">Nothing</span>    <span class="co">-- by expansion of m</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Nothing</span>                 <span class="co">-- by applying equation (1)</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>(<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g) m <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g <span class="dt">Nothing</span>) <span class="co">-- by applying equation (4) and expanding m</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="fu">fmap</span> f <span class="dt">Nothing</span>          <span class="co">-- by applying equation (1)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Nothing</span>                 <span class="co">-- by applying equation (1)</span></span></code></pre></div>
<p><em>Case 2:</em> <code>m = Just a</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) m      <span class="ot">=</span> <span class="fu">fmap</span> (f <span class="op">.</span> g) (<span class="dt">Just</span> a)    <span class="co">-- by expansion of m</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> ((f <span class="op">.</span> g) a)         <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>(<span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g) m <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="fu">fmap</span> g (<span class="dt">Just</span> a)) <span class="co">-- by applying equation (4) and expanding m</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> (g a))      <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> (f (g a)            <span class="co">-- by applying equation (2)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>                    <span class="ot">=</span> <span class="dt">Just</span> ((f <span class="op">.</span> g) a)         <span class="co">-- by applying equation (3)</span></span></code></pre></div>
<p>Therefore, <code>fmap (f . g) m = (fmap f . fmap g) m</code> in all cases. ∎</p>
<h2 id="conclusion">Conclusion</h2>
<p>You’ll see this kind of reasoning quite a lot in Haskell documentation and online discussions. The simple reason is: if you can prove something you don’t have to test it.</p>
]]></summary>
</entry>

</feed>
